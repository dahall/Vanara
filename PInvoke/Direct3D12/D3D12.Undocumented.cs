#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
namespace Vanara.PInvoke;

public static partial class D3D12
{
	public enum D3D12_DISPATCH_MODE
	{
		D3D12_DISPATCH_MODE_NODE_CPU_INPUT,
		D3D12_DISPATCH_MODE_NODE_GPU_INPUT,
		D3D12_DISPATCH_MODE_MULTI_NODE_CPU_INPUT,
		D3D12_DISPATCH_MODE_MULTI_NODE_GPU_INPUT
	}

	public enum D3D12_PROGRAM_TYPE
	{
		D3D12_PROGRAM_TYPE_GENERIC_PIPELINE = 1,
		D3D12_PROGRAM_TYPE_RAYTRACING_PIPELINE = 4,
		D3D12_PROGRAM_TYPE_WORK_GRAPH = 5
	}

	[Flags]
	public enum D3D12_SET_WORK_GRAPH_FLAGS
	{
		D3D12_SET_WORK_GRAPH_FLAG_NONE = 0,
		D3D12_SET_WORK_GRAPH_FLAG_INITIALIZE = 1
	}

	[ComImport]
	[Guid("5405c344-d457-444e-b4dd-2366e45aee39")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ID3D12Device11 : ID3D12Device10, ID3D12Device9, ID3D12Device8, ID3D12Device7, ID3D12Device6, ID3D12Device5, ID3D12Device4, ID3D12Device3, ID3D12Device2, ID3D12Device1, ID3D12Device, ID3D12Object
	{
		/// <summary>Gets application-defined data from a device object.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> that is associated with the data.</para>
		/// </param>
		/// <param name="pDataSize">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a variable that on input contains the size, in bytes, of the buffer that <i>pData</i> points to, and on output
		/// contains the size, in bytes, of the amount of data that <b>GetPrivateData</b> retrieved.
		/// </para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a memory block that receives the data from the device object if <i>pDataSize</i> points to a value that specifies a
		/// buffer large enough to hold the data.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// If the data returned is a pointer to an <c>IUnknown</c>, or one of its derivative classes, which was previously set by
		/// SetPrivateDataInterface, that interface will have its reference count incremented before the private data is returned.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-getprivatedata HRESULT GetPrivateData( [in]
		// REFGUID guid, [in, out] UINT *pDataSize, [out, optional] void *pData );
		[PreserveSig]
		new HRESULT GetPrivateData(in Guid guid, ref uint pDataSize, [Out, Optional] IntPtr pData);

		/// <summary>Sets application-defined data to a device object and associates that data with an application-defined <b>GUID</b>.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the data.</para>
		/// </param>
		/// <param name="DataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size in bytes of the data.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>
		/// A pointer to a memory block that contains the data to be stored with this device object. If <i>pData</i> is <b>NULL</b>,
		/// <i>DataSize</i> must also be 0, and any data that was previously associated with the <b>GUID</b> specified in <i>guid</i> will
		/// be destroyed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// Rather than using the Direct3D 11 debug object naming scheme of calling <b>ID3D12Object::SetPrivateData</b> using
		/// <b>WKPDID_D3DDebugObjectName</b> with an ASCII name, call <c>ID3D12Object::SetName</c> with a UNICODE name.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedata HRESULT SetPrivateData( [in]
		// REFGUID guid, [in] UINT DataSize, [in, optional] const void *pData );
		[PreserveSig]
		new HRESULT SetPrivateData(in Guid guid, uint DataSize, [In, Optional] IntPtr pData);

		/// <summary>
		/// Associates an <c>IUnknown</c>-derived interface with the device object, and associates that interface with an
		/// application-defined <b>GUID</b>.
		/// </summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the interface.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const <c>IUnknown</c>*</b></para>
		/// <para>
		/// A pointer to the <c>IUnknown</c>-derived interface to be associated with the device object. Its reference count is incremented
		/// when set, and its reference count is decremented when either the <c>ID3D12Object</c> is destroyed, or when the data is
		/// overwritten by calling <c>SetPrivateData</c> or <b>SetPrivateDataInterface</b> with the same <b>GUID</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 return codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedatainterface HRESULT
		// SetPrivateDataInterface( [in] REFGUID guid, [in, optional] const IUnknown *pData );
		[PreserveSig]
		new HRESULT SetPrivateDataInterface(in Guid guid, [In, Optional, MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 0)] object? pData);

		/// <summary>Associates a name with the device object. This name is for use in debug diagnostics and tools.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the device object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>This method takes UNICODE names.</para>
		/// <para>
		/// Note that this is simply a convenience wrapper around <c>ID3D12Object::SetPrivateData</c> with
		/// <b>WKPDID_D3DDebugObjectNameW</b>. Therefore names which are set with <c>SetName</c> can be retrieved with
		/// <c>ID3D12Object::GetPrivateData</c> with the same GUID. Additionally, D3D12 supports narrow strings for names, using the
		/// <b>WKPDID_D3DDebugObjectName</b> GUID directly instead.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setname HRESULT SetName( [in] LPCWSTR Name );
		[PreserveSig]
		new HRESULT SetName([MarshalAs(UnmanagedType.LPWStr)] string Name);

		/// <summary>Reports the number of physical adapters (nodes) that are associated with this device.</summary>
		/// <returns>
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of physical adapters (nodes) that this device has.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getnodecount UINT GetNodeCount();
		[PreserveSig]
		new uint GetNodeCount();

		/// <summary>
		/// <para>Creates a command queue.</para>
		/// <para>Also see <c>ID3D12Device9::CreateCommandQueue1</c>.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_COMMAND_QUEUE_DESC</c>*</b></para>
		/// <para>Specifies a <b>D3D12_COMMAND_QUEUE_DESC</b> that describes the command queue.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier (GUID) for the command queue interface. See <b>Remarks</b>. An input parameter.</para>
		/// </param>
		/// <param name="ppCommandQueue">
		/// <para>Type: [out] <b><b>void</b>**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandQueue</c> interface for the command queue.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the command queue. See <c>Direct3D 12 return
		/// codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the command queue can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12CommandQueue) will get the <b>GUID</b> of the interface to a command queue.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandqueue HRESULT CreateCommandQueue(
		// const D3D12_COMMAND_QUEUE_DESC *pDesc, REFIID riid, void **ppCommandQueue );
		[PreserveSig]
		new HRESULT CreateCommandQueue(in D3D12_COMMAND_QUEUE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppCommandQueue);

		/// <summary>Creates a command allocator object.</summary>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>
		/// A <c>D3D12_COMMAND_LIST_TYPE</c>-typed value that specifies the type of command allocator to create. The type of command
		/// allocator can be the type that records either direct command lists or bundles.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the command allocator interface ( <c>ID3D12CommandAllocator</c>). The
		/// <b>REFIID</b>, or <b>GUID</b>, of the interface to the command allocator can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12CommandAllocator) will get the <b>GUID</b> of the interface to a command allocator.
		/// </para>
		/// </param>
		/// <param name="ppCommandAllocator">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandAllocator</c> interface for the command allocator.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the command allocator. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The device creates command lists from the command allocator. Examples The <c>D3D12Bundles</c> sample uses
		/// <b>ID3D12Device::CreateCommandAllocator</b> as follows:
		/// </para>
		/// <para>
		/// <c>ThrowIfFailed(pDevice-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&amp;m_commandAllocator)));
		/// ThrowIfFailed(pDevice-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_BUNDLE, IID_PPV_ARGS(&amp;m_bundleAllocator)));</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandallocator HRESULT
		// CreateCommandAllocator( [in] D3D12_COMMAND_LIST_TYPE type, REFIID riid, [out] void **ppCommandAllocator );
		[PreserveSig]
		new HRESULT CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE type, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppCommandAllocator);

		/// <summary>Creates a graphics pipeline state object.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c> structure that describes graphics pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>). The <b>REFIID</b>,
		/// or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For example,
		/// __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// The pipeline state object is an immutable state object. It contains no methods.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-creategraphicspipelinestate HRESULT
		// CreateGraphicsPipelineState( [in] const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreateGraphicsPipelineState(in D3D12_GRAPHICS_PIPELINE_STATE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>Creates a compute pipeline state object.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c> structure that describes compute pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>). The <b>REFIID</b>,
		/// or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For example,
		/// __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// The pipeline state object is an immutable state object. It contains no methods.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcomputepipelinestate HRESULT
		// CreateComputePipelineState( [in] const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreateComputePipelineState(in D3D12_COMPUTE_PIPELINE_STATE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>Creates a command list.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set a bit to identify the node (the device's
		/// physical adapter) for which to create the command list. Each bit in the mask corresponds to a single node. Only one bit must be
		/// set. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>Specifies the type of command list to create.</para>
		/// </param>
		/// <param name="pCommandAllocator">
		/// <para>Type: <b><c>ID3D12CommandAllocator</c>*</b></para>
		/// <para>A pointer to the command allocator object from which the device creates command lists.</para>
		/// </param>
		/// <param name="pInitialState">
		/// <para>Type: <b><c>ID3D12PipelineState</c>*</b></para>
		/// <para>
		/// An optional pointer to the pipeline state object that contains the initial pipeline state for the command list. If it is
		/// <c>nullptr</c>, then the runtime sets a dummy initial pipeline state, so that drivers don't have to deal with undefined state.
		/// The overhead for this is low, particularly for a command list, for which the overall cost of recording the command list likely
		/// dwarfs the cost of a single initial state setting. So there's little cost in not setting the initial pipeline state parameter,
		/// if doing so is inconvenient.
		/// </para>
		/// <para>
		/// For bundles, on the other hand, it might make more sense to try to set the initial state parameter (since bundles are likely
		/// smaller overall, and can be reused frequently).
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the command list interface to return in ppCommandList.</para>
		/// </param>
		/// <param name="ppCommandList">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12CommandList</c> or <c>ID3D12GraphicsCommandList</c>
		/// interface for the command list.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the command list.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>The device creates command lists from the command allocator.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandlist HRESULT CreateCommandList( [in]
		// UINT nodeMask, [in] D3D12_COMMAND_LIST_TYPE type, [in] ID3D12CommandAllocator *pCommandAllocator, [in, optional]
		// ID3D12PipelineState *pInitialState, [in] REFIID riid, [out] void **ppCommandList );
		[PreserveSig]
		new HRESULT CreateCommandList(uint nodeMask, D3D12_COMMAND_LIST_TYPE type, [In] ID3D12CommandAllocator pCommandAllocator, [In, Optional] ID3D12PipelineState? pInitialState,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppCommandList);

		/// <summary>Gets information about the features that are supported by the current graphics driver.</summary>
		/// <param name="Feature">
		/// <para>Type: <b><c>D3D12_FEATURE</c></b></para>
		/// <para>A constant from the <c>D3D12_FEATURE</c> enumeration describing the feature(s) that you want to query for support.</para>
		/// </param>
		/// <param name="pFeatureSupportData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a data structure that corresponds to the value of the <i>Feature</i> parameter. To determine the corresponding data
		/// structure for each constant, see <c>D3D12_FEATURE</c>.
		/// </para>
		/// </param>
		/// <param name="FeatureSupportDataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size of the structure pointed to by the <i>pFeatureSupportData</i> parameter.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// Returns <b>S_OK</b> if successful. Returns <b>E_INVALIDARG</b> if an unsupported data type is passed to the
		/// <i>pFeatureSupportData</i> parameter or if a size mismatch is detected for the <i>FeatureSupportDataSize</i> parameter.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// As a usage example, to check for ray tracing support, specify the <c>D3D12_FEATURE_DATA_D3D12_OPTIONS5</c> structure in the
		/// <i>pFeatureSupportData</i> parameter. When the function completes successfully, access the <i>RaytracingTier</i> field (which
		/// specifies the supported ray tracing tier) of the now-populated <b>D3D12_FEATURE_DATA_D3D12_OPTIONS5</b> structure.
		/// </para>
		/// <para>For more info, see <c>Capability Querying</c>.</para>
		/// <para><c></c><c></c><c></c> Hardware support for DXGI Formats</para>
		/// <para>To view tables of DXGI formats and hardware features, refer to:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 12.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 12.0 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 11.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 11.0 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>Hardware Support for Direct3D 10Level9 Formats</c></description>
		/// </item>
		/// <item>
		/// <description><c>Format Support for Direct3D Feature Level 10.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>Format Support for Direct3D Feature Level 10.0 Hardware</c></description>
		/// </item>
		/// </list>
		/// <para>Examples</para>
		/// <para>The <c>D3D1211on12</c> sample uses <b>ID3D12Device::CheckFeatureSupport</b> as follows:</para>
		/// <para>
		/// <c>inline UINT8 D3D12GetFormatPlaneCount( _In_ ID3D12Device* pDevice, DXGI_FORMAT Format ) { D3D12_FEATURE_DATA_FORMAT_INFO
		/// formatInfo = {Format}; if (FAILED(pDevice-&gt;CheckFeatureSupport(D3D12_FEATURE_FORMAT_INFO, &amp;formatInfo,
		/// sizeof(formatInfo)))) { return 0; } return formatInfo.PlaneCount; }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport HRESULT CheckFeatureSupport(
		// D3D12_FEATURE Feature, [in, out] void *pFeatureSupportData, UINT FeatureSupportDataSize );
		[PreserveSig]
		new HRESULT CheckFeatureSupport(D3D12_FEATURE Feature, [In, Out] IntPtr pFeatureSupportData, uint FeatureSupportDataSize);

		/// <summary>Creates a descriptor heap object.</summary>
		/// <param name="pDescriptorHeapDesc">
		/// <para>Type: <b>const <c>D3D12_DESCRIPTOR_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DESCRIPTOR_HEAP_DESC</c> structure that describes the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the descriptor heap interface. See Remarks. An input parameter.</para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b><b>void</b>**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the descriptor heap. <i>ppvHeap</i> can be NULL, to enable capability
		/// testing. When <i>ppvHeap</i> is NULL, no object will be created and S_FALSE will be returned when <i>pDescriptorHeapDesc</i> is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the descriptor heap object. See <c>Direct3D
		/// 12 Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the descriptor heap can be obtained by using the __uuidof() macro. For
		/// example, __uuidof( <c>ID3D12DescriptorHeap</c>) will get the <b>GUID</b> of the interface to a descriptor heap. Examples The
		/// <c>D3D12HelloWorld</c> sample uses <b>ID3D12Device::CreateDescriptorHeap</b> as follows:
		/// </para>
		/// <para>Describe and create a render target view (RTV) descriptor heap.</para>
		/// <para>
		/// <c>// Create descriptor heaps. { // Describe and create a render target view (RTV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// rtvHeapDesc = {}; rtvHeapDesc.NumDescriptors = FrameCount; rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; rtvHeapDesc.Flags
		/// = D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;rtvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_rtvHeap))); m_rtvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV); } // Create frame resources. {
		/// CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); // Create a RTV for each frame. for
		/// (UINT n = 0; n &lt; FrameCount; n++) { ThrowIfFailed(m_swapChain-&gt;GetBuffer(n, IID_PPV_ARGS(&amp;m_renderTargets[n])));
		/// m_device-&gt;CreateRenderTargetView(m_renderTargets[n].Get(), nullptr, rtvHandle); rtvHandle.Offset(1, m_rtvDescriptorSize); }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap HRESULT
		// CreateDescriptorHeap( [in] const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateDescriptorHeap(in D3D12_DESCRIPTOR_HEAP_DESC pDescriptorHeapDesc, in Guid riid, [Out] IntPtr ppvHeap);

		/// <summary>
		/// Gets the size of the handle increment for the given type of descriptor heap. This value is typically used to increment a handle
		/// into a descriptor array by the correct amount.
		/// </summary>
		/// <param name="DescriptorHeapType">
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to get the size of the handle
		/// increment for.
		/// </param>
		/// <returns>Returns the size of the handle increment for the given type of descriptor heap, including any necessary padding.</returns>
		/// <remarks>
		/// <para>
		/// The descriptor size returned by this method is used as one input to the helper structures <c>CD3DX12_CPU_DESCRIPTOR_HANDLE</c>
		/// and <c>CD3DX12_GPU_DESCRIPTOR_HANDLE</c>. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12Device::GetDescriptorHandleIncrementSize</b> as follows:
		/// </para>
		/// <para>
		/// Create the descriptor heap for the resources. The <c>m_rtvDescriptorSize</c> variable stores the render target view descriptor
		/// handle increment size, and is used in the <b>Create frame resources</b> section of the code.
		/// </para>
		/// <para>
		/// <c>// Create descriptor heaps. { // Describe and create a render target view (RTV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// rtvHeapDesc = {}; rtvHeapDesc.NumDescriptors = FrameCount; rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; rtvHeapDesc.Flags
		/// = D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;rtvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_rtvHeap))); // Describe and create a depth stencil view (DSV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// dsvHeapDesc = {}; dsvHeapDesc.NumDescriptors = 1; dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV; dsvHeapDesc.Flags =
		/// D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;dsvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_dsvHeap))); // Describe and create a constant buffer view (CBV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// cbvHeapDesc = {}; cbvHeapDesc.NumDescriptors = CbvCountPerFrame * FrameCount; cbvHeapDesc.Type =
		/// D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV; cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
		/// ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;cbvHeapDesc, IID_PPV_ARGS(&amp;m_cbvHeap))); // Describe and create a heap
		/// for occlusion queries. D3D12_QUERY_HEAP_DESC queryHeapDesc = {}; queryHeapDesc.Count = 1; queryHeapDesc.Type =
		/// D3D12_QUERY_HEAP_TYPE_OCCLUSION; ThrowIfFailed(m_device-&gt;CreateQueryHeap(&amp;queryHeapDesc,
		/// IID_PPV_ARGS(&amp;m_queryHeap))); m_rtvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV); m_cbvSrvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV); } // Create frame resources. {
		/// CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); // Create a RTV and a command
		/// allocator for each frame. for (UINT n = 0; n &lt; FrameCount; n++) { ThrowIfFailed(m_swapChain-&gt;GetBuffer(n,
		/// IID_PPV_ARGS(&amp;m_renderTargets[n]))); m_device-&gt;CreateRenderTargetView(m_renderTargets[n].Get(), nullptr, rtvHandle);
		/// rtvHandle.Offset(1, m_rtvDescriptorSize); ThrowIfFailed(m_device-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT,
		/// IID_PPV_ARGS(&amp;m_commandAllocators[n]))); } }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getdescriptorhandleincrementsize UINT
		// GetDescriptorHandleIncrementSize( [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType );
		[PreserveSig]
		new uint GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);

		/// <summary>Creates a root signature layout.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single GPU operation, set this to zero. If there are multiple GPU nodes, set bits to identify the nodes (the device's
		/// physical adapters) to which the root signature is to apply. Each bit in the mask corresponds to a single node. Refer to
		/// <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="pBlobWithRootSignature">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>A pointer to the source data for the serialized signature.</para>
		/// </param>
		/// <param name="blobLengthInBytes">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>The size, in bytes, of the block of memory that <i>pBlobWithRootSignature</i> points to.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the root signature interface. See Remarks. An input parameter.</para>
		/// </param>
		/// <param name="ppvRootSignature">
		/// <para>Type: <b><b>void</b>**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the root signature.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// <para>This method returns <b>E_INVALIDARG</b> if the blob that <i>pBlobWithRootSignature</i> points to is invalid.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// If an application procedurally generates a <c>D3D12_ROOT_SIGNATURE_DESC</c> data structure, it must pass a pointer to this
		/// <b>D3D12_ROOT_SIGNATURE_DESC</b> in a call to <c>D3D12SerializeRootSignature</c> to make the serialized form. The application
		/// then passes the serialized form to <i>pBlobWithRootSignature</i> in a call to <b>ID3D12Device::CreateRootSignature</b>.
		/// </para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the root signature layout can be obtained by using the __uuidof() macro.
		/// For example, __uuidof( <c>ID3D12RootSignature</c>) will get the <b>GUID</b> of the interface to a root signature. Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12Device::CreateRootSignature</b> as follows:
		/// </para>
		/// <para>Create an empty root signature.</para>
		/// <para>
		/// <c>CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc; rootSignatureDesc.Init(0, nullptr, 0, nullptr,
		/// D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT); ComPtr&lt;ID3DBlob&gt; signature; ComPtr&lt;ID3DBlob&gt; error;
		/// ThrowIfFailed(D3D12SerializeRootSignature(&amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &amp;signature, &amp;error));
		/// ThrowIfFailed(m_device-&gt;CreateRootSignature(0, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(), IID_PPV_ARGS(&amp;m_rootSignature)));</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrootsignature HRESULT CreateRootSignature(
		// [in] UINT nodeMask, [in] const void *pBlobWithRootSignature, [in] SIZE_T blobLengthInBytes, REFIID riid, [out] void
		// **ppvRootSignature );
		[PreserveSig]
		new HRESULT CreateRootSignature(uint nodeMask, [In] IntPtr pBlobWithRootSignature, [In] SizeT blobLengthInBytes, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppvRootSignature);

		/// <summary>Creates a constant-buffer view for accessing resource data.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_CONSTANT_BUFFER_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_CONSTANT_BUFFER_VIEW_DESC</c> structure that describes the constant-buffer view.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the constant-buffer view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createconstantbufferview void
		// CreateConstantBufferView( [in, optional] const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE
		// DestDescriptor );
		[PreserveSig]
		new void CreateConstantBufferView([In, Optional] StructPointer<D3D12_CONSTANT_BUFFER_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a shader-resource view for accessing data in a resource.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the shader resource.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_SHADER_RESOURCE_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_SHADER_RESOURCE_VIEW_DESC</c> structure that describes the shader-resource view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and for buffers SRVs target a full buffer and are typed (not raw or structured), and for textures SRVs target a full texture,
		/// all mips and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// Describes the CPU descriptor handle that represents the shader-resource view. This handle can be created in a shader-visible or
		/// non-shader-visible descriptor heap.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para><c></c><c></c><c></c> Processing YUV 4:2:0 video formats</para>
		/// <para>
		/// An app must map the luma (Y) plane separately from the chroma (UV) planes. Developers do this by calling
		/// <b>CreateShaderResourceView</b> twice for the same texture and passing in 1-channel and 2-channel formats. Passing in a
		/// 1-channel format compatible with the Y plane maps only the Y plane. Passing in a 2-channel format compatible with the UV planes
		/// (together) maps only the U and V planes as a single resource view.
		/// </para>
		/// <para>
		/// YUV 4:2:0 formats are listed in <c>DXGI_FORMAT</c>. Examples The <c>D3D12nBodyGravity</c> sample uses
		/// <b>ID3D12Device::CreateShaderResourceView</b> as follows:
		/// </para>
		/// <para>Describe and create two shader resource views based on one description.</para>
		/// <para>
		/// <c>D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {}; srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
		/// srvDesc.Format = DXGI_FORMAT_UNKNOWN; srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER; srvDesc.Buffer.FirstElement = 0;
		/// srvDesc.Buffer.NumElements = ParticleCount; srvDesc.Buffer.StructureByteStride = sizeof(Particle); srvDesc.Buffer.Flags =
		/// D3D12_BUFFER_SRV_FLAG_NONE; CD3DX12_CPU_DESCRIPTOR_HANDLE srvHandle0(m_srvUavHeap-&gt;GetCPUDescriptorHandleForHeapStart(),
		/// SrvParticlePosVelo0 + index, m_srvUavDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// srvHandle1(m_srvUavHeap-&gt;GetCPUDescriptorHandleForHeapStart(), SrvParticlePosVelo1 + index, m_srvUavDescriptorSize);
		/// m_device-&gt;CreateShaderResourceView(m_particleBuffer0[index].Get(), &amp;srvDesc, srvHandle0);
		/// m_device-&gt;CreateShaderResourceView(m_particleBuffer1[index].Get(), &amp;srvDesc, srvHandle1);</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createshaderresourceview void
		// CreateShaderResourceView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
		// [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateShaderResourceView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_SHADER_RESOURCE_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a view for unordered accessing.</summary>
		/// <param name="pResource">
		/// <para>Type: [in, optional] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the unordered access.</para>
		/// <para>At least one of <i>pResource</i> or <i>pDesc</i> must be provided.</para>
		/// <para>
		/// A null <i>pResource</i> is used to initialize a null descriptor, which guarantees Direct3D 11-like null binding behavior
		/// (reading 0s, writes are discarded), but must have a valid <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pCounterResource">
		/// <para>Type: [in, optional] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The <c>ID3D12Resource</c> for the counter (if any) associated with the UAV.</para>
		/// <para>
		/// If <i>pCounterResource</i> is not specified, then the <b>CounterOffsetInBytes</b> member of the <c>D3D12_BUFFER_UAV</c>
		/// structure must be 0.
		/// </para>
		/// <para>
		/// If <i>pCounterResource</i> is specified, then there is a counter associated with the UAV, and the runtime performs validation of
		/// the following requirements:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>The <b>StructureByteStride</b> member of the <c>D3D12_BUFFER_UAV</c> structure must be greater than 0.</description>
		/// </item>
		/// <item>
		/// <description>The format must be DXGI_FORMAT_UNKNOWN.</description>
		/// </item>
		/// <item>
		/// <description>The D3D12_BUFFER_UAV_FLAG_RAW flag (a <c>D3D12_BUFFER_UAV_FLAGS</c> enumeration constant) must not be set.</description>
		/// </item>
		/// <item>
		/// <description>Both of the resources ( <i>pResource</i> and <i>pCounterResource</i>) must be buffers.</description>
		/// </item>
		/// <item>
		/// <description>
		/// The <b>CounterOffsetInBytes</b> member of the <c>D3D12_BUFFER_UAV</c> structure must be a multiple of
		/// **D3D12_UAV_COUNTER_PLACEMENT_ALIGNMENT** (4096), and must be within the range of the counter resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description><i>pResource</i> cannot be NULL</description>
		/// </item>
		/// <item>
		/// <description><i>pDesc</i> cannot be NULL.</description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in, optional] <b>const <c>D3D12_UNORDERED_ACCESS_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_UNORDERED_ACCESS_VIEW_DESC</c> structure that describes the unordered-access view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and for buffers UAVs target a full buffer and are typed, and for textures UAVs target the first mip and all array slices. Not
		/// all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the unordered-access view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createunorderedaccessview void
		// CreateUnorderedAccessView( ID3D12Resource *pResource, ID3D12Resource *pCounterResource, const D3D12_UNORDERED_ACCESS_VIEW_DESC
		// *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateUnorderedAccessView([In, Optional] ID3D12Resource? pResource, [In, Optional] ID3D12Resource? pCounterResource,
			[In, Optional] StructPointer<D3D12_UNORDERED_ACCESS_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a render-target view for accessing resource data.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the render target.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RENDER_TARGET_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_RENDER_TARGET_VIEW_DESC</c> structure that describes the render-target view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and RTVs target the first mip and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the destination where the newly-created render target view will reside.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrendertargetview void
		// CreateRenderTargetView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_RENDER_TARGET_VIEW_DESC *pDesc, [in]
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateRenderTargetView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_RENDER_TARGET_VIEW_DESC> pDesc,
			[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a depth-stencil view for accessing resource data.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the depth stencil.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_DEPTH_STENCIL_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DEPTH_STENCIL_VIEW_DESC</c> structure that describes the depth-stencil view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and DSVs target the first mip and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the depth-stencil view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createdepthstencilview void
		// CreateDepthStencilView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc, [in]
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateDepthStencilView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_DEPTH_STENCIL_VIEW_DESC> pDesc,
			[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Create a sampler object that encapsulates sampling information for a texture.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_SAMPLER_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_SAMPLER_DESC</c> structure that describes the sampler.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the sampler.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsampler void CreateSampler( [in] const
		// D3D12_SAMPLER_DESC *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateSampler(in D3D12_SAMPLER_DESC pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Copies descriptors from a source to a destination.</summary>
		/// <param name="NumDestDescriptorRanges">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of destination descriptor ranges to copy to.</para>
		/// </param>
		/// <param name="pDestDescriptorRangeStarts">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>An array of <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> objects to copy to.</para>
		/// <para>All the destination and source descriptors must be in heaps of the same <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>.</para>
		/// </param>
		/// <param name="pDestDescriptorRangeSizes">
		/// <para>Type: <b>const <c>UINT</c>*</b></para>
		/// <para>An array of destination descriptor range sizes to copy to.</para>
		/// </param>
		/// <param name="NumSrcDescriptorRanges">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of source descriptor ranges to copy from.</para>
		/// </param>
		/// <param name="pSrcDescriptorRangeStarts">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>An array of <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> objects to copy from.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// All elements in the pSrcDescriptorRangeStarts parameter must be in a non shader-visible descriptor heap. This is because
		/// shader-visible descriptor heaps may be created in <b>WRITE_COMBINE</b> memory or GPU local memory, which is prohibitively slow
		/// to read from. If your application manages descriptor heaps via copying the descriptors required for a given pass or frame from
		/// local "storage" descriptor heaps to the GPU-bound descriptor heap, use shader-opaque heaps for the storage heaps and copy into
		/// the GPU-visible heap as required.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="pSrcDescriptorRangeSizes">
		/// <para>Type: <b>const <c>UINT</c>*</b></para>
		/// <para>An array of source descriptor range sizes to copy from.</para>
		/// </param>
		/// <param name="DescriptorHeapsType">
		/// <para>Type: <b><c>D3D12_DESCRIPTOR_HEAP_TYPE</c></b></para>
		/// <para>
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to copy with. This is required as
		/// different descriptor types may have different sizes.
		/// </para>
		/// <para>Both the source and destination descriptor heaps must have the same type, else the debug layer will emit an error.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// Where applicable, prefer <c><b>ID3D12Device::CopyDescriptorsSimple</b></c> to this method. It can have a better CPU cache miss
		/// rate due to the linear nature of the copy.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-copydescriptors void CopyDescriptors( [in] UINT
		// NumDestDescriptorRanges, [in] const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts, [in, optional] const UINT
		// *pDestDescriptorRangeSizes, [in] UINT NumSrcDescriptorRanges, [in] const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
		// [in, optional] const UINT *pSrcDescriptorRangeSizes, [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType );
		[PreserveSig]
		new void CopyDescriptors(int NumDestDescriptorRanges, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_CPU_DESCRIPTOR_HANDLE[] pDestDescriptorRangeStarts,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[]? pDestDescriptorRangeSizes, int NumSrcDescriptorRanges,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] D3D12_CPU_DESCRIPTOR_HANDLE[] pSrcDescriptorRangeStarts,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[]? pSrcDescriptorRangeSizes, D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);

		/// <summary>Copies descriptors from a source to a destination.</summary>
		/// <param name="NumDescriptors">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of descriptors to copy.</para>
		/// </param>
		/// <param name="DestDescriptorRangeStart">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> that describes the destination descriptors to start to copy to.</para>
		/// <para>The destination and source descriptors must be in heaps of the same <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>.</para>
		/// </param>
		/// <param name="SrcDescriptorRangeStart">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> that describes the source descriptors to start to copy from.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// The SrcDescriptorRangeStart parameter must be in a non shader-visible descriptor heap. This is because shader-visible descriptor
		/// heaps may be created in <b>WRITE_COMBINE</b> memory or GPU local memory, which is prohibitively slow to read from. If your
		/// application manages descriptor heaps via copying the descriptors required for a given pass or frame from local "storage"
		/// descriptor heaps to the GPU-bound descriptor heap, then use shader-opaque heaps for the storage heaps and copy into the
		/// GPU-visible heap as required.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="DescriptorHeapsType">
		/// <para>Type: <b><c>D3D12_DESCRIPTOR_HEAP_TYPE</c></b></para>
		/// <para>
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to copy with. This is required as
		/// different descriptor types may have different sizes.
		/// </para>
		/// <para>Both the source and destination descriptor heaps must have the same type, else the debug layer will emit an error.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// Where applicable, prefer this method to <c><b>ID3D12Device::CopyDescriptors</b></c>. It can have a better CPU cache miss rate
		/// due to the linear nature of the copy.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-copydescriptorssimple void CopyDescriptorsSimple(
		// [in] UINT NumDescriptors, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart, [in] D3D12_CPU_DESCRIPTOR_HANDLE
		// SrcDescriptorRangeStart, [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType );
		[PreserveSig]
		new void CopyDescriptorsSimple(uint NumDescriptors, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart, [In] D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
			D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);

		/// <summary>Gets the size and alignment of memory required for a collection of resources on this adapter.</summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// <para>If an error occurs, then <b>D3D12_RESOURCE_ALLOCATION_INFO::SizeInBytes</b> equals <b>UINT64_MAX</b>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When you're using <c>CreatePlacedResource</c>, your application must use <b>GetResourceAllocationInfo</b> in order to understand
		/// the size and alignment characteristics of texture resources. The results of this method vary depending on the particular
		/// adapter, and must be treated as unique to this adapter and driver version.
		/// </para>
		/// <para>
		/// Your application can't use the output of <b>GetResourceAllocationInfo</b> to understand packed mip properties of textures. To
		/// understand packed mip properties of textures, your application must use <c>GetResourceTiling</c>.
		/// </para>
		/// <para>
		/// Texture resource sizes significantly differ from the information returned by <b>GetResourceTiling</b>, because some adapter
		/// architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios. This even
		/// includes textures that have constraints on their texture layouts, or have standardized texture layouts. That extra memory can't
		/// be sparsely mapped nor remapped by an application using <c>CreateReservedResource</c> and <c>UpdateTileMappings</c>, so it isn't
		/// reported by <b>GetResourceTiling</b>.
		/// </para>
		/// <para>
		/// Your application can forgo using <b>GetResourceAllocationInfo</b> for buffer resources (
		/// <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>). Buffers have the same size on all adapters, which is merely the smallest multiple of
		/// 64KB that's greater or equal to <c>D3D12_RESOURCE_DESC::Width</c>.
		/// </para>
		/// <para>
		/// When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used.
		/// For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource, reports differing sizes
		/// based on the order of the array. If the 4MB aligned resource is in the middle, then the resulting <b>Size</b> is 12MB.
		/// Otherwise, the resulting <b>Size</b> is 8MB. The <b>Alignment</b> returned would always be 4MB, because it's the superset of all
		/// alignments in the resource array.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getresourceallocationinfo(uint_uint_constd3d12_resource_desc)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo( [in] UINT visibleMask, [in] UINT numResourceDescs, [in] const
		// D3D12_RESOURCE_DESC *pResourceDescs );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_RESOURCE_DESC[] pResourceDescs);

		/// <summary>
		/// Divulges the equivalent custom heap properties that are used for non-custom heap types, based on the adapter's architectural properties.
		/// </summary>
		/// <param name="nodeMask">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the device's
		/// physical adapter). Each bit in the mask corresponds to a single node. Only 1 bit must be set. See <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="heapType">
		/// <para>Type: <b><c>D3D12_HEAP_TYPE</c></b></para>
		/// <para>
		/// A <c>D3D12_HEAP_TYPE</c>-typed value that specifies the heap to get properties for. D3D12_HEAP_TYPE_CUSTOM is not supported as a
		/// parameter value.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_HEAP_PROPERTIES</c></b></para>
		/// <para>
		/// Returns a <c>D3D12_HEAP_PROPERTIES</c> structure that provides properties for the specified heap. The <b>Type</b> member of the
		/// returned D3D12_HEAP_PROPERTIES is always D3D12_HEAP_TYPE_CUSTOM.
		/// </para>
		/// <para>When <c>D3D12_FEATURE_DATA_ARCHITECTURE</c>::UMA is FALSE, the returned D3D12_HEAP_PROPERTIES members convert as follows:</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_COMBINE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L1.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// <para></para>
		/// <para>
		/// When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is FALSE, the returned
		/// D3D12_HEAP_PROPERTIES members convert as follows:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_COMBINE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// <para></para>
		/// <para>
		/// When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is TRUE, the returned
		/// D3D12_HEAP_PROPERTIES members convert as follows:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcustomheapproperties(uint_d3d12_heap_type)
		// D3D12_HEAP_PROPERTIES GetCustomHeapProperties( [in] UINT nodeMask, D3D12_HEAP_TYPE heapType );
		[PreserveSig]
		new D3D12_HEAP_PROPERTIES GetCustomHeapProperties(uint nodeMask, D3D12_HEAP_TYPE heapType);

		/// <summary>
		/// Creates both a resource and an implicit heap, such that the heap is big enough to contain the entire resource, and the resource
		/// is mapped to the heap.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource HRESULT
		// CreateCommittedResource( [in] const D3D12_HEAP_PROPERTIES *pHeapProperties, [in] D3D12_HEAP_FLAGS HeapFlags, [in] const
		// D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialResourceState, [in, optional] const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, [in] REFIID riidResource, [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>Creates a heap that can be used with placed resources and reserved resources.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_HEAP_DESC</b> structure that describes the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the heap interface to return in ppvHeap.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Heap</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// An optional pointer to a memory block that receives the requested interface pointer to the created heap object. <paramref
		/// name="ppvHeap"/> can be <c>nullptr</c>, to enable capability testing. When ppvHeap is <c>nullptr</c>, no object is created, and
		/// <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the heap.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para><b>CreateHeap</b> creates a heap that can be used with placed resources and reserved resources.</para>
		/// <para>
		/// Before releasing the final reference on the heap, your application must ensure that the GPU will no longer read or write to this heap.
		/// </para>
		/// <para>
		/// A placed resource object holds a reference on the heap it is created on; but a reserved resource doesn't hold a reference for
		/// each mapping made to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createheap HRESULT CreateHeap( [in] const
		// D3D12_HEAP_DESC *pDesc, [in] REFIID riid, [out, optional] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateHeap(in D3D12_HEAP_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>
		/// When a resource is created together with a <b>D3D12_HEAP_TYPE_UPLOAD</b> heap, InitialState must be
		/// <b>D3D12_RESOURCE_STATE_GENERIC_READ</b>. When a resource is created together with a <b>D3D12_HEAP_TYPE_READBACK</b> heap,
		/// InitialState must be <b>D3D12_RESOURCE_STATE_COPY_DEST</b>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreatePlacedResource</b> is similar to fully mapping a reserved resource to an offset within a heap; but the virtual address
		/// space associated with a heap may be reused as well.
		/// </para>
		/// <para>
		/// Placed resources are lighter weight to create and destroy than committed resources are. This is because no heap is created nor
		/// destroyed during those operations. In addition, placed resources enable an even lighter weight technique to reuse memory than
		/// resource creation and destructionthat is, reuse through aliasing, and aliasing barriers. Multiple placed resources may
		/// simultaneously overlap each other on the same heap, but only a single overlapping resource can be used at a time.
		/// </para>
		/// <para>
		/// There are two placed resource usage semanticsa simple model, and an advanced model. We recommend that you choose the simple
		/// model (it maximizes graphics tool support across the diverse ecosystem of GPUs), unless and until you find that you need the
		/// advanced model for your app.
		/// </para>
		/// <para>Simple model</para>
		/// <para>
		/// In this model, you can consider a placed resource to be in one of two states: active, or inactive. It's invalid for the GPU to
		/// either read or write from an inactive resource. Placed resources are created in the inactive state.
		/// </para>
		/// <para>
		/// To activate a resource with an aliasing barrier on a command list, your application must pass the resource in
		/// <c><b>D3D12_RESOURCE_ALIASING_BARRIER::pResourceAfter</b></c>. <b>pResourceBefore</b> can be left NULL during an activation. All
		/// resources that share physical memory with the activated resource now become inactive, which includes overlapping placed and
		/// reserved resources.
		/// </para>
		/// <para>Aliasing barriers should be grouped up and submitted together, in order to maximize efficiency.</para>
		/// <para>
		/// After activation, resources with either the render target or depth stencil flags must be further initialized. See the notes on
		/// the required resource initialization below.
		/// </para>
		/// <para>Notes on the required resource initialization</para>
		/// <para>
		/// Certain resource types still require initialization. Resources with either the render target or depth stencil flags must be
		/// initialized with either a clear operation or a collection of full subresource copies. If an aliasing barrier was used to denote
		/// the transition between two aliased resources, the initialization must occur after the aliasing barrier. This initialization is
		/// still required whenever a resource would've been activated in the simple model.
		/// </para>
		/// <para>
		/// Placed and reserved resources with either the render target or depth stencil flags must be initialized with one of the following
		/// operations before other operations are supported.
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>A Clear operation; for example <c>ClearRenderTargetView</c> or <c>ClearDepthStencilView</c>.</description>
		/// </item>
		/// <item>
		/// <description>A <c>DiscardResource</c> operation.</description>
		/// </item>
		/// <item>
		/// <description>A Copy operation; for example <c>CopyBufferRegion</c>, <c>CopyTextureRegion</c>, or <c>CopyResource</c>.</description>
		/// </item>
		/// </list>
		/// <para>
		/// Applications should prefer the most explicit operation that results in the least amount of texels modified. Consider the
		/// following examples.
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// Using a depth buffer to solve pixel visibility typically requires each depth texel start out at 1.0 or 0. Therefore, a Clear
		/// operation should be the most efficient option for aliased depth buffer initialization.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// An application may use an aliased render target as a destination for tone mapping. Since the application will render over every
		/// pixel during the tone mapping, <c>DiscardResource</c> should be the most efficient option for initialization.
		/// </description>
		/// </item>
		/// </list>
		/// <para>Advanced model</para>
		/// <para>In this model, you can ignore the active/inactive state abstraction. Instead, you must honor these lower-level rules.</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// An aliasing barrier must be between two different GPU resource accesses of the same physical memory, as long as those accesses
		/// are within the same <c>ExecuteCommandLists</c> call.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// The first rendering operation to certain types of aliased resource must still be an initialization, just like the simple model.
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// Initialization operations must occur either on an entire subresource, or on a 64KB granularity. An entire subresource
		/// initialization is supported for all resource types. A 64KB initialization granularity, aligned at a 64KB offset, is supported
		/// for buffers and textures with either the 64KB_UNDEFINED_SWIZZLE or 64KB_STANDARD_SWIZZLE texture layout (refer to <c>D3D12_TEXTURE_LAYOUT</c>).
		/// </para>
		/// <para>Notes on the aliasing barrier</para>
		/// <para>
		/// The aliasing barrier may set NULL for both pResourceAfter and pResourceBefore. The memory coherence definition of
		/// <c><b>ExecuteCommandLists</b></c> and an aliasing barrier are the same, such that two aliased accesses to the same physical
		/// memory need no aliasing barrier when the accesses are in two different <b>ExecuteCommandLists</b> invocations.
		/// </para>
		/// <para>
		/// For D3D12 advanced usage models, the synchronization definition of <c><b>ExecuteCommandLists</b></c> is equivalent to an
		/// aliasing barrier. Therefore, applications may either insert an aliasing barrier between reusing physical memory, or ensure the
		/// two aliased usages of physical memory occurs in two separate calls to <b>ExecuteCommandLists</b>.
		/// </para>
		/// <para>
		/// The amount of inactivation varies based on resource properties. Textures with undefined memory layouts are the worst case, as
		/// the entire texture must be inactivated atomically. For two overlapping resources with defined layouts, inactivation can result
		/// in only the overlapping aligned regions of a resource. Data inheritance can even be well-defined. For more details, see
		/// <c>Memory aliasing and data inheritance</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource HRESULT
		// CreatePlacedResource( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC *pDesc, D3D12_RESOURCE_STATES InitialState,
		// const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>Creates a resource that is reserved, and not yet mapped to any pages in a heap.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreateReservedResource</b> is equivalent to <c>D3D11_RESOURCE_MISC_TILED</c> in Direct3D 11. It creates a resource with
		/// virtual memory only, no backing store.
		/// </para>
		/// <para>You need to map the resource to physical memory (that is, to a heap) using <c>CopyTileMappings</c> and <c>UpdateTileMappings</c>.</para>
		/// <para>
		/// These resource types can only be created when the adapter supports tiled resource tier 1 or greater. The tiled resource tier
		/// defines the behavior of accessing a resource that is not mapped to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createreservedresource HRESULT
		// CreateReservedResource( [in] const D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialState, [in, optional] const
		// D3D12_CLEAR_VALUE *pOptimizedClearValue, [in] REFIID riid, [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource(in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppvResource);

		/// <summary>Creates a shared handle to a heap, resource, or fence object.</summary>
		/// <param name="pObject">
		/// <para>Type: <b><c>ID3D12DeviceChild</c>*</b></para>
		/// <para>
		/// A pointer to the <c>ID3D12DeviceChild</c> interface that represents the heap, resource, or fence object to create for sharing.
		/// The following interfaces (derived from <b>ID3D12DeviceChild</b>) are supported:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pAttributes">
		/// <para>Type: <b>const <c>SECURITY_ATTRIBUTES</c>*</b></para>
		/// <para>
		/// A pointer to a <c>SECURITY_ATTRIBUTES</c> structure that contains two separate but related data members: an optional security
		/// descriptor, and a <b>Boolean</b> value that determines whether child processes can inherit the returned handle.
		/// </para>
		/// <para>
		/// Set this parameter to <b>NULL</b> if you want child processes that the application might create to not inherit the handle
		/// returned by <b>CreateSharedHandle</b>, and if you want the resource that is associated with the returned handle to get a default
		/// security descriptor.
		/// </para>
		/// <para>
		/// The <b>lpSecurityDescriptor</b> member of the structure specifies a <c>SECURITY_DESCRIPTOR</c> for the resource. Set this member
		/// to <b>NULL</b> if you want the runtime to assign a default security descriptor to the resource that is associated with the
		/// returned handle. The ACLs in the default security descriptor for the resource come from the primary or impersonation token of
		/// the creator. For more info, see <c>Synchronization Object Security and Access Rights</c>.
		/// </para>
		/// </param>
		/// <param name="Access">
		/// <para>Type: <b><c>DWORD</c></b></para>
		/// <para>Currently the only value this parameter accepts is GENERIC_ALL.</para>
		/// </param>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>
		/// A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the shared heap. The name is limited to
		/// MAX_PATH characters. Name comparison is case-sensitive.
		/// </para>
		/// <para>
		/// If <i>Name</i> matches the name of an existing resource, <b>CreateSharedHandle</b> fails with
		/// <c>DXGI_ERROR_NAME_ALREADY_EXISTS</c>. This occurs because these objects share the same namespace.
		/// </para>
		/// <para>
		/// The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder
		/// of the name can contain any character except the backslash character (\). For more information, see <c>Kernel Object
		/// Namespaces</c>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the
		/// guidelines outlined for Terminal Services so that applications can support multiple users.
		/// </para>
		/// <para>The object can be created in a private namespace. For more information, see <c>Object Namespaces</c>.</para>
		/// </param>
		/// <param name="pHandle">
		/// <para>Type: <b><c>HANDLE</c>*</b></para>
		/// <para>
		/// A pointer to a variable that receives the NT HANDLE value to the resource to share. You can use this handle in calls to access
		/// the resource.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns S_OK if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>DXGI_ERROR_INVALID_CALL</c> if one of the parameters is invalid.</description>
		/// </item>
		/// <item>
		/// <description>
		/// <c>DXGI_ERROR_NAME_ALREADY_EXISTS</c> if the supplied name of the resource to share is already associated with another resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description>E_ACCESSDENIED if the object is being created in a protected namespace.</description>
		/// </item>
		/// <item>
		/// <description>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</description>
		/// </item>
		/// <item>
		/// <description>Possibly other error codes that are described in the <c>Direct3D 12 Return Codes</c> topic.</description>
		/// </item>
		/// </list>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Both heaps and committed resources can be shared. Sharing a committed resource shares the implicit heap along with the committed
		/// resource description, such that a compatible resource description can be mapped to the heap from another device.
		/// </para>
		/// <para>
		/// For Direct3D 11 and Direct3D 12 interop scenarios, a shared fence is opened in DirectX 11 with the
		/// <c>ID3D11Device5::OpenSharedFence</c> method, and a shared resource is opened with the <c>ID3D11Device::OpenSharedResource1</c> method.
		/// </para>
		/// <para>
		/// For Direct3D 12, a shared handle is opened with the <c>ID3D12Device::OpenSharedHandle</c> or the
		/// ID3D12Device::OpenSharedHandleByName method.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle HRESULT CreateSharedHandle(
		// [in] ID3D12DeviceChild *pObject, [in, optional] const SECURITY_ATTRIBUTES *pAttributes, DWORD Access, [in, optional] LPCWSTR
		// Name, [out] HANDLE *pHandle );
		[PreserveSig]
		new HRESULT CreateSharedHandle([In] ID3D12DeviceChild pObject, [In, Optional] SECURITY_ATTRIBUTES? pAttributes, ACCESS_MASK Access,
			[Optional, MarshalAs(UnmanagedType.LPWStr)] string? Name, out HANDLE pHandle);

		/// <summary>Opens a handle for shared resources, shared heaps, and shared fences, by using HANDLE and REFIID.</summary>
		/// <param name="NTHandle">
		/// <para>Type: <b>HANDLE</b></para>
		/// <para>The handle that was output by the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for one of the following interfaces:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// <para>
		/// The REFIID , or GUID , of the interface can be obtained by using the __uuidof() macro. For example, __uuidof(ID3D12Heap) will
		/// get the GUID of the interface to a resource.
		/// </para>
		/// </param>
		/// <param name="ppvObj">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to one of the following interfaces:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-opensharedhandle HRESULT OpenSharedHandle( [in]
		// HANDLE NTHandle, REFIID riid, [out, optional] void **ppvObj );
		[PreserveSig]
		new HRESULT OpenSharedHandle(HANDLE NTHandle, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvObj);

		/// <summary>Opens a handle for shared resources, shared heaps, and shared fences, by using Name and Access.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>The name that was optionally passed as the <i>Name</i> parameter in the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="Access">
		/// <para>Type: <b>DWORD</b></para>
		/// <para>The access level that was specified in the <i>Access</i> parameter in the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="pNTHandle">
		/// <para>Type: <b>HANDLE*</b></para>
		/// <para>Pointer to the shared handle.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-opensharedhandlebyname HRESULT
		// OpenSharedHandleByName( [in] LPCWSTR Name, DWORD Access, [out] HANDLE *pNTHandle );
		[PreserveSig]
		new HRESULT OpenSharedHandleByName([MarshalAs(UnmanagedType.LPWStr)] string Name, ACCESS_MASK Access, out HANDLE pNTHandle);

		/// <summary>Makes objects resident for the device.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to make resident for the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block that contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>
		/// Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following
		/// objects: Descriptor Heaps, Heaps, Committed Resources, and Query Heaps
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>MakeResident</b> loads the data associated with a resource from disk, and re-allocates the memory from the resource's
		/// appropriate memory pool. This method should be called on the object which owns the physical memory.
		/// </para>
		/// <para>
		/// Use this method, and <c>Evict</c>, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to
		/// be done by the app in D3D12.
		/// </para>
		/// <para>
		/// <b>MakeResident</b> and <c>Evict</c> can help applications manage the residency budget on many adapters. <b>MakeResident</b>
		/// explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <b>Evict</b> enables page-out.
		/// </para>
		/// <para>
		/// Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use
		/// <c>D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT</c> and <c>IDXGIAdapter3::QueryVideoMemoryInfo</c> to recognize when the
		/// maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the
		/// residency budget will always be constrained by the amount of GPU virtual address space. <c>Evict</c> will not free-up any
		/// residency budget on such systems.
		/// </para>
		/// <para>
		/// Applications must handle <b>MakeResident</b> failures, even if there appears to be enough residency budget available. Physical
		/// memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications
		/// should free up more residency budget before trying again.
		/// </para>
		/// <para>
		/// <b>MakeResident</b> is ref-counted, such that <c>Evict</c> must be called the same amount of times as <b>MakeResident</b> before
		/// <b>Evict</b> takes effect. Objects that support residency are made resident during creation, so a single <b>Evict</b> call will
		/// actually evict the object.
		/// </para>
		/// <para>
		/// Applications must use fences to ensure the GPU doesn't use non-resident objects. <b>MakeResident</b> must return before the GPU
		/// executes a command list that references the object. <c>Evict</c> must be called after the GPU finishes executing a command list
		/// that references the object.
		/// </para>
		/// <para>
		/// Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource
		/// descriptors and other GPU virtual address references are not invalidated after <c>Evict</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-makeresident HRESULT MakeResident( UINT
		// NumObjects, [in] ID3D12Pageable * const *ppObjects );
		[PreserveSig]
		new HRESULT MakeResident(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects);

		/// <summary>Enables the page-out of data, which precludes GPU access of that data.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to evict from the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block that contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>
		/// Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following
		/// objects: Descriptor Heaps, Heaps, Committed Resources, and Query Heaps
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>Evict</b> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it
		/// was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns
		/// both virtual and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed
		/// resources are borrowing memory from a heap.
		/// </para>
		/// <para>Refer to the remarks for <c>MakeResident</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-evict HRESULT Evict( UINT NumObjects, [in]
		// ID3D12Pageable * const *ppObjects );
		[PreserveSig]
		new HRESULT Evict(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects);

		/// <summary>Creates a fence object.</summary>
		/// <param name="InitialValue">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>The initial value for the fence.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_FENCE_FLAGS</c></b></para>
		/// <para>
		/// A combination of <c>D3D12_FENCE_FLAGS</c>-typed values that are combined by using a bitwise OR operation. The resulting value
		/// specifies options for the fence.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the fence interface ( <c>ID3D12Fence</c>). The <b>REFIID</b>, or <b>GUID</b>,
		/// of the interface to the fence can be obtained by using the __uuidof() macro. For example, __uuidof(ID3D12Fence) will get the
		/// <b>GUID</b> of the interface to a fence.
		/// </para>
		/// </param>
		/// <param name="ppFence">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12Fence</c> interface that is used to access the fence.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createfence HRESULT CreateFence( UINT64
		// InitialValue, D3D12_FENCE_FLAGS Flags, REFIID riid, [out] void **ppFence );
		[PreserveSig]
		new HRESULT CreateFence(ulong InitialValue, D3D12_FENCE_FLAGS Flags, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppFence);

		/// <summary>
		/// Gets the reason that the device was removed, or <b>S_OK</b> if the device isn't removed. To be called back when a device is
		/// removed, consider using <c>ID3D12Fence::SetEventOnCompletion</c> with a value of <b>UINT64_MAX</b>. That's because device
		/// removal causes all fences to be signaled to that value (which also implies completing all events waited on, because they'll all
		/// be less than <b>UINT64_MAX</b>).
		/// </summary>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns the reason that the device was removed.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getdeviceremovedreason HRESULT GetDeviceRemovedReason();
		[PreserveSig]
		new HRESULT GetDeviceRemovedReason();

		/// <summary>
		/// Gets a resource layout that can be copied. Helps the app fill-in <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> when suballocating space in upload heaps.
		/// </summary>
		/// <param name="pResourceDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A description of the resource, as a pointer to a <c>D3D12_RESOURCE_DESC</c> structure.</para>
		/// </param>
		/// <param name="FirstSubresource">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Index of the first subresource in the resource. The range of valid values is 0 to D3D12_REQ_SUBRESOURCES.</para>
		/// </param>
		/// <param name="NumSubresources">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of subresources in the resource. The range of valid values is 0 to (D3D12_REQ_SUBRESOURCES - <i>FirstSubresource</i>).</para>
		/// </param>
		/// <param name="BaseOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset, in bytes, to the resource.</para>
		/// </param>
		/// <param name="pLayouts">
		/// <para>Type: <b><c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c>*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> structures, to be filled
		/// with the description and placement of each subresource.
		/// </para>
		/// </param>
		/// <param name="pNumRows">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, to be filled with the number of rows for each subresource.
		/// </para>
		/// </param>
		/// <param name="pRowSizeInBytes">
		/// <para>Type: <b>UINT64*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, each entry to be filled with the unpadded size in
		/// bytes of a row, of each subresource.
		/// </para>
		/// <para>For example, if a Texture2D resource has a width of 32 and bytes per pixel of 4,</para>
		/// <para>then <i>pRowSizeInBytes</i> returns 128.</para>
		/// <para>
		/// <i>pRowSizeInBytes</i> should not be confused with <b>row pitch</b>, as examining <i>pLayouts</i> and getting the row pitch from
		/// that will give you 256 as it is aligned to D3D12_TEXTURE_DATA_PITCH_ALIGNMENT.
		/// </para>
		/// </param>
		/// <param name="pTotalBytes">
		/// <para>Type: <b>UINT64*</b></para>
		/// <para>A pointer to an integer variable, to be filled with the total size, in bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// This routine assists the application in filling out <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> structures, when suballocating space in upload heaps. The resulting structures are GPU
		/// adapter-agnostic, meaning that the values will not vary from one GPU adapter to the next. <b>GetCopyableFootprints</b> uses
		/// specified details about resource formats, texture layouts, and alignment requirements (from the <c>D3D12_RESOURCE_DESC</c>
		/// structure) to fill out the subresource structures. Applications have access to all these details, so this method, or a variation
		/// of it, could be written as part of the app. Examples The <c>D3D12Multithreading</c> sample uses
		/// <b>ID3D12Device::GetCopyableFootprints</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Returns required size of a buffer to be used for data upload inline UINT64 GetRequiredIntermediateSize( _In_
		/// ID3D12Resource* pDestinationResource, _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		/// _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources) { D3D12_RESOURCE_DESC Desc =
		/// pDestinationResource-&gt;GetDesc(); UINT64 RequiredSize = 0; ID3D12Device* pDevice;
		/// pDestinationResource-&gt;GetDevice(__uuidof(*pDevice), reinterpret_cast&lt;void**&gt;(&amp;pDevice));
		/// pDevice-&gt;GetCopyableFootprints(&amp;Desc, FirstSubresource, NumSubresources, 0, nullptr, nullptr, nullptr,
		/// &amp;RequiredSize); pDevice-&gt;Release(); return RequiredSize; }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcopyablefootprints void GetCopyableFootprints(
		// [in] const D3D12_RESOURCE_DESC *pResourceDesc, [in] UINT FirstSubresource, [in] UINT NumSubresources, UINT64 BaseOffset, [out,
		// optional] D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts, [out, optional] UINT *pNumRows, [out, optional] UINT64 *pRowSizeInBytes,
		// [out, optional] UINT64 *pTotalBytes );
		[PreserveSig]
		new void GetCopyableFootprints(in D3D12_RESOURCE_DESC pResourceDesc, uint FirstSubresource, int NumSubresources, ulong BaseOffset,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_PLACED_SUBRESOURCE_FOOTPRINT[]? pLayouts,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[]? pNumRows,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[]? pRowSizeInBytes,
			out ulong pTotalBytes);

		/// <summary>Creates a query heap. A query heap contains an array of queries.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_QUERY_HEAP_DESC</c>*</b></para>
		/// <para>Specifies the query heap in a <c>D3D12_QUERY_HEAP_DESC</c> structure.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>Specifies a REFIID that uniquely identifies the heap.</para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// Specifies a pointer to the heap, that will be returned on successful completion of the method. <i>ppvHeap</i> can be NULL, to
		/// enable capability testing. When <i>ppvHeap</i> is NULL, no object will be created and S_FALSE will be returned when <i>pDesc</i>
		/// is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Refer to <c>Queries</c> for more information. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12Device::CreateQueryHeap</b> as follows:
		/// </para>
		/// <para>Create a query heap and a query result buffer.</para>
		/// <para>
		/// <c>// Pipeline objects. D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
		/// ComPtr&lt;ID3D12Device&gt; m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
		/// ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocators[FrameCount]; ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
		/// ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature; ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_cbvHeap; ComPtr&lt;ID3D12DescriptorHeap&gt; m_dsvHeap; ComPtr&lt;ID3D12QueryHeap&gt;
		/// m_queryHeap; UINT m_rtvDescriptorSize; UINT m_cbvSrvDescriptorSize; UINT m_frameIndex; // Synchronization objects.
		/// ComPtr&lt;ID3D12Fence&gt; m_fence; UINT64 m_fenceValues[FrameCount]; HANDLE m_fenceEvent; // Asset objects.
		/// ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState; ComPtr&lt;ID3D12PipelineState&gt; m_queryState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; ComPtr&lt;ID3D12Resource&gt; m_vertexBuffer; ComPtr&lt;ID3D12Resource&gt;
		/// m_constantBuffer; ComPtr&lt;ID3D12Resource&gt; m_depthStencil; ComPtr&lt;ID3D12Resource&gt; m_queryResult;
		/// D3D12_VERTEX_BUFFER_VIEW m_vertexBufferView;</c>
		/// </para>
		/// <para>
		/// <c>// Describe and create a heap for occlusion queries. D3D12_QUERY_HEAP_DESC queryHeapDesc = {}; queryHeapDesc.Count = 1;
		/// queryHeapDesc.Type = D3D12_QUERY_HEAP_TYPE_OCCLUSION; ThrowIfFailed(m_device-&gt;CreateQueryHeap(&amp;queryHeapDesc, IID_PPV_ARGS(&amp;m_queryHeap)));</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createqueryheap HRESULT CreateQueryHeap( [in]
		// const D3D12_QUERY_HEAP_DESC *pDesc, REFIID riid, [out, optional] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateQueryHeap(in D3D12_QUERY_HEAP_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>A development-time aid for certain types of profiling and experimental prototyping.</summary>
		/// <param name="Enable">
		/// <para>Type: <b>BOOL</b></para>
		/// <para>Specifies a BOOL that turns the stable power state on or off.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method is only useful during the development of applications. It enables developers to profile GPU usage of multiple
		/// algorithms without experiencing artifacts from <c>dynamic frequency scaling</c>.
		/// </para>
		/// <para>
		/// Do not call this method in normal execution for a shipped application. This method only works while the machine is in
		/// <c>developer mode</c>. If developer mode is not enabled, then device removal will occur. Instead, call this method in response
		/// to an off-by-default, developer-facing switch. Calling it in response to command line parameters, config files, registry keys,
		/// and developer console commands are reasonable usage scenarios.
		/// </para>
		/// <para>
		/// A stable power state typically fixes GPU clock rates at a slower setting that is significantly lower than that experienced by
		/// users under normal application load. This reduction in clock rate affects the entire system. Slow clock rates are required to
		/// ensure processors dont exhaust power, current, and thermal limits. Normal usage scenarios commonly leverage a processors
		/// ability to dynamically over-clock. Any conclusions made by comparing two designs under a stable power state should be
		/// double-checked with supporting results from real usage scenarios.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-setstablepowerstate HRESULT SetStablePowerState(
		// BOOL Enable );
		[PreserveSig]
		new HRESULT SetStablePowerState(bool Enable);

		/// <summary>This method creates a command signature.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_COMMAND_SIGNATURE_DESC</c>*</b></para>
		/// <para>Describes the command signature to be created with the <c>D3D12_COMMAND_SIGNATURE_DESC</c> structure.</para>
		/// </param>
		/// <param name="pRootSignature">
		/// <para>Type: <b><c>ID3D12RootSignature</c>*</b></para>
		/// <para>Specifies the <c>ID3D12RootSignature</c> that the command signature applies to.</para>
		/// <para>
		/// The root signature is required if any of the commands in the signature will update bindings on the pipeline. If the only command
		/// present is a draw or dispatch, the root signature parameter can be set to NULL.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the command signature interface ( <c>ID3D12CommandSignature</c>). The
		/// <b>REFIID</b>, or <b>GUID</b>, of the interface to the command signature can be obtained by using the __uuidof() macro. For
		/// example, __uuidof( <b>ID3D12CommandSignature</b>) will get the <b>GUID</b> of the interface to a command signature.
		/// </para>
		/// </param>
		/// <param name="ppvCommandSignature">
		/// <para>Type: <b>void**</b></para>
		/// <para>Specifies a pointer, that on successful completion of the method will point to the created command signature ( <c>ID3D12CommandSignature</c>).</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandsignature HRESULT
		// CreateCommandSignature( [in] const D3D12_COMMAND_SIGNATURE_DESC *pDesc, [in, optional] ID3D12RootSignature *pRootSignature,
		// REFIID riid, [out, optional] void **ppvCommandSignature );
		[PreserveSig]
		new HRESULT CreateCommandSignature(in D3D12_COMMAND_SIGNATURE_DESC pDesc, [In, Optional] ID3D12RootSignature? pRootSignature,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppvCommandSignature);

		/// <summary>Gets info about how a tiled resource is broken into tiles.</summary>
		/// <param name="pTiledResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies a tiled <c>ID3D12Resource</c> to get info about.</para>
		/// </param>
		/// <param name="pNumTilesForEntireResource">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>A pointer to a variable that receives the number of tiles needed to store the entire tiled resource.</para>
		/// </param>
		/// <param name="pPackedMipDesc">
		/// <para>Type: <b><c>D3D12_PACKED_MIP_INFO</c>*</b></para>
		/// <para>
		/// A pointer to a <c>D3D12_PACKED_MIP_INFO</c> structure that <b>GetResourceTiling</b> fills with info about how the tiled
		/// resource's mipmaps are packed.
		/// </para>
		/// </param>
		/// <param name="pStandardTileShapeForNonPackedMips">
		/// <para>Type: <b><c>D3D12_TILE_SHAPE</c>*</b></para>
		/// <para>
		/// Specifies a <c>D3D12_TILE_SHAPE</c> structure that <b>GetResourceTiling</b> fills with info about the tile shape. This is info
		/// about how pixels fit in the tiles, independent of tiled resource's dimensions, not including packed mipmaps. If the entire tiled
		/// resource is packed, this parameter is meaningless because the tiled resource has no defined layout for packed mipmaps. In this
		/// situation, <b>GetResourceTiling</b> sets the members of D3D12_TILE_SHAPE to zeros.
		/// </para>
		/// </param>
		/// <param name="pNumSubresourceTilings">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>
		/// A pointer to a variable that contains the number of tiles in the subresource. On input, this is the number of subresources to
		/// query tilings for; on output, this is the number that was actually retrieved at <i>pSubresourceTilingsForNonPackedMips</i>
		/// (clamped to what's available).
		/// </para>
		/// </param>
		/// <param name="FirstSubresourceTilingToGet">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// The number of the first subresource tile to get. <b>GetResourceTiling</b> ignores this parameter if the number that
		/// <i>pNumSubresourceTilings</i> points to is 0.
		/// </para>
		/// </param>
		/// <param name="pSubresourceTilingsForNonPackedMips">
		/// <para>Type: <b><c>D3D12_SUBRESOURCE_TILING</c>*</b></para>
		/// <para>
		/// Specifies a <c>D3D12_SUBRESOURCE_TILING</c> structure that <b>GetResourceTiling</b> fills with info about subresource tiles. If
		/// subresource tiles are part of packed mipmaps, <b>GetResourceTiling</b> sets the members of D3D12_SUBRESOURCE_TILING to zeros,
		/// except the <i>StartTileIndexInOverallResource</i> member, which <b>GetResourceTiling</b> sets to D3D12_PACKED_TILE (0xffffffff).
		/// The D3D12_PACKED_TILE constant indicates that the whole <b>D3D12_SUBRESOURCE_TILING</b> structure is meaningless for this
		/// situation, and the info that the <i>pPackedMipDesc</i> parameter points to applies.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// To estimate the total resource size of textures needed when calculating heap sizes and calling <c>CreatePlacedResource</c>, use
		/// <c>GetResourceAllocationInfo</c> instead of <b>GetResourceTiling</b>. <b>GetResourceTiling</b> cannot be used for this.
		/// </para>
		/// <para>For more information on tiled resources, refer to <c>Volume Tiled Resources</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getresourcetiling void GetResourceTiling( [in]
		// ID3D12Resource *pTiledResource, [out, optional] UINT *pNumTilesForEntireResource, [out, optional] D3D12_PACKED_MIP_INFO
		// *pPackedMipDesc, [out, optional] D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips, [in, out, optional] UINT
		// *pNumSubresourceTilings, [in] UINT FirstSubresourceTilingToGet, [out] D3D12_SUBRESOURCE_TILING
		// *pSubresourceTilingsForNonPackedMips );
		[PreserveSig]
		new void GetResourceTiling([In] ID3D12Resource pTiledResource, [Out, Optional] StructPointer<uint> pNumTilesForEntireResource,
			[Out, Optional] StructPointer<D3D12_PACKED_MIP_INFO> pPackedMipDesc, [Out, Optional] StructPointer<D3D12_TILE_SHAPE> pStandardTileShapeForNonPackedMips,
			[In, Out, Optional] StructPointer<uint> pNumSubresourceTilings, uint FirstSubresourceTilingToGet,
			[Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] D3D12_SUBRESOURCE_TILING[] pSubresourceTilingsForNonPackedMips);

		/// <summary>Gets a locally unique identifier for the current device (adapter).</summary>
		/// <returns>
		/// <para>Type: <b><c>LUID</c></b></para>
		/// <para>The locally unique identifier for the adapter.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this
		/// identifier to define robust mappings across various APIs (Direct3D 12, DXGI).
		/// </para>
		/// <para>
		/// A locally unique identifier (LUID) is a 64-bit value that is guaranteed to be unique only on the system on which it was
		/// generated. The uniqueness of a locally unique identifier (LUID) is guaranteed only until the system is restarted.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getadapterluid LUID GetAdapterLuid();
		[PreserveSig]
		new LUID GetAdapterLuid();

		/// <summary>
		/// <para>
		/// Creates a cached pipeline library. For pipeline state objects (PSOs) that are expected to share data together, grouping them
		/// into a library before serializing them means that there's less overhead due to metadata, as well as the opportunity to avoid
		/// redundant or duplicated data being written to disk.
		/// </para>
		/// <para>
		/// You can query for <b>ID3D12PipelineLibrary</b> support with <b><c>ID3D12Device::CheckFeatureSupport</c></b>, with
		/// <b><c>D3D12_FEATURE_SHADER_CACHE</c></b> and <b><c>D3D12_FEATURE_DATA_SHADER_CACHE</c></b>. If the Flags member of
		/// <b><c>D3D12_FEATURE_DATA_SHADER_CACHE</c></b> contains the flag <b><c>D3D12_SHADER_CACHE_SUPPORT_LIBRARY</c></b>, the
		/// <b>ID3D12PipelineLibrary</b> interface is supported. If not, then <b>DXGI_ERROR_NOT_SUPPORTED</b> will always be returned when
		/// this function is called.
		/// </para>
		/// </summary>
		/// <param name="pLibraryBlob">
		/// <para>Type: [in] <b>const void*</b></para>
		/// <para>
		/// If the input library blob is empty, then the initial content of the library is empty. If the input library blob is not empty,
		/// then it is validated for integrity, parsed, and the pointer is stored. The pointer provided as input to this method must remain
		/// valid for the lifetime of the object returned. For efficiency reasons, the data is not copied.
		/// </para>
		/// </param>
		/// <param name="BlobLength">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>Specifies the length of pLibraryBlob in bytes.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// Specifies a unique REFIID for the <c>ID3D12PipelineLibrary</c> object. Typically set this and the following parameter with the
		/// macro <c>IID_PPV_ARGS(&amp;Library)</c>, where <b>Library</b> is the name of the object.
		/// </para>
		/// </param>
		/// <param name="ppPipelineLibrary">
		/// <para>Type: [out] <b>void**</b></para>
		/// <para>Returns a pointer to the created library.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>, including
		/// <b>E_INVALIDARG</b> if the blob is corrupted or unrecognized, <b>D3D12_ERROR_DRIVER_VERSION_MISMATCH</b> if the provided data
		/// came from an old driver or runtime, and <b>D3D12_ERROR_ADAPTER_NOT_FOUND</b> if the data came from different hardware.
		/// </para>
		/// <para>
		/// If you pass <c>nullptr</c> for pPipelineLibrary then the runtime still performs the validation of the blob but avoid creating
		/// the actual library and returns S_FALSE if the library would have been created.
		/// </para>
		/// <para>Also, the feature requires an updated driver, and attempting to use it on old drivers will return DXGI_ERROR_UNSUPPORTED.</para>
		/// </returns>
		/// <remarks>
		/// <para>A pipeline library enables the following operations.</para>
		/// <list type="bullet">
		/// <item>
		/// <description>Adding pipeline state objects (PSOs) to an existing library object (refer to <c>StorePipeline</c>).</description>
		/// </item>
		/// <item>
		/// <description>Serializing a PSO library into a contiguous block of memory for disk storage (refer to <c>Serialize</c>).</description>
		/// </item>
		/// <item>
		/// <description>De-serializing a PSO library from persistent storage (this is handled by <b>CreatePipelineLibrary</b>).</description>
		/// </item>
		/// <item>
		/// <description>Retrieving individual PSOs from the library (refer to <c>LoadComputePipeline</c> and <c>LoadGraphicsPipeline</c>).</description>
		/// </item>
		/// </list>
		/// <para>At no point in the lifecycle of a pipeline library is there duplication between PSOs with identical sub-components.</para>
		/// <para>
		/// A recommended solution for managing the lifetime of the provided pointer while only having to ref-count the returned interface
		/// is to leverage <c>ID3D12Object::SetPrivateDataInterface</c>, and use an object which implements <b>IUnknown</b>, and frees the
		/// memory when the ref-count reaches 0.
		/// </para>
		/// <para>Thread Safety</para>
		/// <para>
		/// The pipeline library is thread-safe to use, and will internally synchronize as necessary, with one exception: multiple threads
		/// loading the same PSO (via <c><b>LoadComputePipeline</b></c>, <c><b>LoadGraphicsPipeline</b></c>, or <c><b>LoadPipeline</b></c>)
		/// should synchronize themselves, as this act may modify the state of that pipeline within the library in a non-thread-safe manner.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-createpipelinelibrary HRESULT
		// CreatePipelineLibrary( const void *pLibraryBlob, SIZE_T BlobLength, REFIID riid, void **ppPipelineLibrary );
		[PreserveSig]
		new HRESULT CreatePipelineLibrary([In] IntPtr pLibraryBlob, [In] SizeT BlobLength, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppPipelineLibrary);

		/// <summary>Specifies an event that should be fired when one or more of a collection of fences reach specific values.</summary>
		/// <param name="ppFences">
		/// <para>Type: <b>ID3D12Fence*</b></para>
		/// <para>An array of length <i>NumFences</i> that specifies the <c>ID3D12Fence</c> objects.</para>
		/// </param>
		/// <param name="pFenceValues">
		/// <para>Type: <b>const UINT64*</b></para>
		/// <para>An array of length <i>NumFences</i> that specifies the fence values required for the event is to be signaled.</para>
		/// </param>
		/// <param name="NumFences">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of fences to be included.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_MULTIPLE_FENCE_WAIT_FLAGS</c></b></para>
		/// <para>Specifies one of the <c>D3D12_MULTIPLE_FENCE_WAIT_FLAGS</c> that determines how to proceed.</para>
		/// </param>
		/// <param name="hEvent">
		/// <para>Type: <b>HANDLE</b></para>
		/// <para>A handle to the event object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns an HRESULT success or error code.</para>
		/// </returns>
		/// <remarks>
		/// <para>To specify a single fence refer to the <c>SetEventOnCompletion</c> method.</para>
		/// <para>If hEvent is a null handle, then this API will not return until the specified fence value(s) have been reached.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-seteventonmultiplefencecompletion HRESULT
		// SetEventOnMultipleFenceCompletion( [in] ID3D12Fence * const *ppFences, [in] const UINT64 *pFenceValues, UINT NumFences,
		// D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags, HANDLE hEvent );
		[PreserveSig]
		new HRESULT SetEventOnMultipleFenceCompletion([In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 2)] ID3D12Fence[] ppFences,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[] pFenceValues, int NumFences, D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
			HEVENT hEvent);

		/// <summary>This method sets residency priorities of a specified list of objects.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of objects in the <i>ppObjects</i> and <i>pPriorities</i> arrays.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b>ID3D12Pageable*</b></para>
		/// <para>Specifies an array, of length <i>NumObjects</i>, containing references to <c>ID3D12Pageable</c> objects.</para>
		/// </param>
		/// <param name="pPriorities">
		/// <para>Type: <b>const <c>D3D12_RESIDENCY_PRIORITY</c>*</b></para>
		/// <para>Specifies an array, of length <i>NumObjects</i>, of <c>D3D12_RESIDENCY_PRIORITY</c> values for the list of objects.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns an HRESULT success or error code.</para>
		/// </returns>
		/// <remarks>For more information, refer to <c>Residency</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority HRESULT
		// SetResidencyPriority( UINT NumObjects, [in] ID3D12Pageable * const *ppObjects, [in] const D3D12_RESIDENCY_PRIORITY *pPriorities );
		[PreserveSig]
		new HRESULT SetResidencyPriority(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_RESIDENCY_PRIORITY[] pPriorities);

		/// <summary>Creates a pipeline state object from a pipeline state stream description.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_PIPELINE_STATE_STREAM_DESC</c>*</b></para>
		/// <para>The address of a <c>D3D12_PIPELINE_STATE_STREAM_DESC</c> structure that describes the pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// </para>
		/// <para>The pipeline state object is an immutable state object. It contains no methods.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// This function takes the pipeline description as a <c>D3D12_PIPELINE_STATE_STREAM_DESC</c> and combines the functionality of the
		/// <c>ID3D12Device::CreateGraphicsPipelineState</c> and <c>ID3D12Device::CreateComputePipelineState</c> functions, which take their
		/// pipeline description as the less-flexible <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c> and <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c>
		/// structs, respectively.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device2-createpipelinestate HRESULT CreatePipelineState(
		// const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreatePipelineState(in D3D12_PIPELINE_STATE_STREAM_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>
		/// Creates a special-purpose diagnostic heap in system memory from an address. The created heap can persist even in the event of a
		/// GPU-fault or device-removed scenario.
		/// </summary>
		/// <param name="pAddress">
		/// <para>Type: <b>const void*</b></para>
		/// <para>The address used to create the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the heap interface ( <c>ID3D12Heap</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the heap can be obtained by using the <b>__uuidof()</b> macro. For
		/// example, <b>__uuidof(ID3D12Heap)</b> will retrieve the <b>GUID</b> of the interface to a heap.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block. On success, the D3D12 runtime will write a pointer to the newly-opened heap into the memory block.
		/// The type of the pointer depends on the provided <b>riid</b> parameter.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to open the existing heap. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>The heap is created in system memory and permits CPU access. It wraps the entire VirtualAlloc region.</para>
		/// <para>
		/// Heaps can be used for placed and reserved resources, as orthogonally as other heaps. Restrictions may still exist based on the
		/// flags that cannot be app-chosen.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-openexistingheapfromaddress HRESULT
		// OpenExistingHeapFromAddress( [in] const void *pAddress, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT OpenExistingHeapFromAddress([In] IntPtr pAddress, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>
		/// Creates a special-purpose diagnostic heap in system memory from a file mapping object. The created heap can persist even in the
		/// event of a GPU-fault or device-removed scenario.
		/// </summary>
		/// <param name="hFileMapping">
		/// <para>Type: <b><c>HANDLE</c></b></para>
		/// <para>The handle to the file mapping object to use to create the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the heap interface ( <c>ID3D12Heap</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the heap can be obtained by using the <b>__uuidof()</b> macro. For
		/// example, <b>__uuidof(ID3D12Heap)</b> will retrieve the <b>GUID</b> of the interface to a heap.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block. On success, the D3D12 runtime will write a pointer to the newly-opened heap into the memory block.
		/// The type of the pointer depends on the provided <b>riid</b> parameter.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to open the existing heap. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>The heap is created in system memory, and it permits CPU access. It wraps the entire VirtualAlloc region.</para>
		/// <para>
		/// Heaps can be used for placed and reserved resources, as orthogonally as other heaps. Restrictions may still exist based on the
		/// flags that cannot be app-chosen.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-openexistingheapfromfilemapping HRESULT
		// OpenExistingHeapFromFileMapping( HANDLE hFileMapping, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT OpenExistingHeapFromFileMapping([In] IntPtr hFileMapping, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>Asynchronously makes objects resident for the device.</summary>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_RESIDENCY_FLAGS</c></b></para>
		/// <para>Controls whether the objects should be made resident if the application is over its memory budget.</para>
		/// </param>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to make resident for the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block; contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>descriptor heaps</description>
		/// </item>
		/// <item>
		/// <description>heaps</description>
		/// </item>
		/// <item>
		/// <description>committed resources</description>
		/// </item>
		/// <item>
		/// <description>query heaps</description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pFenceToSignal">
		/// <para>Type: <b><c>ID3D12Fence</c>*</b></para>
		/// <para>A pointer to the fence used to signal when the work is done.</para>
		/// </param>
		/// <param name="FenceValueToSignal">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>An unsigned 64-bit value signaled to the fence when the work is done.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>EnqueueMakeResident</b> performs the same actions as <c>MakeResident</c>, but does not wait for the resources to be made
		/// resident. Instead, <b>EnqueueMakeResident</b> signals a fence when the work is done.
		/// </para>
		/// <para>
		/// The system will not allow work that references the resources that are being made resident by using <b>EnqueueMakeResident</b>
		/// before its fence is signaled. Instead, calls to this API are guaranteed to signal their corresponding fence in order, so the
		/// same fence can be used from call to call.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-enqueuemakeresident HRESULT EnqueueMakeResident(
		// D3D12_RESIDENCY_FLAGS Flags, UINT NumObjects, [in] ID3D12Pageable * const *ppObjects, [in] ID3D12Fence *pFenceToSignal, UINT64
		// FenceValueToSignal );
		[PreserveSig]
		new HRESULT EnqueueMakeResident(D3D12_RESIDENCY_FLAGS Flags, int NumObjects,
			[MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 1)] ID3D12Pageable[] ppObjects,
			[In] ID3D12Fence pFenceToSignal, ulong FenceValueToSignal);

		/// <summary>Creates a command list in the closed state. Also see <c>ID3D12Device::CreateCommandList</c>.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set a bit to identify the node (the device's
		/// physical adapter) for which to create the command list. Each bit in the mask corresponds to a single node. Only one bit must be
		/// set. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>Specifies the type of command list to create.</para>
		/// </param>
		/// <param name="flags">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_FLAGS</c></b></para>
		/// <para>Specifies creation flags.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the command list interface to return in ppCommandList.</para>
		/// </param>
		/// <param name="ppCommandList">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12CommandList</c> or <c>ID3D12GraphicsCommandList</c>
		/// interface for the command list.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the command list.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createcommandlist1 HRESULT CreateCommandList1(
		// [in] UINT nodeMask, [in] D3D12_COMMAND_LIST_TYPE type, D3D12_COMMAND_LIST_FLAGS flags, [in] REFIID riid, [out] void
		// **ppCommandList );
		[PreserveSig]
		new HRESULT CreateCommandList1(uint nodeMask, D3D12_COMMAND_LIST_TYPE type, D3D12_COMMAND_LIST_FLAGS flags, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppCommandList);

		/// <summary>
		/// <para>
		/// Creates an object that represents a session for content protection. You can then provide that session when you're creating
		/// resource or heap objects, to indicate that they should be protected.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>Memory contents can't be transferred from a protected resource to an unprotected resource.</para>
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_PROTECTED_RESOURCE_SESSION_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_PROTECTED_RESOURCE_SESSION_DESC</b> structure, describing the session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the <c>ID3D12ProtectedResourceSession</c> interface.</para>
		/// </param>
		/// <param name="ppSession">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives an <c>ID3D12ProtectedResourceSession</c> interface pointer to the created session object.
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createprotectedresourcesession HRESULT
		// CreateProtectedResourceSession( [in] const D3D12_PROTECTED_RESOURCE_SESSION_DESC *pDesc, [in] REFIID riid, [out] void **ppSession );
		[PreserveSig]
		new HRESULT CreateProtectedResourceSession(in D3D12_PROTECTED_RESOURCE_SESSION_DESC pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppSession);

		/// <summary>
		/// Creates both a resource and an implicit heap (optionally for a protected session), such that the heap is big enough to contain
		/// the entire resource, and the resource is mapped to the heap. Also see <c>ID3D12Device::CreateCommittedResource</c> for a code example.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createcommittedresource1 HRESULT
		// CreateCommittedResource1( [in] const D3D12_HEAP_PROPERTIES *pHeapProperties, [in] D3D12_HEAP_FLAGS HeapFlags, [in] const
		// D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialResourceState, [in, optional] const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riidResource, [out,
		// optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource1(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 6)] out object? ppvResource);

		/// <summary>
		/// Creates a heap (optionally for a protected session) that can be used with placed resources and reserved resources. Also see <c>ID3D12Device::CreateHeap</c>.
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_HEAP_DESC</b> structure that describes the heap.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// heap should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// <para>A heap with a protected session can't be created with the <c>D3D12_HEAP_FLAG_SHARED_CROSS_ADAPTER</c> flag.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the heap interface to return in ppvHeap.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Heap</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created heap object.</para>
		/// <para>
		/// <paramref name="ppvHeap"/> can be <c>nullptr</c>, to enable capability testing. When ppvHeap is <c>nullptr</c>, no object is
		/// created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the heap.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para><b>CreateHeap1</b> creates a heap that can be used with placed resources and reserved resources.</para>
		/// <para>
		/// Before releasing the final reference on the heap, your application must ensure that the GPU will no longer read or write to this heap.
		/// </para>
		/// <para>
		/// A placed resource object holds a reference on the heap it is created on; but a reserved resource doesn't hold a reference for
		/// each mapping made to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createheap1 HRESULT CreateHeap1( [in] const
		// D3D12_HEAP_DESC *pDesc, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riid, [out, optional] void
		// **ppvHeap );
		[PreserveSig]
		new HRESULT CreateHeap1(in D3D12_HEAP_DESC pDesc, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppvHeap);

		/// <summary>
		/// <para>
		/// Creates a resource (optionally for a protected session) that is reserved, and not yet mapped to any pages in a heap. Also see <c>ID3D12Device::CreateReservedResource</c>.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>Only tiles from heaps created with the same protected resource session can be mapped into a protected reserved resource.</para>
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/>&gt; specifies a value for which clear operations are most optimal. When the created
		/// resource is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or
		/// <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b> flags, you should choose the value with which the clear operation will most
		/// commonly be called. You can call the clear operation with other values, but those operations won't be as efficient as when the
		/// value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreateReservedResource</b> is equivalent to <c>D3D11_RESOURCE_MISC_TILED</c> in Direct3D 11. It creates a resource with
		/// virtual memory only, no backing store.
		/// </para>
		/// <para>You need to map the resource to physical memory (that is, to a heap) using <c>CopyTileMappings</c> and <c>UpdateTileMappings</c>.</para>
		/// <para>
		/// These resource types can only be created when the adapter supports tiled resource tier 1 or greater. The tiled resource tier
		/// defines the behavior of accessing a resource that is not mapped to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createreservedresource1 HRESULT
		// CreateReservedResource1( [in] const D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialState, [in, optional] const
		// D3D12_CLEAR_VALUE *pOptimizedClearValue, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riid,
		// [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource1(in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Gets rich info about the size and alignment of memory required for a collection of resources on this adapter. Also see <c>ID3D12Device::GetResourceAllocationInfo</c>.
		/// </para>
		/// <para>
		/// In addition to the <c>D3D12_RESOURCE_ALLOCATION_INFO</c> returned from the method, this version also returns an array of
		/// <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, which provide additional details for each resource description passed as
		/// input. See the pResourceAllocationInfo1 parameter.
		/// </para>
		/// </summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array. This is also the size (the number of elements in) pResourceAllocationInfo1.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <param name="pResourceAllocationInfo1">
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO1</c>*</b></para>
		/// <para>
		/// An array of <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, containing additional details for each resource description
		/// passed as input. This makes it simpler for your application to allocate a heap for multiple resources, and without manually
		/// computing offsets for where each resource should be placed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When you're using <c>CreatePlacedResource</c>, your application must use <b>GetResourceAllocationInfo</b> in order to understand
		/// the size and alignment characteristics of texture resources. The results of this method vary depending on the particular
		/// adapter, and must be treated as unique to this adapter and driver version.
		/// </para>
		/// <para>
		/// Your application can't use the output of <b>GetResourceAllocationInfo</b> to understand packed mip properties of textures. To
		/// understand packed mip properties of textures, your application must use <c>GetResourceTiling</c>.
		/// </para>
		/// <para>
		/// Texture resource sizes significantly differ from the information returned by <b>GetResourceTiling</b>, because some adapter
		/// architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios. This even
		/// includes textures that have constraints on their texture layouts, or have standardized texture layouts. That extra memory can't
		/// be sparsely mapped nor remapped by an application using <c>CreateReservedResource</c> and <c>UpdateTileMappings</c>, so it isn't
		/// reported by <b>GetResourceTiling</b>.
		/// </para>
		/// <para>
		/// Your application can forgo using <b>GetResourceAllocationInfo</b> for buffer resources (
		/// <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>). Buffers have the same size on all adapters, which is merely the smallest multiple of
		/// 64KB that's greater or equal to <c>D3D12_RESOURCE_DESC::Width</c>.
		/// </para>
		/// <para>
		/// When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used.
		/// For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource, reports differing sizes
		/// based on the order of the array. If the 4MB aligned resource is in the middle, then the resulting <b>Size</b> is 12MB.
		/// Otherwise, the resulting <b>Size</b> is 8MB. The <b>Alignment</b> returned would always be 4MB, because it's the superset of all
		/// alignments in the resource array.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-getresourceallocationinfo1(uint_uint_constd3d12_resource_desc_d3d12_resource_allocation_info1)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo1( [in] UINT visibleMask, [in] UINT numResourceDescs, [in] const
		// D3D12_RESOURCE_DESC *pResourceDescs, [out] D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1 );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo1(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC[] pResourceDescs,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[]? pResourceAllocationInfo1);

		/// <summary>
		/// Creates a lifetime tracker associated with an application-defined callback; the callback receives notifications when the
		/// lifetime of a tracked object is changed.
		/// </summary>
		/// <param name="pOwner">
		/// <para>Type: <b><c>ID3D12LifetimeOwner</c>*</b></para>
		/// <para>A pointer to an <b>ID3D12LifetimeOwner</b> interface representing the application-defined callback.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the interface identifier (IID) of the interface to return in ppvTracker.</para>
		/// </param>
		/// <param name="ppvTracker">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives the requested interface pointer to the created object.</para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createlifetimetracker HRESULT
		// CreateLifetimeTracker( [in] ID3D12LifetimeOwner *pOwner, [in] REFIID riid, [out] void **ppvTracker );
		[PreserveSig]
		new HRESULT CreateLifetimeTracker([In] ID3D12LifetimeOwner pOwner, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvTracker);

		/// <summary>
		/// You can call <b>RemoveDevice</b> to indicate to the Direct3D 12 runtime that the GPU device encountered a problem, and can no
		/// longer be used. Doing so will cause all devices' monitored fences to be signaled. Your application typically doesn't need to
		/// explicitly call <b>RemoveDevice</b>.
		/// </summary>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Because device removal triggers all fences to be signaled to <c>UINT64_MAX</c>, you can create a callback for device removal
		/// using an event.
		/// </para>
		/// <para>
		/// <c>HANDLE deviceRemovedEvent = CreateEventW(NULL, FALSE, FALSE, NULL); assert(deviceRemovedEvent != NULL);
		/// _deviceFence-&gt;SetEventOnCompletion(UINT64_MAX, deviceRemoved); HANDLE waitHandle; RegisterWaitForSingleObject(
		/// &amp;waitHandle, deviceRemovedEvent, OnDeviceRemoved, _device.Get(), // Pass the device as our context INFINITE, // No timeout 0
		/// // No flags ); void OnDeviceRemoved(PVOID context, BOOLEAN) { ID3D12Device* removedDevice = (ID3D12Device*)context; HRESULT
		/// removedReason = removedDevice-&gt;GetDeviceRemovedReason(); // Perform app-specific device removed operation, such as logging or
		/// inspecting DRED output }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-removedevice void RemoveDevice();
		[PreserveSig]
		new void RemoveDevice();

		/// <summary>Queries reflection metadata about available meta commands.</summary>
		/// <param name="pNumMetaCommands">
		/// <para>Type: [in, out] <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a <c>UINT</c> containing the number of meta commands to query for. This field determines the size of the
		/// <i>pDescs</i> array, unless <i>pDescs</i> is <b>nullptr</b>.
		/// </para>
		/// </param>
		/// <param name="pDescs">
		/// <para>Type: [out, optional] <b><c>D3D12_META_COMMAND_DESC</c>*</b></para>
		/// <para>
		/// An optional pointer to an array of <c>D3D12_META_COMMAND_DESC</c> containing the descriptions of the available meta commands.
		/// Pass <c>nullptr</c> to have the number of available meta commands returned in <i>pNumMetaCommands</i>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-enumeratemetacommands HRESULT
		// EnumerateMetaCommands( UINT *pNumMetaCommands, D3D12_META_COMMAND_DESC *pDescs );
		[PreserveSig]
		new HRESULT EnumerateMetaCommands(ref int pNumMetaCommands, [Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_META_COMMAND_DESC[]? pDescs);

		/// <summary>Queries reflection metadata about the parameters of the specified meta command.</summary>
		/// <param name="CommandId">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier (GUID) of the meta command whose parameters you wish to be returned in <i>pParameterDescs</i>.</para>
		/// </param>
		/// <param name="Stage">
		/// <para>Type: <b>D3D12_META_COMMAND_PARAMETER_STAGE</b></para>
		/// <para>
		/// A <c>D3D12_META_COMMAND_PARAMETER_STAGE</c> specifying the stage of the parameters that you wish to be included in the query.
		/// </para>
		/// </param>
		/// <param name="pTotalStructureSizeInBytes">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// An optional pointer to a <c>UINT</c> containing the size of the structure containing the parameter values, which you pass when
		/// creating/initializing/executing the meta command, as appropriate.
		/// </para>
		/// </param>
		/// <param name="pParameterCount">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a <c>UINT</c> containing the number of parameters to query for. This field determines the size of the
		/// <i>pParameterDescs</i> array, unless <i>pParameterDescs</i> is <b>nullptr</b>.
		/// </para>
		/// </param>
		/// <param name="pParameterDescs">
		/// <para>Type: <b>D3D12_META_COMMAND_PARAMETER_DESC*</b></para>
		/// <para>
		/// An optional pointer to an array of <c>D3D12_META_COMMAND_PARAMETER_DESC</c> containing the descriptions of the parameters. Pass
		/// <b>nullptr</b> to have the parameter count returned in <i>pParameterCount</i>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HRESULT</b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-enumeratemetacommandparameters HRESULT
		// EnumerateMetaCommandParameters( [in] REFGUID CommandId, [in] D3D12_META_COMMAND_PARAMETER_STAGE Stage, [out, optional] UINT
		// *pTotalStructureSizeInBytes, [in, out] UINT *pParameterCount, [out, optional] D3D12_META_COMMAND_PARAMETER_DESC *pParameterDescs );
		[PreserveSig]
		new HRESULT EnumerateMetaCommandParameters(in Guid CommandId, D3D12_META_COMMAND_PARAMETER_STAGE Stage, out uint pTotalStructureSizeInBytes,
			ref int pParameterCount, [Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] D3D12_META_COMMAND_PARAMETER_DESC[]? pParameterDescs);

		/// <summary>Creates an instance of the specified meta command.</summary>
		/// <param name="CommandId">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier (GUID) of the meta command that you wish to instantiate.</para>
		/// </param>
		/// <param name="NodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-adapter operation, set this to zero. If there are multiple adapter nodes, set a bit to identify the node (one of the
		/// device's physical adapters) to which the meta command applies. Each bit in the mask corresponds to a single node. Only one bit
		/// must be set. See <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="pCreationParametersData">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>An optional pointer to a constant structure containing the values of the parameters for creating the meta command.</para>
		/// </param>
		/// <param name="CreationParametersDataSizeInBytes">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>A <c>SIZE_T</c> containing the size of the structure pointed to by <i>pCreationParametersData</i>, if set, otherwise 0.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// A reference to the globally unique identifier (GUID) of the interface that you wish to be returned in <i>ppMetaCommand</i>. This
		/// is expected to be the GUID of <c>ID3D12MetaCommand</c>.
		/// </para>
		/// </param>
		/// <param name="ppMetaCommand">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the meta command. This is the address of a pointer to an
		/// <c>ID3D12MetaCommand</c>, representing the meta command created.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HRESULT</b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>DXGI_ERROR_UNSUPPORTED</description>
		/// <description>The current hardware does not support the algorithm being requested</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createmetacommand HRESULT CreateMetaCommand(
		// [in] REFGUID CommandId, [in] UINT NodeMask, [in, optional] const void *pCreationParametersData, [in] SIZE_T
		// CreationParametersDataSizeInBytes, REFIID riid, [out] void **ppMetaCommand );
		[PreserveSig]
		new HRESULT CreateMetaCommand(in Guid CommandId, uint NodeMask, [In, Optional] IntPtr pCreationParametersData, [In] SizeT CreationParametersDataSizeInBytes,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppMetaCommand);

		/// <summary>Creates an <c>ID3D12StateObject</c>.</summary>
		/// <param name="pDesc">The description of the state object to create.</param>
		/// <param name="riid">The GUID of the interface to create. Use <i>__uuidof(ID3D12StateObject)</i>.</param>
		/// <param name="ppStateObject">The returned state object.</param>
		/// <returns>
		/// <para>Returns S_OK if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>E_INVALIDARG if one of the input parameters is invalid.</description>
		/// </item>
		/// <item>
		/// <description>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</description>
		/// </item>
		/// <item>
		/// <description>Possibly other error codes that are described in the <c>Direct3D 12 Return Codes</c> topic.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createstateobject HRESULT CreateStateObject(
		// [in] const D3D12_STATE_OBJECT_DESC *pDesc, REFIID riid, [out] void **ppStateObject );
		[PreserveSig]
		new HRESULT CreateStateObject(in D3D12_STATE_OBJECT_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppStateObject);

		/// <summary>Query the driver for resource requirements to build an acceleration structure.</summary>
		/// <param name="pDesc">
		/// <para>
		/// Description of the acceleration structure build. This structure is shared with <c>BuildRaytracingAccelerationStructure</c>. For
		/// more information, see <c>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS</c>.
		/// </para>
		/// <para>
		/// The implementation is allowed to look at all the CPU parameters in this struct and nested structs. It may not
		/// inspect/dereference any GPU virtual addresses, other than to check to see if a pointer is NULL or not, such as the optional
		/// transform in <c>D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC</c>, without dereferencing it. In other words, the calculation of
		/// resource requirements for the acceleration structure does not depend on the actual geometry data (such as vertex positions),
		/// rather it can only depend on overall properties, such as the number of triangles, number of instances etc.
		/// </para>
		/// </param>
		/// <param name="pInfo">The result of the query (in a <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO</c> structure).</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The input acceleration structure description is the same as what goes into <c>BuildRaytracingAccelerationStructure</c>. The
		/// result of this function lets the application provide the correct amount of output storage and scratch storage to
		/// <b>BuildRaytracingAccelerationStructure</b> given the same geometry.
		/// </para>
		/// <para>
		/// Builds can also be done with the same configuration passed to <b>GetAccelerationStructurePrebuildInfo</b> overall except equal
		/// or smaller counts for the number of geometries/instances or the number of vertices/indices/AABBs in any given geometry. In this
		/// case the storage requirements reported with the original sizes passed to <b>GetRaytracingAccelerationStructurePrebuildInfo</b>
		/// will be valid  the build may actually consume less space but not more. This is handy for app scenarios where having
		/// conservatively large storage allocated for acceleration structures is fine.
		/// </para>
		/// <para>
		/// This method is on the device interface as opposed to command list on the assumption that drivers must be able to calculate
		/// resource requirements for an acceleration structure build from only looking at the CPU-visible portions of the call, without
		/// having to dereference any pointers to GPU memory containing actual vertex data, index data, etc.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-getraytracingaccelerationstructureprebuildinfo
		// void GetRaytracingAccelerationStructurePrebuildInfo( [in] const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS *pDesc,
		// [out] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO *pInfo );
		[PreserveSig]
		new void GetRaytracingAccelerationStructurePrebuildInfo(in D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS pDesc, out D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO pInfo);

		/// <summary>
		/// Reports the compatibility of serialized data, such as a serialized raytracing acceleration structure resulting from a call to
		/// <c>CopyRaytracingAccelerationStructure</c> with mode <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_SERIALIZE</c>, with
		/// the current device/driver.
		/// </summary>
		/// <param name="SerializedDataType">The type of the serialized data. For more information, see <c>D3D12_SERIALIZED_DATA_TYPE</c>.</param>
		/// <param name="pIdentifierToCheck">
		/// Identifier from the header of the serialized data to check with the driver. For more information, see <c>D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER</c>.
		/// </param>
		/// <returns>The returned compatibility status. For more information, see <c>D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS</c>.</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-checkdrivermatchingidentifier
		// D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS CheckDriverMatchingIdentifier( [in] D3D12_SERIALIZED_DATA_TYPE SerializedDataType, [in]
		// const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER *pIdentifierToCheck );
		[PreserveSig]
		new D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS CheckDriverMatchingIdentifier(D3D12_SERIALIZED_DATA_TYPE SerializedDataType,
			in D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER pIdentifierToCheck);

		/// <summary>Sets the mode for driver background processing optimizations.</summary>
		/// <param name="Mode">
		/// <para>Type: <b><c>D3D12_BACKGROUND_PROCESSING_MODE</c></b></para>
		/// <para>The level of dynamic optimization to apply to GPU work that's subsequently submitted.</para>
		/// </param>
		/// <param name="MeasurementsAction">
		/// <para>Type: <b><c>D3D12_MEASUREMENTS_ACTION</c></b></para>
		/// <para>The action to take with the results of earlier workload instrumentation.</para>
		/// </param>
		/// <param name="hEventToSignalUponCompletion">
		/// <para>Type: <b><c>HANDLE</c></b></para>
		/// <para>
		/// An optional handle to signal when the function is complete. For example, if MeasurementsAction is set to
		/// <c>D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS</c>, then hEventToSignalUponCompletion is signaled when all resulting compilations
		/// have finished.
		/// </para>
		/// </param>
		/// <param name="pbFurtherMeasurementsDesired">
		/// <para>Type: <b><c>BOOL</c>*</b></para>
		/// <para>
		/// An optional pointer to a Boolean value. The function sets the value to <c>true</c> to indicate that you should continue
		/// profiling, otherwise, <c>false</c>.
		/// </para>
		/// </param>
		/// <remarks>
		/// <para>
		/// A graphics driver can use idle-priority background CPU threads to dynamically recompile shader programs. That can improve GPU
		/// performance by specializing shader code to better match details of the hardware that it's running on, and/or the context in
		/// which it's being used.
		/// </para>
		/// <para>
		/// As a developer, you don't have to do anything to benefit from this feature (over time, as drivers adopt background processing
		/// optimizations, existing shaders will automatically be tuned more efficiently). But, when you're profiling your code, you'll
		/// probably want to call <b>SetBackgroundProcessingMode</b> to make sure that any driver background processing optimizations have
		/// taken place before you take timing measurements. Here's an example.
		/// </para>
		/// <para>
		/// <c>SetBackgroundProcessingMode( D3D12_BACKGROUND_PROCESSING_MODE_ALLOW_INTRUSIVE_MEASUREMENTS, D3D_MEASUREMENTS_ACTION_KEEP_ALL,
		/// nullptr, nullptr); // Here, prime the system by rendering some typical content. // For example, a level flythrough.
		/// SetBackgroundProcessingMode( D3D12_BACKGROUND_PROCESSING_MODE_ALLOWED, D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS, nullptr,
		/// nullptr); // Here, continue rendering. This time with dynamic optimizations applied. // And then take your measurements.</c>
		/// </para>
		/// <para>
		/// <c>PIX</c> automatically uses <b>SetBackgroundProcessingMode</b>first to prime the system,and then to prevent any further
		/// changes from taking place in the middle of its analysis. PIX waits on an event (to make sure all background shader recompiles
		/// have finished) before it starts taking measurements.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device6-setbackgroundprocessingmode HRESULT
		// SetBackgroundProcessingMode( [in] D3D12_BACKGROUND_PROCESSING_MODE Mode, [in] D3D12_MEASUREMENTS_ACTION MeasurementsAction, [in]
		// HANDLE hEventToSignalUponCompletion, [out] BOOL *pbFurtherMeasurementsDesired );
		[PreserveSig]
		new HRESULT SetBackgroundProcessingMode(D3D12_BACKGROUND_PROCESSING_MODE Mode, D3D12_MEASUREMENTS_ACTION MeasurementsAction,
			[In] HEVENT hEventToSignalUponCompletion, out bool pbFurtherMeasurementsDesired);

		/// <summary>
		/// Incrementally add to an existing state object. This incurs lower CPU overhead than creating a state object from scratch that is
		/// a superset of an existing one (for example, adding a few more shaders).
		/// </summary>
		/// <param name="pAddition">
		/// <para>Type: _In_ <b>const <c>D3D12_STATE_OBJECT_DESC</c>*</b></para>
		/// <para>
		/// Description of state object contents to add to existing state object. To help generate this see the
		/// <b>CD3D12_STATE_OBJECT_DESC</b> helper in class in <c>d3dx12.h</c>.
		/// </para>
		/// </param>
		/// <param name="pStateObjectToGrowFrom">
		/// <para>Type: _In_ <b><c>ID3D12StateObject</c>*</b></para>
		/// <para>Existing state object, which can be in use (for example, active raytracing) during this operation.</para>
		/// <para>The existing state object must not be of type <b>Collection</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: _In_ <b>REFIID</b></para>
		/// <para>Must be the IID of the <c>ID3D12StateObject</c> interface.</para>
		/// </param>
		/// <param name="ppNewStateObject">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>Returned state object.</para>
		/// <para>
		/// Behavior is undefined if shader identifiers are retrieved for new shaders from this call and they are accessed via shader tables
		/// by any already existing or in-flight command list that references some older state object. Use of the new shaders added to the
		/// state object can occur only from commands (such as <b>DispatchRays</b> or <b>ExecuteIndirect</b> calls) recorded in a command
		/// list after the call to <b>AddToStateObject</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <b>S_OK</b> for success. <b>E_INVALIDARG</b>, <b>E_OUTOFMEMORY</b> on failure. The debug layer provides detailed status information.
		/// </returns>
		/// <remarks>For more info, see <c>AddToStateObject</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device7-addtostateobject HRESULT AddToStateObject( const
		// D3D12_STATE_OBJECT_DESC *pAddition, ID3D12StateObject *pStateObjectToGrowFrom, REFIID riid, void **ppNewStateObject );
		[PreserveSig]
		new HRESULT AddToStateObject(in D3D12_STATE_OBJECT_DESC pAddition, [In] ID3D12StateObject pStateObjectToGrowFrom, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppNewStateObject);

		/// <summary>
		/// <para>
		/// <b>CreateProtectedResourceSession1</b> revises the <c><b>ID3D12Device4::CreateProtectedResourceSession</b></c> method with
		/// provision (in the structure passed via the pDesc parameter) for a globally unique identifier ( <b>GUID</b>) that indicates the
		/// type of protected resource session.
		/// </para>
		/// <para>
		/// Calling <b>ID3D12Device4::CreateProtectedResourceSession</b> is equivalent to calling
		/// <b>ID3D12Device7::CreateProtectedResourceSession1</b> with the <b>D3D12_PROTECTED_RESOURCES_SESSION_HARDWARE_PROTECTED</b> GUID.
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_PROTECTED_RESOURCE_SESSION_DESC1</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_PROTECTED_RESOURCE_SESSION_DESC1</b> structure, describing the session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: _In_ <b>REFIID</b></para>
		/// <para>
		/// The GUID of the interface to a protected session. Most commonly, <c>ID3D12ProtectedResourceSession1</c>, although it may be any
		/// <b>GUID</b> for any interface. If the protected session object doesn't support the interface for this <b>GUID</b>, the getter
		/// will return <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppSession">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the session for the given protected session (the specific interface type
		/// returned depends on riid).
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device7-createprotectedresourcesession1 HRESULT
		// CreateProtectedResourceSession1( const D3D12_PROTECTED_RESOURCE_SESSION_DESC1 *pDesc, REFIID riid, void **ppSession );
		[PreserveSig]
		new HRESULT CreateProtectedResourceSession1(in D3D12_PROTECTED_RESOURCE_SESSION_DESC1 pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppSession);

		/// <summary>
		/// <para>
		/// Gets rich info about the size and alignment of memory required for a collection of resources on this adapter. Also see <c>ID3D12Device4::GetResourceAllocationInfo1</c>.
		/// </para>
		/// <para>This version also returns an array of <c>D3D12_RESOURCE_DESC1</c> structures.</para>
		/// </summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array. This is also the size (the number of elements in) pResourceAllocationInfo1.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC1</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <param name="pResourceAllocationInfo1">
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO1</c>*</b></para>
		/// <para>
		/// An array of <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, containing additional details for each resource description
		/// passed as input. This makes it simpler for your application to allocate a heap for multiple resources, and without manually
		/// computing offsets for where each resource should be placed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// </returns>
		/// <remarks>For remarks, see <c>ID3D12Device4::GetResourceAllocationInfo1</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-getresourceallocationinfo2(uint_uint_constd3d12_resource_desc1_d3d12_resource_allocation_info1)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo2( UINT visibleMask, UINT numResourceDescs, const D3D12_RESOURCE_DESC1
		// *pResourceDescs, D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1 );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo2(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC1[] pResourceDescs,
			[Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[] pResourceAllocationInfo1);

		/// <summary>
		/// Creates both a resource and an implicit heap (optionally for a protected session), such that the heap is big enough to contain
		/// the entire resource, and the resource is mapped to the heap. Also see <c>ID3D12Device::CreateCommittedResource</c> for a code example.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: _In_ <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createcommittedresource2 HRESULT
		// CreateCommittedResource2( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC1
		// *pDesc, D3D12_RESOURCE_STATES InitialResourceState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, ID3D12ProtectedResourceSession
		// *pProtectedSession, REFIID riidResource, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource2(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC1 pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 6)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC1</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>
		/// When a resource is created together with a <b>D3D12_HEAP_TYPE_UPLOAD</b> heap, InitialState must be
		/// <b>D3D12_RESOURCE_STATE_GENERIC_READ</b>. When a resource is created together with a <b>D3D12_HEAP_TYPE_READBACK</b> heap,
		/// InitialState must be <b>D3D12_RESOURCE_STATE_COPY_DEST</b>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>See <c>ID3D12Device::CreatePlacedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createplacedresource1 HRESULT
		// CreatePlacedResource1( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC1 *pDesc, D3D12_RESOURCE_STATES
		// InitialState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource1([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC1 pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>For purposes of sampler feedback, creates a descriptor suitable for binding.</summary>
		/// <param name="pTargetedResource">
		/// <para>Type: _In_opt_ <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The targeted resource, such as a texture, to create a descriptor for.</para>
		/// </param>
		/// <param name="pFeedbackResource">
		/// <para>Type: _In_opt_ <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The feedback resource, such as a texture, to create a descriptor for.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: _In_ <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>The CPU descriptor handle.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createsamplerfeedbackunorderedaccessview void
		// CreateSamplerFeedbackUnorderedAccessView( ID3D12Resource *pTargetedResource, ID3D12Resource *pFeedbackResource,
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateSamplerFeedbackUnorderedAccessView([In, Optional] ID3D12Resource? pTargetedResource, [In, Optional] ID3D12Resource? pFeedbackResource,
			D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>
		/// Gets a resource layout that can be copied. Helps your app fill in <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> when suballocating space in upload heaps.
		/// </summary>
		/// <param name="pResourceDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A description of the resource, as a pointer to a <b>D3D12_RESOURCE_DESC1</b> structure.</para>
		/// </param>
		/// <param name="FirstSubresource">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>Index of the first subresource in the resource. The range of valid values is 0 to D3D12_REQ_SUBRESOURCES.</para>
		/// </param>
		/// <param name="NumSubresources">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The number of subresources in the resource. The range of valid values is 0 to (D3D12_REQ_SUBRESOURCES - <i>FirstSubresource</i>).</para>
		/// </param>
		/// <param name="BaseOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset, in bytes, to the resource.</para>
		/// </param>
		/// <param name="pLayouts">
		/// <para>Type: [out, optional] <b><c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c>*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> structures, to be filled
		/// with the description and placement of each subresource.
		/// </para>
		/// </param>
		/// <param name="pNumRows">
		/// <para>Type: [out, optional] <b>UINT*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, to be filled with the number of rows for each subresource.
		/// </para>
		/// </param>
		/// <param name="pRowSizeInBytes">
		/// <para>Type: [out, optional] <b>UINT64*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, each entry to be filled with the unpadded size in
		/// bytes of a row, of each subresource.
		/// </para>
		/// <para>For example, if a Texture2D resource has a width of 32 and bytes per pixel of 4, then <i>pRowSizeInBytes</i> returns 128.</para>
		/// <para>
		/// <i>pRowSizeInBytes</i> should not be confused with <b>row pitch</b>, as examining <i>pLayouts</i> and getting the row pitch from
		/// that will give you 256 as it is aligned to D3D12_TEXTURE_DATA_PITCH_ALIGNMENT.
		/// </para>
		/// </param>
		/// <param name="pTotalBytes">
		/// <para>Type: [out, optional] <b>UINT64*</b></para>
		/// <para>A pointer to an integer variable, to be filled with the total size, in bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>For remarks and examples, see <c>ID3D12Device::GetCopyableFootprints</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-getcopyablefootprints1 void
		// GetCopyableFootprints1( const D3D12_RESOURCE_DESC1 *pResourceDesc, UINT FirstSubresource, UINT NumSubresources, UINT64
		// BaseOffset, D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts, UINT *pNumRows, UINT64 *pRowSizeInBytes, UINT64 *pTotalBytes );
		[PreserveSig]
		new void GetCopyableFootprints1(in D3D12_RESOURCE_DESC1 pResourceDesc, uint FirstSubresource, int NumSubresources, ulong BaseOffset,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_PLACED_SUBRESOURCE_FOOTPRINT[]? pLayouts,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[]? pNumRows,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[]? pRowSizeInBytes, out ulong pTotalBytes);

		/// <summary>
		/// Creates an object that grants access to a shader cache, potentially opening an existing cache or creating a new one.
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_SHADER_CACHE_SESSION_DESC</c>*</b></para>
		/// <para>A <b>D3D12_SHADER_CACHE_SESSION_DESC</b> structure describing the shader cache session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>The globally unique identifier (GUID) for the shader cache session interface.</para>
		/// </param>
		/// <param name="ppvSession">
		/// <para>Type: _COM_Outptr_opt_ <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12ShaderCacheSession</c> interface for the shader cache session.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>DXGI_ERROR_ALREADY_EXISTS</description>
		/// <description>You tried to create a cache with an existing identifier. See <c>D3D12_SHADER_CACHE_SESSION_DESC::Identifier</c>.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-createshadercachesession HRESULT
		// CreateShaderCacheSession( const D3D12_SHADER_CACHE_SESSION_DESC *pDesc, REFIID riid, void **ppvSession );
		[PreserveSig]
		new HRESULT CreateShaderCacheSession(in D3D12_SHADER_CACHE_SESSION_DESC pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvSession);

		/// <summary>
		/// Modifies the behavior of caches used internally by Direct3D or by the driver. <b>ShaderCacheControl</b> may be used only in
		/// developer mode.
		/// </summary>
		/// <param name="Kinds">
		/// <para>Type: <b><c>D3D12_SHADER_CACHE_KIND_FLAGS</c></b></para>
		/// <para>The caches to modify. Any one of these caches may or may not exist.</para>
		/// </param>
		/// <param name="Control">
		/// <para>Type: <b><c>D3D12_SHADER_CACHE_CONTROL_FLAGS</c></b></para>
		/// <para>
		/// The way in which to modify the caches. You can't pass both <b>DISABLE</b> and <b>ENABLE</b> at the same time; and you must pass
		/// at least one flag.
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-shadercachecontrol HRESULT ShaderCacheControl(
		// D3D12_SHADER_CACHE_KIND_FLAGS Kinds, D3D12_SHADER_CACHE_CONTROL_FLAGS Control );
		[PreserveSig]
		new HRESULT ShaderCacheControl(D3D12_SHADER_CACHE_KIND_FLAGS Kinds, D3D12_SHADER_CACHE_CONTROL_FLAGS Control);

		/// <summary>
		/// <para>Creates a command queue with a creator ID.</para>
		/// <para>Also see <c>ID3D12Device::CreateCommandQueue</c>.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_COMMAND_QUEUE_DESC</c>*</b></para>
		/// <para>Specifies a <b>D3D12_COMMAND_QUEUE_DESC</b> that describes the command queue.</para>
		/// </param>
		/// <param name="CreatorID">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>A creator ID. See <b>Remarks</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>The globally unique identifier (GUID) for the command queue interface.</para>
		/// </param>
		/// <param name="ppCommandQueue">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandQueue</c> interface for the command queue.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// Returns <b>E_OUTOFMEMORY</b> if there's insufficient memory to create the command queue; otherwise <b>S_OK</b>. See <c>Direct3D
		/// 12 return codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When multiple components in the same process are sharing a single Direct3D 12 device, often they will end up with separate
		/// workloads on independent command queues. In some hardware implementations, independent queues can run in parallel only with
		/// specific other command queues.
		/// </para>
		/// <para>
		/// Direct3D 12 applies a first-come, first-serve grouping for queues, which might not work well for all application or component
		/// designs. To help inform Direct3D 12's grouping of queues, you can specify a creator ID (which is unique per component) that
		/// restricts the grouping to other queues with the same ID. When possible, a component should choose the same unique ID for all of
		/// its queues. Microsoft has reserved a few well-known creator IDs for use by Microsoft-developed implementations of APIs on top of
		/// Direct3D 12.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-createcommandqueue1 HRESULT CreateCommandQueue1(
		// const D3D12_COMMAND_QUEUE_DESC *pDesc, REFIID CreatorID, REFIID riid, void **ppCommandQueue );
		[PreserveSig]
		new HRESULT CreateCommandQueue1(in D3D12_COMMAND_QUEUE_DESC pDesc, in Guid CreatorID, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppCommandQueue);

		/// <summary>
		/// <para>Creates a committed resource with an initial layout rather than an initial state.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: _In_ <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createcommittedresource3 HRESULT
		// CreateCommittedResource3( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC1
		// *pDesc, D3D12_BARRIER_LAYOUT InitialLayout, const D3D12_CLEAR_VALUE *pOptimizedClearValue, ID3D12ProtectedResourceSession
		// *pProtectedSession, UINT32 NumCastableFormats, const DXGI_FORMAT *pCastableFormats, REFIID riidResource, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource3(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC1 pDesc,
			D3D12_BARRIER_LAYOUT InitialLayout, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, int NumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 6)] DXGI_FORMAT[]? pCastableFormats, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 8)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>See <b>Remarks</b> for <c>ID3D12Device::CreatePlacedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createplacedresource2 HRESULT
		// CreatePlacedResource2( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC1 *pDesc, D3D12_BARRIER_LAYOUT
		// InitialLayout, const D3D12_CLEAR_VALUE *pOptimizedClearValue, UINT32 NumCastableFormats, const DXGI_FORMAT *pCastableFormats,
		// REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource2([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC1 pDesc, D3D12_BARRIER_LAYOUT InitialLayout,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, int NumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 5)] DXGI_FORMAT[] pCastableFormats, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 7)] out object? ppvResource);

		/// <summary>
		/// <para>Creates a resource that is reserved, and not yet mapped to any pages in a heap.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>See <b>Remarks</b> for <c>ID3D12Device.CreateReservedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createreservedresource2 HRESULT
		// CreateReservedResource2( const D3D12_RESOURCE_DESC *pDesc, D3D12_BARRIER_LAYOUT InitialLayout, const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, ID3D12ProtectedResourceSession *pProtectedSession, UINT32 NumCastableFormats, const DXGI_FORMAT
		// *pCastableFormats, [in] REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource2(in D3D12_RESOURCE_DESC pDesc, D3D12_BARRIER_LAYOUT InitialLayout,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession,
			int NumCastableFormats, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] DXGI_FORMAT[]? pCastableFormats,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 7)] out object? ppvResource);

		[PreserveSig]
		void CreateSampler2(in D3D12_SAMPLER_DESC pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);
	}

	[ComImport]
	[Guid("5af5c532-4c91-4cd0-b541-15a405395fc5")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ID3D12Device12 : ID3D12Device11, ID3D12Device10, ID3D12Device9, ID3D12Device8, ID3D12Device7, ID3D12Device6, ID3D12Device5, ID3D12Device4, ID3D12Device3, ID3D12Device2, ID3D12Device1, ID3D12Device, ID3D12Object
	{
		/// <summary>Gets application-defined data from a device object.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> that is associated with the data.</para>
		/// </param>
		/// <param name="pDataSize">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a variable that on input contains the size, in bytes, of the buffer that <i>pData</i> points to, and on output
		/// contains the size, in bytes, of the amount of data that <b>GetPrivateData</b> retrieved.
		/// </para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a memory block that receives the data from the device object if <i>pDataSize</i> points to a value that specifies a
		/// buffer large enough to hold the data.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// If the data returned is a pointer to an <c>IUnknown</c>, or one of its derivative classes, which was previously set by
		/// SetPrivateDataInterface, that interface will have its reference count incremented before the private data is returned.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-getprivatedata HRESULT GetPrivateData( [in]
		// REFGUID guid, [in, out] UINT *pDataSize, [out, optional] void *pData );
		[PreserveSig]
		new HRESULT GetPrivateData(in Guid guid, ref uint pDataSize, [Out, Optional] IntPtr pData);

		/// <summary>Sets application-defined data to a device object and associates that data with an application-defined <b>GUID</b>.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the data.</para>
		/// </param>
		/// <param name="DataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size in bytes of the data.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>
		/// A pointer to a memory block that contains the data to be stored with this device object. If <i>pData</i> is <b>NULL</b>,
		/// <i>DataSize</i> must also be 0, and any data that was previously associated with the <b>GUID</b> specified in <i>guid</i> will
		/// be destroyed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// Rather than using the Direct3D 11 debug object naming scheme of calling <b>ID3D12Object::SetPrivateData</b> using
		/// <b>WKPDID_D3DDebugObjectName</b> with an ASCII name, call <c>ID3D12Object::SetName</c> with a UNICODE name.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedata HRESULT SetPrivateData( [in]
		// REFGUID guid, [in] UINT DataSize, [in, optional] const void *pData );
		[PreserveSig]
		new HRESULT SetPrivateData(in Guid guid, uint DataSize, [In, Optional] IntPtr pData);

		/// <summary>
		/// Associates an <c>IUnknown</c>-derived interface with the device object, and associates that interface with an
		/// application-defined <b>GUID</b>.
		/// </summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the interface.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const <c>IUnknown</c>*</b></para>
		/// <para>
		/// A pointer to the <c>IUnknown</c>-derived interface to be associated with the device object. Its reference count is incremented
		/// when set, and its reference count is decremented when either the <c>ID3D12Object</c> is destroyed, or when the data is
		/// overwritten by calling <c>SetPrivateData</c> or <b>SetPrivateDataInterface</b> with the same <b>GUID</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 return codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedatainterface HRESULT
		// SetPrivateDataInterface( [in] REFGUID guid, [in, optional] const IUnknown *pData );
		[PreserveSig]
		new HRESULT SetPrivateDataInterface(in Guid guid, [In, Optional, MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 0)] object? pData);

		/// <summary>Associates a name with the device object. This name is for use in debug diagnostics and tools.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the device object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>This method takes UNICODE names.</para>
		/// <para>
		/// Note that this is simply a convenience wrapper around <c>ID3D12Object::SetPrivateData</c> with
		/// <b>WKPDID_D3DDebugObjectNameW</b>. Therefore names which are set with <c>SetName</c> can be retrieved with
		/// <c>ID3D12Object::GetPrivateData</c> with the same GUID. Additionally, D3D12 supports narrow strings for names, using the
		/// <b>WKPDID_D3DDebugObjectName</b> GUID directly instead.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setname HRESULT SetName( [in] LPCWSTR Name );
		[PreserveSig]
		new HRESULT SetName([MarshalAs(UnmanagedType.LPWStr)] string Name);

		/// <summary>Reports the number of physical adapters (nodes) that are associated with this device.</summary>
		/// <returns>
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of physical adapters (nodes) that this device has.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getnodecount UINT GetNodeCount();
		[PreserveSig]
		new uint GetNodeCount();

		/// <summary>
		/// <para>Creates a command queue.</para>
		/// <para>Also see <c>ID3D12Device9::CreateCommandQueue1</c>.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_COMMAND_QUEUE_DESC</c>*</b></para>
		/// <para>Specifies a <b>D3D12_COMMAND_QUEUE_DESC</b> that describes the command queue.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier (GUID) for the command queue interface. See <b>Remarks</b>. An input parameter.</para>
		/// </param>
		/// <param name="ppCommandQueue">
		/// <para>Type: [out] <b><b>void</b>**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandQueue</c> interface for the command queue.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the command queue. See <c>Direct3D 12 return
		/// codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the command queue can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12CommandQueue) will get the <b>GUID</b> of the interface to a command queue.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandqueue HRESULT CreateCommandQueue(
		// const D3D12_COMMAND_QUEUE_DESC *pDesc, REFIID riid, void **ppCommandQueue );
		[PreserveSig]
		new HRESULT CreateCommandQueue(in D3D12_COMMAND_QUEUE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppCommandQueue);

		/// <summary>Creates a command allocator object.</summary>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>
		/// A <c>D3D12_COMMAND_LIST_TYPE</c>-typed value that specifies the type of command allocator to create. The type of command
		/// allocator can be the type that records either direct command lists or bundles.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the command allocator interface ( <c>ID3D12CommandAllocator</c>). The
		/// <b>REFIID</b>, or <b>GUID</b>, of the interface to the command allocator can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12CommandAllocator) will get the <b>GUID</b> of the interface to a command allocator.
		/// </para>
		/// </param>
		/// <param name="ppCommandAllocator">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandAllocator</c> interface for the command allocator.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the command allocator. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The device creates command lists from the command allocator. Examples The <c>D3D12Bundles</c> sample uses
		/// <b>ID3D12Device::CreateCommandAllocator</b> as follows:
		/// </para>
		/// <para>
		/// <c>ThrowIfFailed(pDevice-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&amp;m_commandAllocator)));
		/// ThrowIfFailed(pDevice-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_BUNDLE, IID_PPV_ARGS(&amp;m_bundleAllocator)));</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandallocator HRESULT
		// CreateCommandAllocator( [in] D3D12_COMMAND_LIST_TYPE type, REFIID riid, [out] void **ppCommandAllocator );
		[PreserveSig]
		new HRESULT CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE type, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppCommandAllocator);

		/// <summary>Creates a graphics pipeline state object.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c> structure that describes graphics pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>). The <b>REFIID</b>,
		/// or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For example,
		/// __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// The pipeline state object is an immutable state object. It contains no methods.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-creategraphicspipelinestate HRESULT
		// CreateGraphicsPipelineState( [in] const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreateGraphicsPipelineState(in D3D12_GRAPHICS_PIPELINE_STATE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>Creates a compute pipeline state object.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c> structure that describes compute pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>). The <b>REFIID</b>,
		/// or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For example,
		/// __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// The pipeline state object is an immutable state object. It contains no methods.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcomputepipelinestate HRESULT
		// CreateComputePipelineState( [in] const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreateComputePipelineState(in D3D12_COMPUTE_PIPELINE_STATE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>Creates a command list.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set a bit to identify the node (the device's
		/// physical adapter) for which to create the command list. Each bit in the mask corresponds to a single node. Only one bit must be
		/// set. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>Specifies the type of command list to create.</para>
		/// </param>
		/// <param name="pCommandAllocator">
		/// <para>Type: <b><c>ID3D12CommandAllocator</c>*</b></para>
		/// <para>A pointer to the command allocator object from which the device creates command lists.</para>
		/// </param>
		/// <param name="pInitialState">
		/// <para>Type: <b><c>ID3D12PipelineState</c>*</b></para>
		/// <para>
		/// An optional pointer to the pipeline state object that contains the initial pipeline state for the command list. If it is
		/// <c>nullptr</c>, then the runtime sets a dummy initial pipeline state, so that drivers don't have to deal with undefined state.
		/// The overhead for this is low, particularly for a command list, for which the overall cost of recording the command list likely
		/// dwarfs the cost of a single initial state setting. So there's little cost in not setting the initial pipeline state parameter,
		/// if doing so is inconvenient.
		/// </para>
		/// <para>
		/// For bundles, on the other hand, it might make more sense to try to set the initial state parameter (since bundles are likely
		/// smaller overall, and can be reused frequently).
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the command list interface to return in ppCommandList.</para>
		/// </param>
		/// <param name="ppCommandList">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12CommandList</c> or <c>ID3D12GraphicsCommandList</c>
		/// interface for the command list.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the command list.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>The device creates command lists from the command allocator.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandlist HRESULT CreateCommandList( [in]
		// UINT nodeMask, [in] D3D12_COMMAND_LIST_TYPE type, [in] ID3D12CommandAllocator *pCommandAllocator, [in, optional]
		// ID3D12PipelineState *pInitialState, [in] REFIID riid, [out] void **ppCommandList );
		[PreserveSig]
		new HRESULT CreateCommandList(uint nodeMask, D3D12_COMMAND_LIST_TYPE type, [In] ID3D12CommandAllocator pCommandAllocator, [In, Optional] ID3D12PipelineState? pInitialState,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppCommandList);

		/// <summary>Gets information about the features that are supported by the current graphics driver.</summary>
		/// <param name="Feature">
		/// <para>Type: <b><c>D3D12_FEATURE</c></b></para>
		/// <para>A constant from the <c>D3D12_FEATURE</c> enumeration describing the feature(s) that you want to query for support.</para>
		/// </param>
		/// <param name="pFeatureSupportData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a data structure that corresponds to the value of the <i>Feature</i> parameter. To determine the corresponding data
		/// structure for each constant, see <c>D3D12_FEATURE</c>.
		/// </para>
		/// </param>
		/// <param name="FeatureSupportDataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size of the structure pointed to by the <i>pFeatureSupportData</i> parameter.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// Returns <b>S_OK</b> if successful. Returns <b>E_INVALIDARG</b> if an unsupported data type is passed to the
		/// <i>pFeatureSupportData</i> parameter or if a size mismatch is detected for the <i>FeatureSupportDataSize</i> parameter.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// As a usage example, to check for ray tracing support, specify the <c>D3D12_FEATURE_DATA_D3D12_OPTIONS5</c> structure in the
		/// <i>pFeatureSupportData</i> parameter. When the function completes successfully, access the <i>RaytracingTier</i> field (which
		/// specifies the supported ray tracing tier) of the now-populated <b>D3D12_FEATURE_DATA_D3D12_OPTIONS5</b> structure.
		/// </para>
		/// <para>For more info, see <c>Capability Querying</c>.</para>
		/// <para><c></c><c></c><c></c> Hardware support for DXGI Formats</para>
		/// <para>To view tables of DXGI formats and hardware features, refer to:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 12.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 12.0 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 11.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 11.0 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>Hardware Support for Direct3D 10Level9 Formats</c></description>
		/// </item>
		/// <item>
		/// <description><c>Format Support for Direct3D Feature Level 10.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>Format Support for Direct3D Feature Level 10.0 Hardware</c></description>
		/// </item>
		/// </list>
		/// <para>Examples</para>
		/// <para>The <c>D3D1211on12</c> sample uses <b>ID3D12Device::CheckFeatureSupport</b> as follows:</para>
		/// <para>
		/// <c>inline UINT8 D3D12GetFormatPlaneCount( _In_ ID3D12Device* pDevice, DXGI_FORMAT Format ) { D3D12_FEATURE_DATA_FORMAT_INFO
		/// formatInfo = {Format}; if (FAILED(pDevice-&gt;CheckFeatureSupport(D3D12_FEATURE_FORMAT_INFO, &amp;formatInfo,
		/// sizeof(formatInfo)))) { return 0; } return formatInfo.PlaneCount; }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport HRESULT CheckFeatureSupport(
		// D3D12_FEATURE Feature, [in, out] void *pFeatureSupportData, UINT FeatureSupportDataSize );
		[PreserveSig]
		new HRESULT CheckFeatureSupport(D3D12_FEATURE Feature, [In, Out] IntPtr pFeatureSupportData, uint FeatureSupportDataSize);

		/// <summary>Creates a descriptor heap object.</summary>
		/// <param name="pDescriptorHeapDesc">
		/// <para>Type: <b>const <c>D3D12_DESCRIPTOR_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DESCRIPTOR_HEAP_DESC</c> structure that describes the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the descriptor heap interface. See Remarks. An input parameter.</para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b><b>void</b>**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the descriptor heap. <i>ppvHeap</i> can be NULL, to enable capability
		/// testing. When <i>ppvHeap</i> is NULL, no object will be created and S_FALSE will be returned when <i>pDescriptorHeapDesc</i> is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the descriptor heap object. See <c>Direct3D
		/// 12 Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the descriptor heap can be obtained by using the __uuidof() macro. For
		/// example, __uuidof( <c>ID3D12DescriptorHeap</c>) will get the <b>GUID</b> of the interface to a descriptor heap. Examples The
		/// <c>D3D12HelloWorld</c> sample uses <b>ID3D12Device::CreateDescriptorHeap</b> as follows:
		/// </para>
		/// <para>Describe and create a render target view (RTV) descriptor heap.</para>
		/// <para>
		/// <c>// Create descriptor heaps. { // Describe and create a render target view (RTV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// rtvHeapDesc = {}; rtvHeapDesc.NumDescriptors = FrameCount; rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; rtvHeapDesc.Flags
		/// = D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;rtvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_rtvHeap))); m_rtvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV); } // Create frame resources. {
		/// CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); // Create a RTV for each frame. for
		/// (UINT n = 0; n &lt; FrameCount; n++) { ThrowIfFailed(m_swapChain-&gt;GetBuffer(n, IID_PPV_ARGS(&amp;m_renderTargets[n])));
		/// m_device-&gt;CreateRenderTargetView(m_renderTargets[n].Get(), nullptr, rtvHandle); rtvHandle.Offset(1, m_rtvDescriptorSize); }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap HRESULT
		// CreateDescriptorHeap( [in] const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateDescriptorHeap(in D3D12_DESCRIPTOR_HEAP_DESC pDescriptorHeapDesc, in Guid riid, [Out] IntPtr ppvHeap);

		/// <summary>
		/// Gets the size of the handle increment for the given type of descriptor heap. This value is typically used to increment a handle
		/// into a descriptor array by the correct amount.
		/// </summary>
		/// <param name="DescriptorHeapType">
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to get the size of the handle
		/// increment for.
		/// </param>
		/// <returns>Returns the size of the handle increment for the given type of descriptor heap, including any necessary padding.</returns>
		/// <remarks>
		/// <para>
		/// The descriptor size returned by this method is used as one input to the helper structures <c>CD3DX12_CPU_DESCRIPTOR_HANDLE</c>
		/// and <c>CD3DX12_GPU_DESCRIPTOR_HANDLE</c>. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12Device::GetDescriptorHandleIncrementSize</b> as follows:
		/// </para>
		/// <para>
		/// Create the descriptor heap for the resources. The <c>m_rtvDescriptorSize</c> variable stores the render target view descriptor
		/// handle increment size, and is used in the <b>Create frame resources</b> section of the code.
		/// </para>
		/// <para>
		/// <c>// Create descriptor heaps. { // Describe and create a render target view (RTV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// rtvHeapDesc = {}; rtvHeapDesc.NumDescriptors = FrameCount; rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; rtvHeapDesc.Flags
		/// = D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;rtvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_rtvHeap))); // Describe and create a depth stencil view (DSV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// dsvHeapDesc = {}; dsvHeapDesc.NumDescriptors = 1; dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV; dsvHeapDesc.Flags =
		/// D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;dsvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_dsvHeap))); // Describe and create a constant buffer view (CBV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// cbvHeapDesc = {}; cbvHeapDesc.NumDescriptors = CbvCountPerFrame * FrameCount; cbvHeapDesc.Type =
		/// D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV; cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
		/// ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;cbvHeapDesc, IID_PPV_ARGS(&amp;m_cbvHeap))); // Describe and create a heap
		/// for occlusion queries. D3D12_QUERY_HEAP_DESC queryHeapDesc = {}; queryHeapDesc.Count = 1; queryHeapDesc.Type =
		/// D3D12_QUERY_HEAP_TYPE_OCCLUSION; ThrowIfFailed(m_device-&gt;CreateQueryHeap(&amp;queryHeapDesc,
		/// IID_PPV_ARGS(&amp;m_queryHeap))); m_rtvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV); m_cbvSrvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV); } // Create frame resources. {
		/// CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); // Create a RTV and a command
		/// allocator for each frame. for (UINT n = 0; n &lt; FrameCount; n++) { ThrowIfFailed(m_swapChain-&gt;GetBuffer(n,
		/// IID_PPV_ARGS(&amp;m_renderTargets[n]))); m_device-&gt;CreateRenderTargetView(m_renderTargets[n].Get(), nullptr, rtvHandle);
		/// rtvHandle.Offset(1, m_rtvDescriptorSize); ThrowIfFailed(m_device-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT,
		/// IID_PPV_ARGS(&amp;m_commandAllocators[n]))); } }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getdescriptorhandleincrementsize UINT
		// GetDescriptorHandleIncrementSize( [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType );
		[PreserveSig]
		new uint GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);

		/// <summary>Creates a root signature layout.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single GPU operation, set this to zero. If there are multiple GPU nodes, set bits to identify the nodes (the device's
		/// physical adapters) to which the root signature is to apply. Each bit in the mask corresponds to a single node. Refer to
		/// <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="pBlobWithRootSignature">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>A pointer to the source data for the serialized signature.</para>
		/// </param>
		/// <param name="blobLengthInBytes">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>The size, in bytes, of the block of memory that <i>pBlobWithRootSignature</i> points to.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the root signature interface. See Remarks. An input parameter.</para>
		/// </param>
		/// <param name="ppvRootSignature">
		/// <para>Type: <b><b>void</b>**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the root signature.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// <para>This method returns <b>E_INVALIDARG</b> if the blob that <i>pBlobWithRootSignature</i> points to is invalid.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// If an application procedurally generates a <c>D3D12_ROOT_SIGNATURE_DESC</c> data structure, it must pass a pointer to this
		/// <b>D3D12_ROOT_SIGNATURE_DESC</b> in a call to <c>D3D12SerializeRootSignature</c> to make the serialized form. The application
		/// then passes the serialized form to <i>pBlobWithRootSignature</i> in a call to <b>ID3D12Device::CreateRootSignature</b>.
		/// </para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the root signature layout can be obtained by using the __uuidof() macro.
		/// For example, __uuidof( <c>ID3D12RootSignature</c>) will get the <b>GUID</b> of the interface to a root signature. Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12Device::CreateRootSignature</b> as follows:
		/// </para>
		/// <para>Create an empty root signature.</para>
		/// <para>
		/// <c>CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc; rootSignatureDesc.Init(0, nullptr, 0, nullptr,
		/// D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT); ComPtr&lt;ID3DBlob&gt; signature; ComPtr&lt;ID3DBlob&gt; error;
		/// ThrowIfFailed(D3D12SerializeRootSignature(&amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &amp;signature, &amp;error));
		/// ThrowIfFailed(m_device-&gt;CreateRootSignature(0, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(), IID_PPV_ARGS(&amp;m_rootSignature)));</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrootsignature HRESULT CreateRootSignature(
		// [in] UINT nodeMask, [in] const void *pBlobWithRootSignature, [in] SIZE_T blobLengthInBytes, REFIID riid, [out] void
		// **ppvRootSignature );
		[PreserveSig]
		new HRESULT CreateRootSignature(uint nodeMask, [In] IntPtr pBlobWithRootSignature, [In] SizeT blobLengthInBytes, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppvRootSignature);

		/// <summary>Creates a constant-buffer view for accessing resource data.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_CONSTANT_BUFFER_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_CONSTANT_BUFFER_VIEW_DESC</c> structure that describes the constant-buffer view.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the constant-buffer view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createconstantbufferview void
		// CreateConstantBufferView( [in, optional] const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE
		// DestDescriptor );
		[PreserveSig]
		new void CreateConstantBufferView([In, Optional] StructPointer<D3D12_CONSTANT_BUFFER_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a shader-resource view for accessing data in a resource.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the shader resource.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_SHADER_RESOURCE_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_SHADER_RESOURCE_VIEW_DESC</c> structure that describes the shader-resource view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and for buffers SRVs target a full buffer and are typed (not raw or structured), and for textures SRVs target a full texture,
		/// all mips and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// Describes the CPU descriptor handle that represents the shader-resource view. This handle can be created in a shader-visible or
		/// non-shader-visible descriptor heap.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para><c></c><c></c><c></c> Processing YUV 4:2:0 video formats</para>
		/// <para>
		/// An app must map the luma (Y) plane separately from the chroma (UV) planes. Developers do this by calling
		/// <b>CreateShaderResourceView</b> twice for the same texture and passing in 1-channel and 2-channel formats. Passing in a
		/// 1-channel format compatible with the Y plane maps only the Y plane. Passing in a 2-channel format compatible with the UV planes
		/// (together) maps only the U and V planes as a single resource view.
		/// </para>
		/// <para>
		/// YUV 4:2:0 formats are listed in <c>DXGI_FORMAT</c>. Examples The <c>D3D12nBodyGravity</c> sample uses
		/// <b>ID3D12Device::CreateShaderResourceView</b> as follows:
		/// </para>
		/// <para>Describe and create two shader resource views based on one description.</para>
		/// <para>
		/// <c>D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {}; srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
		/// srvDesc.Format = DXGI_FORMAT_UNKNOWN; srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER; srvDesc.Buffer.FirstElement = 0;
		/// srvDesc.Buffer.NumElements = ParticleCount; srvDesc.Buffer.StructureByteStride = sizeof(Particle); srvDesc.Buffer.Flags =
		/// D3D12_BUFFER_SRV_FLAG_NONE; CD3DX12_CPU_DESCRIPTOR_HANDLE srvHandle0(m_srvUavHeap-&gt;GetCPUDescriptorHandleForHeapStart(),
		/// SrvParticlePosVelo0 + index, m_srvUavDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// srvHandle1(m_srvUavHeap-&gt;GetCPUDescriptorHandleForHeapStart(), SrvParticlePosVelo1 + index, m_srvUavDescriptorSize);
		/// m_device-&gt;CreateShaderResourceView(m_particleBuffer0[index].Get(), &amp;srvDesc, srvHandle0);
		/// m_device-&gt;CreateShaderResourceView(m_particleBuffer1[index].Get(), &amp;srvDesc, srvHandle1);</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createshaderresourceview void
		// CreateShaderResourceView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
		// [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateShaderResourceView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_SHADER_RESOURCE_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a view for unordered accessing.</summary>
		/// <param name="pResource">
		/// <para>Type: [in, optional] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the unordered access.</para>
		/// <para>At least one of <i>pResource</i> or <i>pDesc</i> must be provided.</para>
		/// <para>
		/// A null <i>pResource</i> is used to initialize a null descriptor, which guarantees Direct3D 11-like null binding behavior
		/// (reading 0s, writes are discarded), but must have a valid <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pCounterResource">
		/// <para>Type: [in, optional] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The <c>ID3D12Resource</c> for the counter (if any) associated with the UAV.</para>
		/// <para>
		/// If <i>pCounterResource</i> is not specified, then the <b>CounterOffsetInBytes</b> member of the <c>D3D12_BUFFER_UAV</c>
		/// structure must be 0.
		/// </para>
		/// <para>
		/// If <i>pCounterResource</i> is specified, then there is a counter associated with the UAV, and the runtime performs validation of
		/// the following requirements:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>The <b>StructureByteStride</b> member of the <c>D3D12_BUFFER_UAV</c> structure must be greater than 0.</description>
		/// </item>
		/// <item>
		/// <description>The format must be DXGI_FORMAT_UNKNOWN.</description>
		/// </item>
		/// <item>
		/// <description>The D3D12_BUFFER_UAV_FLAG_RAW flag (a <c>D3D12_BUFFER_UAV_FLAGS</c> enumeration constant) must not be set.</description>
		/// </item>
		/// <item>
		/// <description>Both of the resources ( <i>pResource</i> and <i>pCounterResource</i>) must be buffers.</description>
		/// </item>
		/// <item>
		/// <description>
		/// The <b>CounterOffsetInBytes</b> member of the <c>D3D12_BUFFER_UAV</c> structure must be a multiple of
		/// **D3D12_UAV_COUNTER_PLACEMENT_ALIGNMENT** (4096), and must be within the range of the counter resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description><i>pResource</i> cannot be NULL</description>
		/// </item>
		/// <item>
		/// <description><i>pDesc</i> cannot be NULL.</description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in, optional] <b>const <c>D3D12_UNORDERED_ACCESS_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_UNORDERED_ACCESS_VIEW_DESC</c> structure that describes the unordered-access view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and for buffers UAVs target a full buffer and are typed, and for textures UAVs target the first mip and all array slices. Not
		/// all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the unordered-access view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createunorderedaccessview void
		// CreateUnorderedAccessView( ID3D12Resource *pResource, ID3D12Resource *pCounterResource, const D3D12_UNORDERED_ACCESS_VIEW_DESC
		// *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateUnorderedAccessView([In, Optional] ID3D12Resource? pResource, [In, Optional] ID3D12Resource? pCounterResource,
			[In, Optional] StructPointer<D3D12_UNORDERED_ACCESS_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a render-target view for accessing resource data.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the render target.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RENDER_TARGET_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_RENDER_TARGET_VIEW_DESC</c> structure that describes the render-target view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and RTVs target the first mip and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the destination where the newly-created render target view will reside.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrendertargetview void
		// CreateRenderTargetView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_RENDER_TARGET_VIEW_DESC *pDesc, [in]
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateRenderTargetView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_RENDER_TARGET_VIEW_DESC> pDesc,
			[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a depth-stencil view for accessing resource data.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the depth stencil.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_DEPTH_STENCIL_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DEPTH_STENCIL_VIEW_DESC</c> structure that describes the depth-stencil view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and DSVs target the first mip and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the depth-stencil view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createdepthstencilview void
		// CreateDepthStencilView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc, [in]
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateDepthStencilView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_DEPTH_STENCIL_VIEW_DESC> pDesc,
			[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Create a sampler object that encapsulates sampling information for a texture.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_SAMPLER_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_SAMPLER_DESC</c> structure that describes the sampler.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the sampler.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsampler void CreateSampler( [in] const
		// D3D12_SAMPLER_DESC *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateSampler(in D3D12_SAMPLER_DESC pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Copies descriptors from a source to a destination.</summary>
		/// <param name="NumDestDescriptorRanges">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of destination descriptor ranges to copy to.</para>
		/// </param>
		/// <param name="pDestDescriptorRangeStarts">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>An array of <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> objects to copy to.</para>
		/// <para>All the destination and source descriptors must be in heaps of the same <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>.</para>
		/// </param>
		/// <param name="pDestDescriptorRangeSizes">
		/// <para>Type: <b>const <c>UINT</c>*</b></para>
		/// <para>An array of destination descriptor range sizes to copy to.</para>
		/// </param>
		/// <param name="NumSrcDescriptorRanges">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of source descriptor ranges to copy from.</para>
		/// </param>
		/// <param name="pSrcDescriptorRangeStarts">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>An array of <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> objects to copy from.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// All elements in the pSrcDescriptorRangeStarts parameter must be in a non shader-visible descriptor heap. This is because
		/// shader-visible descriptor heaps may be created in <b>WRITE_COMBINE</b> memory or GPU local memory, which is prohibitively slow
		/// to read from. If your application manages descriptor heaps via copying the descriptors required for a given pass or frame from
		/// local "storage" descriptor heaps to the GPU-bound descriptor heap, use shader-opaque heaps for the storage heaps and copy into
		/// the GPU-visible heap as required.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="pSrcDescriptorRangeSizes">
		/// <para>Type: <b>const <c>UINT</c>*</b></para>
		/// <para>An array of source descriptor range sizes to copy from.</para>
		/// </param>
		/// <param name="DescriptorHeapsType">
		/// <para>Type: <b><c>D3D12_DESCRIPTOR_HEAP_TYPE</c></b></para>
		/// <para>
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to copy with. This is required as
		/// different descriptor types may have different sizes.
		/// </para>
		/// <para>Both the source and destination descriptor heaps must have the same type, else the debug layer will emit an error.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// Where applicable, prefer <c><b>ID3D12Device::CopyDescriptorsSimple</b></c> to this method. It can have a better CPU cache miss
		/// rate due to the linear nature of the copy.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-copydescriptors void CopyDescriptors( [in] UINT
		// NumDestDescriptorRanges, [in] const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts, [in, optional] const UINT
		// *pDestDescriptorRangeSizes, [in] UINT NumSrcDescriptorRanges, [in] const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
		// [in, optional] const UINT *pSrcDescriptorRangeSizes, [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType );
		[PreserveSig]
		new void CopyDescriptors(int NumDestDescriptorRanges, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_CPU_DESCRIPTOR_HANDLE[] pDestDescriptorRangeStarts,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[]? pDestDescriptorRangeSizes, int NumSrcDescriptorRanges,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] D3D12_CPU_DESCRIPTOR_HANDLE[] pSrcDescriptorRangeStarts,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[]? pSrcDescriptorRangeSizes, D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);

		/// <summary>Copies descriptors from a source to a destination.</summary>
		/// <param name="NumDescriptors">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of descriptors to copy.</para>
		/// </param>
		/// <param name="DestDescriptorRangeStart">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> that describes the destination descriptors to start to copy to.</para>
		/// <para>The destination and source descriptors must be in heaps of the same <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>.</para>
		/// </param>
		/// <param name="SrcDescriptorRangeStart">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> that describes the source descriptors to start to copy from.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// The SrcDescriptorRangeStart parameter must be in a non shader-visible descriptor heap. This is because shader-visible descriptor
		/// heaps may be created in <b>WRITE_COMBINE</b> memory or GPU local memory, which is prohibitively slow to read from. If your
		/// application manages descriptor heaps via copying the descriptors required for a given pass or frame from local "storage"
		/// descriptor heaps to the GPU-bound descriptor heap, then use shader-opaque heaps for the storage heaps and copy into the
		/// GPU-visible heap as required.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="DescriptorHeapsType">
		/// <para>Type: <b><c>D3D12_DESCRIPTOR_HEAP_TYPE</c></b></para>
		/// <para>
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to copy with. This is required as
		/// different descriptor types may have different sizes.
		/// </para>
		/// <para>Both the source and destination descriptor heaps must have the same type, else the debug layer will emit an error.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// Where applicable, prefer this method to <c><b>ID3D12Device::CopyDescriptors</b></c>. It can have a better CPU cache miss rate
		/// due to the linear nature of the copy.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-copydescriptorssimple void CopyDescriptorsSimple(
		// [in] UINT NumDescriptors, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart, [in] D3D12_CPU_DESCRIPTOR_HANDLE
		// SrcDescriptorRangeStart, [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType );
		[PreserveSig]
		new void CopyDescriptorsSimple(uint NumDescriptors, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart, [In] D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
			D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);

		/// <summary>Gets the size and alignment of memory required for a collection of resources on this adapter.</summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// <para>If an error occurs, then <b>D3D12_RESOURCE_ALLOCATION_INFO::SizeInBytes</b> equals <b>UINT64_MAX</b>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When you're using <c>CreatePlacedResource</c>, your application must use <b>GetResourceAllocationInfo</b> in order to understand
		/// the size and alignment characteristics of texture resources. The results of this method vary depending on the particular
		/// adapter, and must be treated as unique to this adapter and driver version.
		/// </para>
		/// <para>
		/// Your application can't use the output of <b>GetResourceAllocationInfo</b> to understand packed mip properties of textures. To
		/// understand packed mip properties of textures, your application must use <c>GetResourceTiling</c>.
		/// </para>
		/// <para>
		/// Texture resource sizes significantly differ from the information returned by <b>GetResourceTiling</b>, because some adapter
		/// architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios. This even
		/// includes textures that have constraints on their texture layouts, or have standardized texture layouts. That extra memory can't
		/// be sparsely mapped nor remapped by an application using <c>CreateReservedResource</c> and <c>UpdateTileMappings</c>, so it isn't
		/// reported by <b>GetResourceTiling</b>.
		/// </para>
		/// <para>
		/// Your application can forgo using <b>GetResourceAllocationInfo</b> for buffer resources (
		/// <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>). Buffers have the same size on all adapters, which is merely the smallest multiple of
		/// 64KB that's greater or equal to <c>D3D12_RESOURCE_DESC::Width</c>.
		/// </para>
		/// <para>
		/// When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used.
		/// For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource, reports differing sizes
		/// based on the order of the array. If the 4MB aligned resource is in the middle, then the resulting <b>Size</b> is 12MB.
		/// Otherwise, the resulting <b>Size</b> is 8MB. The <b>Alignment</b> returned would always be 4MB, because it's the superset of all
		/// alignments in the resource array.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getresourceallocationinfo(uint_uint_constd3d12_resource_desc)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo( [in] UINT visibleMask, [in] UINT numResourceDescs, [in] const
		// D3D12_RESOURCE_DESC *pResourceDescs );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_RESOURCE_DESC[] pResourceDescs);

		/// <summary>
		/// Divulges the equivalent custom heap properties that are used for non-custom heap types, based on the adapter's architectural properties.
		/// </summary>
		/// <param name="nodeMask">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the device's
		/// physical adapter). Each bit in the mask corresponds to a single node. Only 1 bit must be set. See <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="heapType">
		/// <para>Type: <b><c>D3D12_HEAP_TYPE</c></b></para>
		/// <para>
		/// A <c>D3D12_HEAP_TYPE</c>-typed value that specifies the heap to get properties for. D3D12_HEAP_TYPE_CUSTOM is not supported as a
		/// parameter value.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_HEAP_PROPERTIES</c></b></para>
		/// <para>
		/// Returns a <c>D3D12_HEAP_PROPERTIES</c> structure that provides properties for the specified heap. The <b>Type</b> member of the
		/// returned D3D12_HEAP_PROPERTIES is always D3D12_HEAP_TYPE_CUSTOM.
		/// </para>
		/// <para>When <c>D3D12_FEATURE_DATA_ARCHITECTURE</c>::UMA is FALSE, the returned D3D12_HEAP_PROPERTIES members convert as follows:</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_COMBINE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L1.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// <para></para>
		/// <para>
		/// When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is FALSE, the returned
		/// D3D12_HEAP_PROPERTIES members convert as follows:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_COMBINE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// <para></para>
		/// <para>
		/// When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is TRUE, the returned
		/// D3D12_HEAP_PROPERTIES members convert as follows:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcustomheapproperties(uint_d3d12_heap_type)
		// D3D12_HEAP_PROPERTIES GetCustomHeapProperties( [in] UINT nodeMask, D3D12_HEAP_TYPE heapType );
		[PreserveSig]
		new D3D12_HEAP_PROPERTIES GetCustomHeapProperties(uint nodeMask, D3D12_HEAP_TYPE heapType);

		/// <summary>
		/// Creates both a resource and an implicit heap, such that the heap is big enough to contain the entire resource, and the resource
		/// is mapped to the heap.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource HRESULT
		// CreateCommittedResource( [in] const D3D12_HEAP_PROPERTIES *pHeapProperties, [in] D3D12_HEAP_FLAGS HeapFlags, [in] const
		// D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialResourceState, [in, optional] const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, [in] REFIID riidResource, [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>Creates a heap that can be used with placed resources and reserved resources.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_HEAP_DESC</b> structure that describes the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the heap interface to return in ppvHeap.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Heap</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// An optional pointer to a memory block that receives the requested interface pointer to the created heap object. <paramref
		/// name="ppvHeap"/> can be <c>nullptr</c>, to enable capability testing. When ppvHeap is <c>nullptr</c>, no object is created, and
		/// <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the heap.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para><b>CreateHeap</b> creates a heap that can be used with placed resources and reserved resources.</para>
		/// <para>
		/// Before releasing the final reference on the heap, your application must ensure that the GPU will no longer read or write to this heap.
		/// </para>
		/// <para>
		/// A placed resource object holds a reference on the heap it is created on; but a reserved resource doesn't hold a reference for
		/// each mapping made to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createheap HRESULT CreateHeap( [in] const
		// D3D12_HEAP_DESC *pDesc, [in] REFIID riid, [out, optional] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateHeap(in D3D12_HEAP_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>
		/// When a resource is created together with a <b>D3D12_HEAP_TYPE_UPLOAD</b> heap, InitialState must be
		/// <b>D3D12_RESOURCE_STATE_GENERIC_READ</b>. When a resource is created together with a <b>D3D12_HEAP_TYPE_READBACK</b> heap,
		/// InitialState must be <b>D3D12_RESOURCE_STATE_COPY_DEST</b>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreatePlacedResource</b> is similar to fully mapping a reserved resource to an offset within a heap; but the virtual address
		/// space associated with a heap may be reused as well.
		/// </para>
		/// <para>
		/// Placed resources are lighter weight to create and destroy than committed resources are. This is because no heap is created nor
		/// destroyed during those operations. In addition, placed resources enable an even lighter weight technique to reuse memory than
		/// resource creation and destructionthat is, reuse through aliasing, and aliasing barriers. Multiple placed resources may
		/// simultaneously overlap each other on the same heap, but only a single overlapping resource can be used at a time.
		/// </para>
		/// <para>
		/// There are two placed resource usage semanticsa simple model, and an advanced model. We recommend that you choose the simple
		/// model (it maximizes graphics tool support across the diverse ecosystem of GPUs), unless and until you find that you need the
		/// advanced model for your app.
		/// </para>
		/// <para>Simple model</para>
		/// <para>
		/// In this model, you can consider a placed resource to be in one of two states: active, or inactive. It's invalid for the GPU to
		/// either read or write from an inactive resource. Placed resources are created in the inactive state.
		/// </para>
		/// <para>
		/// To activate a resource with an aliasing barrier on a command list, your application must pass the resource in
		/// <c><b>D3D12_RESOURCE_ALIASING_BARRIER::pResourceAfter</b></c>. <b>pResourceBefore</b> can be left NULL during an activation. All
		/// resources that share physical memory with the activated resource now become inactive, which includes overlapping placed and
		/// reserved resources.
		/// </para>
		/// <para>Aliasing barriers should be grouped up and submitted together, in order to maximize efficiency.</para>
		/// <para>
		/// After activation, resources with either the render target or depth stencil flags must be further initialized. See the notes on
		/// the required resource initialization below.
		/// </para>
		/// <para>Notes on the required resource initialization</para>
		/// <para>
		/// Certain resource types still require initialization. Resources with either the render target or depth stencil flags must be
		/// initialized with either a clear operation or a collection of full subresource copies. If an aliasing barrier was used to denote
		/// the transition between two aliased resources, the initialization must occur after the aliasing barrier. This initialization is
		/// still required whenever a resource would've been activated in the simple model.
		/// </para>
		/// <para>
		/// Placed and reserved resources with either the render target or depth stencil flags must be initialized with one of the following
		/// operations before other operations are supported.
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>A Clear operation; for example <c>ClearRenderTargetView</c> or <c>ClearDepthStencilView</c>.</description>
		/// </item>
		/// <item>
		/// <description>A <c>DiscardResource</c> operation.</description>
		/// </item>
		/// <item>
		/// <description>A Copy operation; for example <c>CopyBufferRegion</c>, <c>CopyTextureRegion</c>, or <c>CopyResource</c>.</description>
		/// </item>
		/// </list>
		/// <para>
		/// Applications should prefer the most explicit operation that results in the least amount of texels modified. Consider the
		/// following examples.
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// Using a depth buffer to solve pixel visibility typically requires each depth texel start out at 1.0 or 0. Therefore, a Clear
		/// operation should be the most efficient option for aliased depth buffer initialization.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// An application may use an aliased render target as a destination for tone mapping. Since the application will render over every
		/// pixel during the tone mapping, <c>DiscardResource</c> should be the most efficient option for initialization.
		/// </description>
		/// </item>
		/// </list>
		/// <para>Advanced model</para>
		/// <para>In this model, you can ignore the active/inactive state abstraction. Instead, you must honor these lower-level rules.</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// An aliasing barrier must be between two different GPU resource accesses of the same physical memory, as long as those accesses
		/// are within the same <c>ExecuteCommandLists</c> call.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// The first rendering operation to certain types of aliased resource must still be an initialization, just like the simple model.
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// Initialization operations must occur either on an entire subresource, or on a 64KB granularity. An entire subresource
		/// initialization is supported for all resource types. A 64KB initialization granularity, aligned at a 64KB offset, is supported
		/// for buffers and textures with either the 64KB_UNDEFINED_SWIZZLE or 64KB_STANDARD_SWIZZLE texture layout (refer to <c>D3D12_TEXTURE_LAYOUT</c>).
		/// </para>
		/// <para>Notes on the aliasing barrier</para>
		/// <para>
		/// The aliasing barrier may set NULL for both pResourceAfter and pResourceBefore. The memory coherence definition of
		/// <c><b>ExecuteCommandLists</b></c> and an aliasing barrier are the same, such that two aliased accesses to the same physical
		/// memory need no aliasing barrier when the accesses are in two different <b>ExecuteCommandLists</b> invocations.
		/// </para>
		/// <para>
		/// For D3D12 advanced usage models, the synchronization definition of <c><b>ExecuteCommandLists</b></c> is equivalent to an
		/// aliasing barrier. Therefore, applications may either insert an aliasing barrier between reusing physical memory, or ensure the
		/// two aliased usages of physical memory occurs in two separate calls to <b>ExecuteCommandLists</b>.
		/// </para>
		/// <para>
		/// The amount of inactivation varies based on resource properties. Textures with undefined memory layouts are the worst case, as
		/// the entire texture must be inactivated atomically. For two overlapping resources with defined layouts, inactivation can result
		/// in only the overlapping aligned regions of a resource. Data inheritance can even be well-defined. For more details, see
		/// <c>Memory aliasing and data inheritance</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource HRESULT
		// CreatePlacedResource( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC *pDesc, D3D12_RESOURCE_STATES InitialState,
		// const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>Creates a resource that is reserved, and not yet mapped to any pages in a heap.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreateReservedResource</b> is equivalent to <c>D3D11_RESOURCE_MISC_TILED</c> in Direct3D 11. It creates a resource with
		/// virtual memory only, no backing store.
		/// </para>
		/// <para>You need to map the resource to physical memory (that is, to a heap) using <c>CopyTileMappings</c> and <c>UpdateTileMappings</c>.</para>
		/// <para>
		/// These resource types can only be created when the adapter supports tiled resource tier 1 or greater. The tiled resource tier
		/// defines the behavior of accessing a resource that is not mapped to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createreservedresource HRESULT
		// CreateReservedResource( [in] const D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialState, [in, optional] const
		// D3D12_CLEAR_VALUE *pOptimizedClearValue, [in] REFIID riid, [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource(in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppvResource);

		/// <summary>Creates a shared handle to a heap, resource, or fence object.</summary>
		/// <param name="pObject">
		/// <para>Type: <b><c>ID3D12DeviceChild</c>*</b></para>
		/// <para>
		/// A pointer to the <c>ID3D12DeviceChild</c> interface that represents the heap, resource, or fence object to create for sharing.
		/// The following interfaces (derived from <b>ID3D12DeviceChild</b>) are supported:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pAttributes">
		/// <para>Type: <b>const <c>SECURITY_ATTRIBUTES</c>*</b></para>
		/// <para>
		/// A pointer to a <c>SECURITY_ATTRIBUTES</c> structure that contains two separate but related data members: an optional security
		/// descriptor, and a <b>Boolean</b> value that determines whether child processes can inherit the returned handle.
		/// </para>
		/// <para>
		/// Set this parameter to <b>NULL</b> if you want child processes that the application might create to not inherit the handle
		/// returned by <b>CreateSharedHandle</b>, and if you want the resource that is associated with the returned handle to get a default
		/// security descriptor.
		/// </para>
		/// <para>
		/// The <b>lpSecurityDescriptor</b> member of the structure specifies a <c>SECURITY_DESCRIPTOR</c> for the resource. Set this member
		/// to <b>NULL</b> if you want the runtime to assign a default security descriptor to the resource that is associated with the
		/// returned handle. The ACLs in the default security descriptor for the resource come from the primary or impersonation token of
		/// the creator. For more info, see <c>Synchronization Object Security and Access Rights</c>.
		/// </para>
		/// </param>
		/// <param name="Access">
		/// <para>Type: <b><c>DWORD</c></b></para>
		/// <para>Currently the only value this parameter accepts is GENERIC_ALL.</para>
		/// </param>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>
		/// A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the shared heap. The name is limited to
		/// MAX_PATH characters. Name comparison is case-sensitive.
		/// </para>
		/// <para>
		/// If <i>Name</i> matches the name of an existing resource, <b>CreateSharedHandle</b> fails with
		/// <c>DXGI_ERROR_NAME_ALREADY_EXISTS</c>. This occurs because these objects share the same namespace.
		/// </para>
		/// <para>
		/// The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder
		/// of the name can contain any character except the backslash character (\). For more information, see <c>Kernel Object
		/// Namespaces</c>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the
		/// guidelines outlined for Terminal Services so that applications can support multiple users.
		/// </para>
		/// <para>The object can be created in a private namespace. For more information, see <c>Object Namespaces</c>.</para>
		/// </param>
		/// <param name="pHandle">
		/// <para>Type: <b><c>HANDLE</c>*</b></para>
		/// <para>
		/// A pointer to a variable that receives the NT HANDLE value to the resource to share. You can use this handle in calls to access
		/// the resource.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns S_OK if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>DXGI_ERROR_INVALID_CALL</c> if one of the parameters is invalid.</description>
		/// </item>
		/// <item>
		/// <description>
		/// <c>DXGI_ERROR_NAME_ALREADY_EXISTS</c> if the supplied name of the resource to share is already associated with another resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description>E_ACCESSDENIED if the object is being created in a protected namespace.</description>
		/// </item>
		/// <item>
		/// <description>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</description>
		/// </item>
		/// <item>
		/// <description>Possibly other error codes that are described in the <c>Direct3D 12 Return Codes</c> topic.</description>
		/// </item>
		/// </list>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Both heaps and committed resources can be shared. Sharing a committed resource shares the implicit heap along with the committed
		/// resource description, such that a compatible resource description can be mapped to the heap from another device.
		/// </para>
		/// <para>
		/// For Direct3D 11 and Direct3D 12 interop scenarios, a shared fence is opened in DirectX 11 with the
		/// <c>ID3D11Device5::OpenSharedFence</c> method, and a shared resource is opened with the <c>ID3D11Device::OpenSharedResource1</c> method.
		/// </para>
		/// <para>
		/// For Direct3D 12, a shared handle is opened with the <c>ID3D12Device::OpenSharedHandle</c> or the
		/// ID3D12Device::OpenSharedHandleByName method.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle HRESULT CreateSharedHandle(
		// [in] ID3D12DeviceChild *pObject, [in, optional] const SECURITY_ATTRIBUTES *pAttributes, DWORD Access, [in, optional] LPCWSTR
		// Name, [out] HANDLE *pHandle );
		[PreserveSig]
		new HRESULT CreateSharedHandle([In] ID3D12DeviceChild pObject, [In, Optional] SECURITY_ATTRIBUTES? pAttributes, ACCESS_MASK Access,
			[Optional, MarshalAs(UnmanagedType.LPWStr)] string? Name, out HANDLE pHandle);

		/// <summary>Opens a handle for shared resources, shared heaps, and shared fences, by using HANDLE and REFIID.</summary>
		/// <param name="NTHandle">
		/// <para>Type: <b>HANDLE</b></para>
		/// <para>The handle that was output by the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for one of the following interfaces:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// <para>
		/// The REFIID , or GUID , of the interface can be obtained by using the __uuidof() macro. For example, __uuidof(ID3D12Heap) will
		/// get the GUID of the interface to a resource.
		/// </para>
		/// </param>
		/// <param name="ppvObj">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to one of the following interfaces:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-opensharedhandle HRESULT OpenSharedHandle( [in]
		// HANDLE NTHandle, REFIID riid, [out, optional] void **ppvObj );
		[PreserveSig]
		new HRESULT OpenSharedHandle(HANDLE NTHandle, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvObj);

		/// <summary>Opens a handle for shared resources, shared heaps, and shared fences, by using Name and Access.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>The name that was optionally passed as the <i>Name</i> parameter in the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="Access">
		/// <para>Type: <b>DWORD</b></para>
		/// <para>The access level that was specified in the <i>Access</i> parameter in the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="pNTHandle">
		/// <para>Type: <b>HANDLE*</b></para>
		/// <para>Pointer to the shared handle.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-opensharedhandlebyname HRESULT
		// OpenSharedHandleByName( [in] LPCWSTR Name, DWORD Access, [out] HANDLE *pNTHandle );
		[PreserveSig]
		new HRESULT OpenSharedHandleByName([MarshalAs(UnmanagedType.LPWStr)] string Name, ACCESS_MASK Access, out HANDLE pNTHandle);

		/// <summary>Makes objects resident for the device.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to make resident for the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block that contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>
		/// Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following
		/// objects: Descriptor Heaps, Heaps, Committed Resources, and Query Heaps
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>MakeResident</b> loads the data associated with a resource from disk, and re-allocates the memory from the resource's
		/// appropriate memory pool. This method should be called on the object which owns the physical memory.
		/// </para>
		/// <para>
		/// Use this method, and <c>Evict</c>, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to
		/// be done by the app in D3D12.
		/// </para>
		/// <para>
		/// <b>MakeResident</b> and <c>Evict</c> can help applications manage the residency budget on many adapters. <b>MakeResident</b>
		/// explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <b>Evict</b> enables page-out.
		/// </para>
		/// <para>
		/// Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use
		/// <c>D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT</c> and <c>IDXGIAdapter3::QueryVideoMemoryInfo</c> to recognize when the
		/// maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the
		/// residency budget will always be constrained by the amount of GPU virtual address space. <c>Evict</c> will not free-up any
		/// residency budget on such systems.
		/// </para>
		/// <para>
		/// Applications must handle <b>MakeResident</b> failures, even if there appears to be enough residency budget available. Physical
		/// memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications
		/// should free up more residency budget before trying again.
		/// </para>
		/// <para>
		/// <b>MakeResident</b> is ref-counted, such that <c>Evict</c> must be called the same amount of times as <b>MakeResident</b> before
		/// <b>Evict</b> takes effect. Objects that support residency are made resident during creation, so a single <b>Evict</b> call will
		/// actually evict the object.
		/// </para>
		/// <para>
		/// Applications must use fences to ensure the GPU doesn't use non-resident objects. <b>MakeResident</b> must return before the GPU
		/// executes a command list that references the object. <c>Evict</c> must be called after the GPU finishes executing a command list
		/// that references the object.
		/// </para>
		/// <para>
		/// Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource
		/// descriptors and other GPU virtual address references are not invalidated after <c>Evict</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-makeresident HRESULT MakeResident( UINT
		// NumObjects, [in] ID3D12Pageable * const *ppObjects );
		[PreserveSig]
		new HRESULT MakeResident(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects);

		/// <summary>Enables the page-out of data, which precludes GPU access of that data.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to evict from the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block that contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>
		/// Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following
		/// objects: Descriptor Heaps, Heaps, Committed Resources, and Query Heaps
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>Evict</b> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it
		/// was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns
		/// both virtual and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed
		/// resources are borrowing memory from a heap.
		/// </para>
		/// <para>Refer to the remarks for <c>MakeResident</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-evict HRESULT Evict( UINT NumObjects, [in]
		// ID3D12Pageable * const *ppObjects );
		[PreserveSig]
		new HRESULT Evict(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects);

		/// <summary>Creates a fence object.</summary>
		/// <param name="InitialValue">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>The initial value for the fence.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_FENCE_FLAGS</c></b></para>
		/// <para>
		/// A combination of <c>D3D12_FENCE_FLAGS</c>-typed values that are combined by using a bitwise OR operation. The resulting value
		/// specifies options for the fence.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the fence interface ( <c>ID3D12Fence</c>). The <b>REFIID</b>, or <b>GUID</b>,
		/// of the interface to the fence can be obtained by using the __uuidof() macro. For example, __uuidof(ID3D12Fence) will get the
		/// <b>GUID</b> of the interface to a fence.
		/// </para>
		/// </param>
		/// <param name="ppFence">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12Fence</c> interface that is used to access the fence.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createfence HRESULT CreateFence( UINT64
		// InitialValue, D3D12_FENCE_FLAGS Flags, REFIID riid, [out] void **ppFence );
		[PreserveSig]
		new HRESULT CreateFence(ulong InitialValue, D3D12_FENCE_FLAGS Flags, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppFence);

		/// <summary>
		/// Gets the reason that the device was removed, or <b>S_OK</b> if the device isn't removed. To be called back when a device is
		/// removed, consider using <c>ID3D12Fence::SetEventOnCompletion</c> with a value of <b>UINT64_MAX</b>. That's because device
		/// removal causes all fences to be signaled to that value (which also implies completing all events waited on, because they'll all
		/// be less than <b>UINT64_MAX</b>).
		/// </summary>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns the reason that the device was removed.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getdeviceremovedreason HRESULT GetDeviceRemovedReason();
		[PreserveSig]
		new HRESULT GetDeviceRemovedReason();

		/// <summary>
		/// Gets a resource layout that can be copied. Helps the app fill-in <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> when suballocating space in upload heaps.
		/// </summary>
		/// <param name="pResourceDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A description of the resource, as a pointer to a <c>D3D12_RESOURCE_DESC</c> structure.</para>
		/// </param>
		/// <param name="FirstSubresource">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Index of the first subresource in the resource. The range of valid values is 0 to D3D12_REQ_SUBRESOURCES.</para>
		/// </param>
		/// <param name="NumSubresources">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of subresources in the resource. The range of valid values is 0 to (D3D12_REQ_SUBRESOURCES - <i>FirstSubresource</i>).</para>
		/// </param>
		/// <param name="BaseOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset, in bytes, to the resource.</para>
		/// </param>
		/// <param name="pLayouts">
		/// <para>Type: <b><c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c>*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> structures, to be filled
		/// with the description and placement of each subresource.
		/// </para>
		/// </param>
		/// <param name="pNumRows">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, to be filled with the number of rows for each subresource.
		/// </para>
		/// </param>
		/// <param name="pRowSizeInBytes">
		/// <para>Type: <b>UINT64*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, each entry to be filled with the unpadded size in
		/// bytes of a row, of each subresource.
		/// </para>
		/// <para>For example, if a Texture2D resource has a width of 32 and bytes per pixel of 4,</para>
		/// <para>then <i>pRowSizeInBytes</i> returns 128.</para>
		/// <para>
		/// <i>pRowSizeInBytes</i> should not be confused with <b>row pitch</b>, as examining <i>pLayouts</i> and getting the row pitch from
		/// that will give you 256 as it is aligned to D3D12_TEXTURE_DATA_PITCH_ALIGNMENT.
		/// </para>
		/// </param>
		/// <param name="pTotalBytes">
		/// <para>Type: <b>UINT64*</b></para>
		/// <para>A pointer to an integer variable, to be filled with the total size, in bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// This routine assists the application in filling out <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> structures, when suballocating space in upload heaps. The resulting structures are GPU
		/// adapter-agnostic, meaning that the values will not vary from one GPU adapter to the next. <b>GetCopyableFootprints</b> uses
		/// specified details about resource formats, texture layouts, and alignment requirements (from the <c>D3D12_RESOURCE_DESC</c>
		/// structure) to fill out the subresource structures. Applications have access to all these details, so this method, or a variation
		/// of it, could be written as part of the app. Examples The <c>D3D12Multithreading</c> sample uses
		/// <b>ID3D12Device::GetCopyableFootprints</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Returns required size of a buffer to be used for data upload inline UINT64 GetRequiredIntermediateSize( _In_
		/// ID3D12Resource* pDestinationResource, _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		/// _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources) { D3D12_RESOURCE_DESC Desc =
		/// pDestinationResource-&gt;GetDesc(); UINT64 RequiredSize = 0; ID3D12Device* pDevice;
		/// pDestinationResource-&gt;GetDevice(__uuidof(*pDevice), reinterpret_cast&lt;void**&gt;(&amp;pDevice));
		/// pDevice-&gt;GetCopyableFootprints(&amp;Desc, FirstSubresource, NumSubresources, 0, nullptr, nullptr, nullptr,
		/// &amp;RequiredSize); pDevice-&gt;Release(); return RequiredSize; }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcopyablefootprints void GetCopyableFootprints(
		// [in] const D3D12_RESOURCE_DESC *pResourceDesc, [in] UINT FirstSubresource, [in] UINT NumSubresources, UINT64 BaseOffset, [out,
		// optional] D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts, [out, optional] UINT *pNumRows, [out, optional] UINT64 *pRowSizeInBytes,
		// [out, optional] UINT64 *pTotalBytes );
		[PreserveSig]
		new void GetCopyableFootprints(in D3D12_RESOURCE_DESC pResourceDesc, uint FirstSubresource, int NumSubresources, ulong BaseOffset,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_PLACED_SUBRESOURCE_FOOTPRINT[]? pLayouts,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[]? pNumRows,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[]? pRowSizeInBytes,
			out ulong pTotalBytes);

		/// <summary>Creates a query heap. A query heap contains an array of queries.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_QUERY_HEAP_DESC</c>*</b></para>
		/// <para>Specifies the query heap in a <c>D3D12_QUERY_HEAP_DESC</c> structure.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>Specifies a REFIID that uniquely identifies the heap.</para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// Specifies a pointer to the heap, that will be returned on successful completion of the method. <i>ppvHeap</i> can be NULL, to
		/// enable capability testing. When <i>ppvHeap</i> is NULL, no object will be created and S_FALSE will be returned when <i>pDesc</i>
		/// is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Refer to <c>Queries</c> for more information. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12Device::CreateQueryHeap</b> as follows:
		/// </para>
		/// <para>Create a query heap and a query result buffer.</para>
		/// <para>
		/// <c>// Pipeline objects. D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
		/// ComPtr&lt;ID3D12Device&gt; m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
		/// ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocators[FrameCount]; ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
		/// ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature; ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_cbvHeap; ComPtr&lt;ID3D12DescriptorHeap&gt; m_dsvHeap; ComPtr&lt;ID3D12QueryHeap&gt;
		/// m_queryHeap; UINT m_rtvDescriptorSize; UINT m_cbvSrvDescriptorSize; UINT m_frameIndex; // Synchronization objects.
		/// ComPtr&lt;ID3D12Fence&gt; m_fence; UINT64 m_fenceValues[FrameCount]; HANDLE m_fenceEvent; // Asset objects.
		/// ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState; ComPtr&lt;ID3D12PipelineState&gt; m_queryState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; ComPtr&lt;ID3D12Resource&gt; m_vertexBuffer; ComPtr&lt;ID3D12Resource&gt;
		/// m_constantBuffer; ComPtr&lt;ID3D12Resource&gt; m_depthStencil; ComPtr&lt;ID3D12Resource&gt; m_queryResult;
		/// D3D12_VERTEX_BUFFER_VIEW m_vertexBufferView;</c>
		/// </para>
		/// <para>
		/// <c>// Describe and create a heap for occlusion queries. D3D12_QUERY_HEAP_DESC queryHeapDesc = {}; queryHeapDesc.Count = 1;
		/// queryHeapDesc.Type = D3D12_QUERY_HEAP_TYPE_OCCLUSION; ThrowIfFailed(m_device-&gt;CreateQueryHeap(&amp;queryHeapDesc, IID_PPV_ARGS(&amp;m_queryHeap)));</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createqueryheap HRESULT CreateQueryHeap( [in]
		// const D3D12_QUERY_HEAP_DESC *pDesc, REFIID riid, [out, optional] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateQueryHeap(in D3D12_QUERY_HEAP_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>A development-time aid for certain types of profiling and experimental prototyping.</summary>
		/// <param name="Enable">
		/// <para>Type: <b>BOOL</b></para>
		/// <para>Specifies a BOOL that turns the stable power state on or off.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method is only useful during the development of applications. It enables developers to profile GPU usage of multiple
		/// algorithms without experiencing artifacts from <c>dynamic frequency scaling</c>.
		/// </para>
		/// <para>
		/// Do not call this method in normal execution for a shipped application. This method only works while the machine is in
		/// <c>developer mode</c>. If developer mode is not enabled, then device removal will occur. Instead, call this method in response
		/// to an off-by-default, developer-facing switch. Calling it in response to command line parameters, config files, registry keys,
		/// and developer console commands are reasonable usage scenarios.
		/// </para>
		/// <para>
		/// A stable power state typically fixes GPU clock rates at a slower setting that is significantly lower than that experienced by
		/// users under normal application load. This reduction in clock rate affects the entire system. Slow clock rates are required to
		/// ensure processors dont exhaust power, current, and thermal limits. Normal usage scenarios commonly leverage a processors
		/// ability to dynamically over-clock. Any conclusions made by comparing two designs under a stable power state should be
		/// double-checked with supporting results from real usage scenarios.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-setstablepowerstate HRESULT SetStablePowerState(
		// BOOL Enable );
		[PreserveSig]
		new HRESULT SetStablePowerState(bool Enable);

		/// <summary>This method creates a command signature.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_COMMAND_SIGNATURE_DESC</c>*</b></para>
		/// <para>Describes the command signature to be created with the <c>D3D12_COMMAND_SIGNATURE_DESC</c> structure.</para>
		/// </param>
		/// <param name="pRootSignature">
		/// <para>Type: <b><c>ID3D12RootSignature</c>*</b></para>
		/// <para>Specifies the <c>ID3D12RootSignature</c> that the command signature applies to.</para>
		/// <para>
		/// The root signature is required if any of the commands in the signature will update bindings on the pipeline. If the only command
		/// present is a draw or dispatch, the root signature parameter can be set to NULL.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the command signature interface ( <c>ID3D12CommandSignature</c>). The
		/// <b>REFIID</b>, or <b>GUID</b>, of the interface to the command signature can be obtained by using the __uuidof() macro. For
		/// example, __uuidof( <b>ID3D12CommandSignature</b>) will get the <b>GUID</b> of the interface to a command signature.
		/// </para>
		/// </param>
		/// <param name="ppvCommandSignature">
		/// <para>Type: <b>void**</b></para>
		/// <para>Specifies a pointer, that on successful completion of the method will point to the created command signature ( <c>ID3D12CommandSignature</c>).</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandsignature HRESULT
		// CreateCommandSignature( [in] const D3D12_COMMAND_SIGNATURE_DESC *pDesc, [in, optional] ID3D12RootSignature *pRootSignature,
		// REFIID riid, [out, optional] void **ppvCommandSignature );
		[PreserveSig]
		new HRESULT CreateCommandSignature(in D3D12_COMMAND_SIGNATURE_DESC pDesc, [In, Optional] ID3D12RootSignature? pRootSignature,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppvCommandSignature);

		/// <summary>Gets info about how a tiled resource is broken into tiles.</summary>
		/// <param name="pTiledResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies a tiled <c>ID3D12Resource</c> to get info about.</para>
		/// </param>
		/// <param name="pNumTilesForEntireResource">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>A pointer to a variable that receives the number of tiles needed to store the entire tiled resource.</para>
		/// </param>
		/// <param name="pPackedMipDesc">
		/// <para>Type: <b><c>D3D12_PACKED_MIP_INFO</c>*</b></para>
		/// <para>
		/// A pointer to a <c>D3D12_PACKED_MIP_INFO</c> structure that <b>GetResourceTiling</b> fills with info about how the tiled
		/// resource's mipmaps are packed.
		/// </para>
		/// </param>
		/// <param name="pStandardTileShapeForNonPackedMips">
		/// <para>Type: <b><c>D3D12_TILE_SHAPE</c>*</b></para>
		/// <para>
		/// Specifies a <c>D3D12_TILE_SHAPE</c> structure that <b>GetResourceTiling</b> fills with info about the tile shape. This is info
		/// about how pixels fit in the tiles, independent of tiled resource's dimensions, not including packed mipmaps. If the entire tiled
		/// resource is packed, this parameter is meaningless because the tiled resource has no defined layout for packed mipmaps. In this
		/// situation, <b>GetResourceTiling</b> sets the members of D3D12_TILE_SHAPE to zeros.
		/// </para>
		/// </param>
		/// <param name="pNumSubresourceTilings">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>
		/// A pointer to a variable that contains the number of tiles in the subresource. On input, this is the number of subresources to
		/// query tilings for; on output, this is the number that was actually retrieved at <i>pSubresourceTilingsForNonPackedMips</i>
		/// (clamped to what's available).
		/// </para>
		/// </param>
		/// <param name="FirstSubresourceTilingToGet">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// The number of the first subresource tile to get. <b>GetResourceTiling</b> ignores this parameter if the number that
		/// <i>pNumSubresourceTilings</i> points to is 0.
		/// </para>
		/// </param>
		/// <param name="pSubresourceTilingsForNonPackedMips">
		/// <para>Type: <b><c>D3D12_SUBRESOURCE_TILING</c>*</b></para>
		/// <para>
		/// Specifies a <c>D3D12_SUBRESOURCE_TILING</c> structure that <b>GetResourceTiling</b> fills with info about subresource tiles. If
		/// subresource tiles are part of packed mipmaps, <b>GetResourceTiling</b> sets the members of D3D12_SUBRESOURCE_TILING to zeros,
		/// except the <i>StartTileIndexInOverallResource</i> member, which <b>GetResourceTiling</b> sets to D3D12_PACKED_TILE (0xffffffff).
		/// The D3D12_PACKED_TILE constant indicates that the whole <b>D3D12_SUBRESOURCE_TILING</b> structure is meaningless for this
		/// situation, and the info that the <i>pPackedMipDesc</i> parameter points to applies.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// To estimate the total resource size of textures needed when calculating heap sizes and calling <c>CreatePlacedResource</c>, use
		/// <c>GetResourceAllocationInfo</c> instead of <b>GetResourceTiling</b>. <b>GetResourceTiling</b> cannot be used for this.
		/// </para>
		/// <para>For more information on tiled resources, refer to <c>Volume Tiled Resources</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getresourcetiling void GetResourceTiling( [in]
		// ID3D12Resource *pTiledResource, [out, optional] UINT *pNumTilesForEntireResource, [out, optional] D3D12_PACKED_MIP_INFO
		// *pPackedMipDesc, [out, optional] D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips, [in, out, optional] UINT
		// *pNumSubresourceTilings, [in] UINT FirstSubresourceTilingToGet, [out] D3D12_SUBRESOURCE_TILING
		// *pSubresourceTilingsForNonPackedMips );
		[PreserveSig]
		new void GetResourceTiling([In] ID3D12Resource pTiledResource, [Out, Optional] StructPointer<uint> pNumTilesForEntireResource,
			[Out, Optional] StructPointer<D3D12_PACKED_MIP_INFO> pPackedMipDesc, [Out, Optional] StructPointer<D3D12_TILE_SHAPE> pStandardTileShapeForNonPackedMips,
			[In, Out, Optional] StructPointer<uint> pNumSubresourceTilings, uint FirstSubresourceTilingToGet,
			[Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] D3D12_SUBRESOURCE_TILING[] pSubresourceTilingsForNonPackedMips);

		/// <summary>Gets a locally unique identifier for the current device (adapter).</summary>
		/// <returns>
		/// <para>Type: <b><c>LUID</c></b></para>
		/// <para>The locally unique identifier for the adapter.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this
		/// identifier to define robust mappings across various APIs (Direct3D 12, DXGI).
		/// </para>
		/// <para>
		/// A locally unique identifier (LUID) is a 64-bit value that is guaranteed to be unique only on the system on which it was
		/// generated. The uniqueness of a locally unique identifier (LUID) is guaranteed only until the system is restarted.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getadapterluid LUID GetAdapterLuid();
		[PreserveSig]
		new LUID GetAdapterLuid();

		/// <summary>
		/// <para>
		/// Creates a cached pipeline library. For pipeline state objects (PSOs) that are expected to share data together, grouping them
		/// into a library before serializing them means that there's less overhead due to metadata, as well as the opportunity to avoid
		/// redundant or duplicated data being written to disk.
		/// </para>
		/// <para>
		/// You can query for <b>ID3D12PipelineLibrary</b> support with <b><c>ID3D12Device::CheckFeatureSupport</c></b>, with
		/// <b><c>D3D12_FEATURE_SHADER_CACHE</c></b> and <b><c>D3D12_FEATURE_DATA_SHADER_CACHE</c></b>. If the Flags member of
		/// <b><c>D3D12_FEATURE_DATA_SHADER_CACHE</c></b> contains the flag <b><c>D3D12_SHADER_CACHE_SUPPORT_LIBRARY</c></b>, the
		/// <b>ID3D12PipelineLibrary</b> interface is supported. If not, then <b>DXGI_ERROR_NOT_SUPPORTED</b> will always be returned when
		/// this function is called.
		/// </para>
		/// </summary>
		/// <param name="pLibraryBlob">
		/// <para>Type: [in] <b>const void*</b></para>
		/// <para>
		/// If the input library blob is empty, then the initial content of the library is empty. If the input library blob is not empty,
		/// then it is validated for integrity, parsed, and the pointer is stored. The pointer provided as input to this method must remain
		/// valid for the lifetime of the object returned. For efficiency reasons, the data is not copied.
		/// </para>
		/// </param>
		/// <param name="BlobLength">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>Specifies the length of pLibraryBlob in bytes.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// Specifies a unique REFIID for the <c>ID3D12PipelineLibrary</c> object. Typically set this and the following parameter with the
		/// macro <c>IID_PPV_ARGS(&amp;Library)</c>, where <b>Library</b> is the name of the object.
		/// </para>
		/// </param>
		/// <param name="ppPipelineLibrary">
		/// <para>Type: [out] <b>void**</b></para>
		/// <para>Returns a pointer to the created library.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>, including
		/// <b>E_INVALIDARG</b> if the blob is corrupted or unrecognized, <b>D3D12_ERROR_DRIVER_VERSION_MISMATCH</b> if the provided data
		/// came from an old driver or runtime, and <b>D3D12_ERROR_ADAPTER_NOT_FOUND</b> if the data came from different hardware.
		/// </para>
		/// <para>
		/// If you pass <c>nullptr</c> for pPipelineLibrary then the runtime still performs the validation of the blob but avoid creating
		/// the actual library and returns S_FALSE if the library would have been created.
		/// </para>
		/// <para>Also, the feature requires an updated driver, and attempting to use it on old drivers will return DXGI_ERROR_UNSUPPORTED.</para>
		/// </returns>
		/// <remarks>
		/// <para>A pipeline library enables the following operations.</para>
		/// <list type="bullet">
		/// <item>
		/// <description>Adding pipeline state objects (PSOs) to an existing library object (refer to <c>StorePipeline</c>).</description>
		/// </item>
		/// <item>
		/// <description>Serializing a PSO library into a contiguous block of memory for disk storage (refer to <c>Serialize</c>).</description>
		/// </item>
		/// <item>
		/// <description>De-serializing a PSO library from persistent storage (this is handled by <b>CreatePipelineLibrary</b>).</description>
		/// </item>
		/// <item>
		/// <description>Retrieving individual PSOs from the library (refer to <c>LoadComputePipeline</c> and <c>LoadGraphicsPipeline</c>).</description>
		/// </item>
		/// </list>
		/// <para>At no point in the lifecycle of a pipeline library is there duplication between PSOs with identical sub-components.</para>
		/// <para>
		/// A recommended solution for managing the lifetime of the provided pointer while only having to ref-count the returned interface
		/// is to leverage <c>ID3D12Object::SetPrivateDataInterface</c>, and use an object which implements <b>IUnknown</b>, and frees the
		/// memory when the ref-count reaches 0.
		/// </para>
		/// <para>Thread Safety</para>
		/// <para>
		/// The pipeline library is thread-safe to use, and will internally synchronize as necessary, with one exception: multiple threads
		/// loading the same PSO (via <c><b>LoadComputePipeline</b></c>, <c><b>LoadGraphicsPipeline</b></c>, or <c><b>LoadPipeline</b></c>)
		/// should synchronize themselves, as this act may modify the state of that pipeline within the library in a non-thread-safe manner.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-createpipelinelibrary HRESULT
		// CreatePipelineLibrary( const void *pLibraryBlob, SIZE_T BlobLength, REFIID riid, void **ppPipelineLibrary );
		[PreserveSig]
		new HRESULT CreatePipelineLibrary([In] IntPtr pLibraryBlob, [In] SizeT BlobLength, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppPipelineLibrary);

		/// <summary>Specifies an event that should be fired when one or more of a collection of fences reach specific values.</summary>
		/// <param name="ppFences">
		/// <para>Type: <b>ID3D12Fence*</b></para>
		/// <para>An array of length <i>NumFences</i> that specifies the <c>ID3D12Fence</c> objects.</para>
		/// </param>
		/// <param name="pFenceValues">
		/// <para>Type: <b>const UINT64*</b></para>
		/// <para>An array of length <i>NumFences</i> that specifies the fence values required for the event is to be signaled.</para>
		/// </param>
		/// <param name="NumFences">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of fences to be included.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_MULTIPLE_FENCE_WAIT_FLAGS</c></b></para>
		/// <para>Specifies one of the <c>D3D12_MULTIPLE_FENCE_WAIT_FLAGS</c> that determines how to proceed.</para>
		/// </param>
		/// <param name="hEvent">
		/// <para>Type: <b>HANDLE</b></para>
		/// <para>A handle to the event object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns an HRESULT success or error code.</para>
		/// </returns>
		/// <remarks>
		/// <para>To specify a single fence refer to the <c>SetEventOnCompletion</c> method.</para>
		/// <para>If hEvent is a null handle, then this API will not return until the specified fence value(s) have been reached.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-seteventonmultiplefencecompletion HRESULT
		// SetEventOnMultipleFenceCompletion( [in] ID3D12Fence * const *ppFences, [in] const UINT64 *pFenceValues, UINT NumFences,
		// D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags, HANDLE hEvent );
		[PreserveSig]
		new HRESULT SetEventOnMultipleFenceCompletion([In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 2)] ID3D12Fence[] ppFences,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[] pFenceValues, int NumFences, D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
			HEVENT hEvent);

		/// <summary>This method sets residency priorities of a specified list of objects.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of objects in the <i>ppObjects</i> and <i>pPriorities</i> arrays.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b>ID3D12Pageable*</b></para>
		/// <para>Specifies an array, of length <i>NumObjects</i>, containing references to <c>ID3D12Pageable</c> objects.</para>
		/// </param>
		/// <param name="pPriorities">
		/// <para>Type: <b>const <c>D3D12_RESIDENCY_PRIORITY</c>*</b></para>
		/// <para>Specifies an array, of length <i>NumObjects</i>, of <c>D3D12_RESIDENCY_PRIORITY</c> values for the list of objects.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns an HRESULT success or error code.</para>
		/// </returns>
		/// <remarks>For more information, refer to <c>Residency</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority HRESULT
		// SetResidencyPriority( UINT NumObjects, [in] ID3D12Pageable * const *ppObjects, [in] const D3D12_RESIDENCY_PRIORITY *pPriorities );
		[PreserveSig]
		new HRESULT SetResidencyPriority(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_RESIDENCY_PRIORITY[] pPriorities);

		/// <summary>Creates a pipeline state object from a pipeline state stream description.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_PIPELINE_STATE_STREAM_DESC</c>*</b></para>
		/// <para>The address of a <c>D3D12_PIPELINE_STATE_STREAM_DESC</c> structure that describes the pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// </para>
		/// <para>The pipeline state object is an immutable state object. It contains no methods.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// This function takes the pipeline description as a <c>D3D12_PIPELINE_STATE_STREAM_DESC</c> and combines the functionality of the
		/// <c>ID3D12Device::CreateGraphicsPipelineState</c> and <c>ID3D12Device::CreateComputePipelineState</c> functions, which take their
		/// pipeline description as the less-flexible <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c> and <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c>
		/// structs, respectively.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device2-createpipelinestate HRESULT CreatePipelineState(
		// const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreatePipelineState(in D3D12_PIPELINE_STATE_STREAM_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>
		/// Creates a special-purpose diagnostic heap in system memory from an address. The created heap can persist even in the event of a
		/// GPU-fault or device-removed scenario.
		/// </summary>
		/// <param name="pAddress">
		/// <para>Type: <b>const void*</b></para>
		/// <para>The address used to create the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the heap interface ( <c>ID3D12Heap</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the heap can be obtained by using the <b>__uuidof()</b> macro. For
		/// example, <b>__uuidof(ID3D12Heap)</b> will retrieve the <b>GUID</b> of the interface to a heap.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block. On success, the D3D12 runtime will write a pointer to the newly-opened heap into the memory block.
		/// The type of the pointer depends on the provided <b>riid</b> parameter.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to open the existing heap. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>The heap is created in system memory and permits CPU access. It wraps the entire VirtualAlloc region.</para>
		/// <para>
		/// Heaps can be used for placed and reserved resources, as orthogonally as other heaps. Restrictions may still exist based on the
		/// flags that cannot be app-chosen.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-openexistingheapfromaddress HRESULT
		// OpenExistingHeapFromAddress( [in] const void *pAddress, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT OpenExistingHeapFromAddress([In] IntPtr pAddress, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>
		/// Creates a special-purpose diagnostic heap in system memory from a file mapping object. The created heap can persist even in the
		/// event of a GPU-fault or device-removed scenario.
		/// </summary>
		/// <param name="hFileMapping">
		/// <para>Type: <b><c>HANDLE</c></b></para>
		/// <para>The handle to the file mapping object to use to create the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the heap interface ( <c>ID3D12Heap</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the heap can be obtained by using the <b>__uuidof()</b> macro. For
		/// example, <b>__uuidof(ID3D12Heap)</b> will retrieve the <b>GUID</b> of the interface to a heap.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block. On success, the D3D12 runtime will write a pointer to the newly-opened heap into the memory block.
		/// The type of the pointer depends on the provided <b>riid</b> parameter.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to open the existing heap. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>The heap is created in system memory, and it permits CPU access. It wraps the entire VirtualAlloc region.</para>
		/// <para>
		/// Heaps can be used for placed and reserved resources, as orthogonally as other heaps. Restrictions may still exist based on the
		/// flags that cannot be app-chosen.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-openexistingheapfromfilemapping HRESULT
		// OpenExistingHeapFromFileMapping( HANDLE hFileMapping, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT OpenExistingHeapFromFileMapping([In] IntPtr hFileMapping, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>Asynchronously makes objects resident for the device.</summary>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_RESIDENCY_FLAGS</c></b></para>
		/// <para>Controls whether the objects should be made resident if the application is over its memory budget.</para>
		/// </param>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to make resident for the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block; contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>descriptor heaps</description>
		/// </item>
		/// <item>
		/// <description>heaps</description>
		/// </item>
		/// <item>
		/// <description>committed resources</description>
		/// </item>
		/// <item>
		/// <description>query heaps</description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pFenceToSignal">
		/// <para>Type: <b><c>ID3D12Fence</c>*</b></para>
		/// <para>A pointer to the fence used to signal when the work is done.</para>
		/// </param>
		/// <param name="FenceValueToSignal">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>An unsigned 64-bit value signaled to the fence when the work is done.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>EnqueueMakeResident</b> performs the same actions as <c>MakeResident</c>, but does not wait for the resources to be made
		/// resident. Instead, <b>EnqueueMakeResident</b> signals a fence when the work is done.
		/// </para>
		/// <para>
		/// The system will not allow work that references the resources that are being made resident by using <b>EnqueueMakeResident</b>
		/// before its fence is signaled. Instead, calls to this API are guaranteed to signal their corresponding fence in order, so the
		/// same fence can be used from call to call.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-enqueuemakeresident HRESULT EnqueueMakeResident(
		// D3D12_RESIDENCY_FLAGS Flags, UINT NumObjects, [in] ID3D12Pageable * const *ppObjects, [in] ID3D12Fence *pFenceToSignal, UINT64
		// FenceValueToSignal );
		[PreserveSig]
		new HRESULT EnqueueMakeResident(D3D12_RESIDENCY_FLAGS Flags, int NumObjects,
			[MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 1)] ID3D12Pageable[] ppObjects,
			[In] ID3D12Fence pFenceToSignal, ulong FenceValueToSignal);

		/// <summary>Creates a command list in the closed state. Also see <c>ID3D12Device::CreateCommandList</c>.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set a bit to identify the node (the device's
		/// physical adapter) for which to create the command list. Each bit in the mask corresponds to a single node. Only one bit must be
		/// set. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>Specifies the type of command list to create.</para>
		/// </param>
		/// <param name="flags">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_FLAGS</c></b></para>
		/// <para>Specifies creation flags.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the command list interface to return in ppCommandList.</para>
		/// </param>
		/// <param name="ppCommandList">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12CommandList</c> or <c>ID3D12GraphicsCommandList</c>
		/// interface for the command list.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the command list.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createcommandlist1 HRESULT CreateCommandList1(
		// [in] UINT nodeMask, [in] D3D12_COMMAND_LIST_TYPE type, D3D12_COMMAND_LIST_FLAGS flags, [in] REFIID riid, [out] void
		// **ppCommandList );
		[PreserveSig]
		new HRESULT CreateCommandList1(uint nodeMask, D3D12_COMMAND_LIST_TYPE type, D3D12_COMMAND_LIST_FLAGS flags, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppCommandList);

		/// <summary>
		/// <para>
		/// Creates an object that represents a session for content protection. You can then provide that session when you're creating
		/// resource or heap objects, to indicate that they should be protected.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>Memory contents can't be transferred from a protected resource to an unprotected resource.</para>
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_PROTECTED_RESOURCE_SESSION_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_PROTECTED_RESOURCE_SESSION_DESC</b> structure, describing the session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the <c>ID3D12ProtectedResourceSession</c> interface.</para>
		/// </param>
		/// <param name="ppSession">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives an <c>ID3D12ProtectedResourceSession</c> interface pointer to the created session object.
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createprotectedresourcesession HRESULT
		// CreateProtectedResourceSession( [in] const D3D12_PROTECTED_RESOURCE_SESSION_DESC *pDesc, [in] REFIID riid, [out] void **ppSession );
		[PreserveSig]
		new HRESULT CreateProtectedResourceSession(in D3D12_PROTECTED_RESOURCE_SESSION_DESC pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppSession);

		/// <summary>
		/// Creates both a resource and an implicit heap (optionally for a protected session), such that the heap is big enough to contain
		/// the entire resource, and the resource is mapped to the heap. Also see <c>ID3D12Device::CreateCommittedResource</c> for a code example.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createcommittedresource1 HRESULT
		// CreateCommittedResource1( [in] const D3D12_HEAP_PROPERTIES *pHeapProperties, [in] D3D12_HEAP_FLAGS HeapFlags, [in] const
		// D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialResourceState, [in, optional] const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riidResource, [out,
		// optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource1(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 6)] out object? ppvResource);

		/// <summary>
		/// Creates a heap (optionally for a protected session) that can be used with placed resources and reserved resources. Also see <c>ID3D12Device::CreateHeap</c>.
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_HEAP_DESC</b> structure that describes the heap.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// heap should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// <para>A heap with a protected session can't be created with the <c>D3D12_HEAP_FLAG_SHARED_CROSS_ADAPTER</c> flag.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the heap interface to return in ppvHeap.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Heap</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created heap object.</para>
		/// <para>
		/// <paramref name="ppvHeap"/> can be <c>nullptr</c>, to enable capability testing. When ppvHeap is <c>nullptr</c>, no object is
		/// created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the heap.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para><b>CreateHeap1</b> creates a heap that can be used with placed resources and reserved resources.</para>
		/// <para>
		/// Before releasing the final reference on the heap, your application must ensure that the GPU will no longer read or write to this heap.
		/// </para>
		/// <para>
		/// A placed resource object holds a reference on the heap it is created on; but a reserved resource doesn't hold a reference for
		/// each mapping made to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createheap1 HRESULT CreateHeap1( [in] const
		// D3D12_HEAP_DESC *pDesc, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riid, [out, optional] void
		// **ppvHeap );
		[PreserveSig]
		new HRESULT CreateHeap1(in D3D12_HEAP_DESC pDesc, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppvHeap);

		/// <summary>
		/// <para>
		/// Creates a resource (optionally for a protected session) that is reserved, and not yet mapped to any pages in a heap. Also see <c>ID3D12Device::CreateReservedResource</c>.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>Only tiles from heaps created with the same protected resource session can be mapped into a protected reserved resource.</para>
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/>&gt; specifies a value for which clear operations are most optimal. When the created
		/// resource is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or
		/// <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b> flags, you should choose the value with which the clear operation will most
		/// commonly be called. You can call the clear operation with other values, but those operations won't be as efficient as when the
		/// value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreateReservedResource</b> is equivalent to <c>D3D11_RESOURCE_MISC_TILED</c> in Direct3D 11. It creates a resource with
		/// virtual memory only, no backing store.
		/// </para>
		/// <para>You need to map the resource to physical memory (that is, to a heap) using <c>CopyTileMappings</c> and <c>UpdateTileMappings</c>.</para>
		/// <para>
		/// These resource types can only be created when the adapter supports tiled resource tier 1 or greater. The tiled resource tier
		/// defines the behavior of accessing a resource that is not mapped to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createreservedresource1 HRESULT
		// CreateReservedResource1( [in] const D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialState, [in, optional] const
		// D3D12_CLEAR_VALUE *pOptimizedClearValue, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riid,
		// [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource1(in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Gets rich info about the size and alignment of memory required for a collection of resources on this adapter. Also see <c>ID3D12Device::GetResourceAllocationInfo</c>.
		/// </para>
		/// <para>
		/// In addition to the <c>D3D12_RESOURCE_ALLOCATION_INFO</c> returned from the method, this version also returns an array of
		/// <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, which provide additional details for each resource description passed as
		/// input. See the pResourceAllocationInfo1 parameter.
		/// </para>
		/// </summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array. This is also the size (the number of elements in) pResourceAllocationInfo1.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <param name="pResourceAllocationInfo1">
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO1</c>*</b></para>
		/// <para>
		/// An array of <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, containing additional details for each resource description
		/// passed as input. This makes it simpler for your application to allocate a heap for multiple resources, and without manually
		/// computing offsets for where each resource should be placed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When you're using <c>CreatePlacedResource</c>, your application must use <b>GetResourceAllocationInfo</b> in order to understand
		/// the size and alignment characteristics of texture resources. The results of this method vary depending on the particular
		/// adapter, and must be treated as unique to this adapter and driver version.
		/// </para>
		/// <para>
		/// Your application can't use the output of <b>GetResourceAllocationInfo</b> to understand packed mip properties of textures. To
		/// understand packed mip properties of textures, your application must use <c>GetResourceTiling</c>.
		/// </para>
		/// <para>
		/// Texture resource sizes significantly differ from the information returned by <b>GetResourceTiling</b>, because some adapter
		/// architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios. This even
		/// includes textures that have constraints on their texture layouts, or have standardized texture layouts. That extra memory can't
		/// be sparsely mapped nor remapped by an application using <c>CreateReservedResource</c> and <c>UpdateTileMappings</c>, so it isn't
		/// reported by <b>GetResourceTiling</b>.
		/// </para>
		/// <para>
		/// Your application can forgo using <b>GetResourceAllocationInfo</b> for buffer resources (
		/// <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>). Buffers have the same size on all adapters, which is merely the smallest multiple of
		/// 64KB that's greater or equal to <c>D3D12_RESOURCE_DESC::Width</c>.
		/// </para>
		/// <para>
		/// When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used.
		/// For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource, reports differing sizes
		/// based on the order of the array. If the 4MB aligned resource is in the middle, then the resulting <b>Size</b> is 12MB.
		/// Otherwise, the resulting <b>Size</b> is 8MB. The <b>Alignment</b> returned would always be 4MB, because it's the superset of all
		/// alignments in the resource array.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-getresourceallocationinfo1(uint_uint_constd3d12_resource_desc_d3d12_resource_allocation_info1)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo1( [in] UINT visibleMask, [in] UINT numResourceDescs, [in] const
		// D3D12_RESOURCE_DESC *pResourceDescs, [out] D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1 );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo1(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC[] pResourceDescs,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[]? pResourceAllocationInfo1);

		/// <summary>
		/// Creates a lifetime tracker associated with an application-defined callback; the callback receives notifications when the
		/// lifetime of a tracked object is changed.
		/// </summary>
		/// <param name="pOwner">
		/// <para>Type: <b><c>ID3D12LifetimeOwner</c>*</b></para>
		/// <para>A pointer to an <b>ID3D12LifetimeOwner</b> interface representing the application-defined callback.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the interface identifier (IID) of the interface to return in ppvTracker.</para>
		/// </param>
		/// <param name="ppvTracker">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives the requested interface pointer to the created object.</para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createlifetimetracker HRESULT
		// CreateLifetimeTracker( [in] ID3D12LifetimeOwner *pOwner, [in] REFIID riid, [out] void **ppvTracker );
		[PreserveSig]
		new HRESULT CreateLifetimeTracker([In] ID3D12LifetimeOwner pOwner, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvTracker);

		/// <summary>
		/// You can call <b>RemoveDevice</b> to indicate to the Direct3D 12 runtime that the GPU device encountered a problem, and can no
		/// longer be used. Doing so will cause all devices' monitored fences to be signaled. Your application typically doesn't need to
		/// explicitly call <b>RemoveDevice</b>.
		/// </summary>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Because device removal triggers all fences to be signaled to <c>UINT64_MAX</c>, you can create a callback for device removal
		/// using an event.
		/// </para>
		/// <para>
		/// <c>HANDLE deviceRemovedEvent = CreateEventW(NULL, FALSE, FALSE, NULL); assert(deviceRemovedEvent != NULL);
		/// _deviceFence-&gt;SetEventOnCompletion(UINT64_MAX, deviceRemoved); HANDLE waitHandle; RegisterWaitForSingleObject(
		/// &amp;waitHandle, deviceRemovedEvent, OnDeviceRemoved, _device.Get(), // Pass the device as our context INFINITE, // No timeout 0
		/// // No flags ); void OnDeviceRemoved(PVOID context, BOOLEAN) { ID3D12Device* removedDevice = (ID3D12Device*)context; HRESULT
		/// removedReason = removedDevice-&gt;GetDeviceRemovedReason(); // Perform app-specific device removed operation, such as logging or
		/// inspecting DRED output }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-removedevice void RemoveDevice();
		[PreserveSig]
		new void RemoveDevice();

		/// <summary>Queries reflection metadata about available meta commands.</summary>
		/// <param name="pNumMetaCommands">
		/// <para>Type: [in, out] <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a <c>UINT</c> containing the number of meta commands to query for. This field determines the size of the
		/// <i>pDescs</i> array, unless <i>pDescs</i> is <b>nullptr</b>.
		/// </para>
		/// </param>
		/// <param name="pDescs">
		/// <para>Type: [out, optional] <b><c>D3D12_META_COMMAND_DESC</c>*</b></para>
		/// <para>
		/// An optional pointer to an array of <c>D3D12_META_COMMAND_DESC</c> containing the descriptions of the available meta commands.
		/// Pass <c>nullptr</c> to have the number of available meta commands returned in <i>pNumMetaCommands</i>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-enumeratemetacommands HRESULT
		// EnumerateMetaCommands( UINT *pNumMetaCommands, D3D12_META_COMMAND_DESC *pDescs );
		[PreserveSig]
		new HRESULT EnumerateMetaCommands(ref int pNumMetaCommands, [Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_META_COMMAND_DESC[]? pDescs);

		/// <summary>Queries reflection metadata about the parameters of the specified meta command.</summary>
		/// <param name="CommandId">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier (GUID) of the meta command whose parameters you wish to be returned in <i>pParameterDescs</i>.</para>
		/// </param>
		/// <param name="Stage">
		/// <para>Type: <b>D3D12_META_COMMAND_PARAMETER_STAGE</b></para>
		/// <para>
		/// A <c>D3D12_META_COMMAND_PARAMETER_STAGE</c> specifying the stage of the parameters that you wish to be included in the query.
		/// </para>
		/// </param>
		/// <param name="pTotalStructureSizeInBytes">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// An optional pointer to a <c>UINT</c> containing the size of the structure containing the parameter values, which you pass when
		/// creating/initializing/executing the meta command, as appropriate.
		/// </para>
		/// </param>
		/// <param name="pParameterCount">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a <c>UINT</c> containing the number of parameters to query for. This field determines the size of the
		/// <i>pParameterDescs</i> array, unless <i>pParameterDescs</i> is <b>nullptr</b>.
		/// </para>
		/// </param>
		/// <param name="pParameterDescs">
		/// <para>Type: <b>D3D12_META_COMMAND_PARAMETER_DESC*</b></para>
		/// <para>
		/// An optional pointer to an array of <c>D3D12_META_COMMAND_PARAMETER_DESC</c> containing the descriptions of the parameters. Pass
		/// <b>nullptr</b> to have the parameter count returned in <i>pParameterCount</i>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HRESULT</b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-enumeratemetacommandparameters HRESULT
		// EnumerateMetaCommandParameters( [in] REFGUID CommandId, [in] D3D12_META_COMMAND_PARAMETER_STAGE Stage, [out, optional] UINT
		// *pTotalStructureSizeInBytes, [in, out] UINT *pParameterCount, [out, optional] D3D12_META_COMMAND_PARAMETER_DESC *pParameterDescs );
		[PreserveSig]
		new HRESULT EnumerateMetaCommandParameters(in Guid CommandId, D3D12_META_COMMAND_PARAMETER_STAGE Stage, out uint pTotalStructureSizeInBytes,
			ref int pParameterCount, [Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] D3D12_META_COMMAND_PARAMETER_DESC[]? pParameterDescs);

		/// <summary>Creates an instance of the specified meta command.</summary>
		/// <param name="CommandId">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier (GUID) of the meta command that you wish to instantiate.</para>
		/// </param>
		/// <param name="NodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-adapter operation, set this to zero. If there are multiple adapter nodes, set a bit to identify the node (one of the
		/// device's physical adapters) to which the meta command applies. Each bit in the mask corresponds to a single node. Only one bit
		/// must be set. See <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="pCreationParametersData">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>An optional pointer to a constant structure containing the values of the parameters for creating the meta command.</para>
		/// </param>
		/// <param name="CreationParametersDataSizeInBytes">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>A <c>SIZE_T</c> containing the size of the structure pointed to by <i>pCreationParametersData</i>, if set, otherwise 0.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// A reference to the globally unique identifier (GUID) of the interface that you wish to be returned in <i>ppMetaCommand</i>. This
		/// is expected to be the GUID of <c>ID3D12MetaCommand</c>.
		/// </para>
		/// </param>
		/// <param name="ppMetaCommand">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the meta command. This is the address of a pointer to an
		/// <c>ID3D12MetaCommand</c>, representing the meta command created.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HRESULT</b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>DXGI_ERROR_UNSUPPORTED</description>
		/// <description>The current hardware does not support the algorithm being requested</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createmetacommand HRESULT CreateMetaCommand(
		// [in] REFGUID CommandId, [in] UINT NodeMask, [in, optional] const void *pCreationParametersData, [in] SIZE_T
		// CreationParametersDataSizeInBytes, REFIID riid, [out] void **ppMetaCommand );
		[PreserveSig]
		new HRESULT CreateMetaCommand(in Guid CommandId, uint NodeMask, [In, Optional] IntPtr pCreationParametersData, [In] SizeT CreationParametersDataSizeInBytes,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppMetaCommand);

		/// <summary>Creates an <c>ID3D12StateObject</c>.</summary>
		/// <param name="pDesc">The description of the state object to create.</param>
		/// <param name="riid">The GUID of the interface to create. Use <i>__uuidof(ID3D12StateObject)</i>.</param>
		/// <param name="ppStateObject">The returned state object.</param>
		/// <returns>
		/// <para>Returns S_OK if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>E_INVALIDARG if one of the input parameters is invalid.</description>
		/// </item>
		/// <item>
		/// <description>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</description>
		/// </item>
		/// <item>
		/// <description>Possibly other error codes that are described in the <c>Direct3D 12 Return Codes</c> topic.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createstateobject HRESULT CreateStateObject(
		// [in] const D3D12_STATE_OBJECT_DESC *pDesc, REFIID riid, [out] void **ppStateObject );
		[PreserveSig]
		new HRESULT CreateStateObject(in D3D12_STATE_OBJECT_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppStateObject);

		/// <summary>Query the driver for resource requirements to build an acceleration structure.</summary>
		/// <param name="pDesc">
		/// <para>
		/// Description of the acceleration structure build. This structure is shared with <c>BuildRaytracingAccelerationStructure</c>. For
		/// more information, see <c>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS</c>.
		/// </para>
		/// <para>
		/// The implementation is allowed to look at all the CPU parameters in this struct and nested structs. It may not
		/// inspect/dereference any GPU virtual addresses, other than to check to see if a pointer is NULL or not, such as the optional
		/// transform in <c>D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC</c>, without dereferencing it. In other words, the calculation of
		/// resource requirements for the acceleration structure does not depend on the actual geometry data (such as vertex positions),
		/// rather it can only depend on overall properties, such as the number of triangles, number of instances etc.
		/// </para>
		/// </param>
		/// <param name="pInfo">The result of the query (in a <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO</c> structure).</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The input acceleration structure description is the same as what goes into <c>BuildRaytracingAccelerationStructure</c>. The
		/// result of this function lets the application provide the correct amount of output storage and scratch storage to
		/// <b>BuildRaytracingAccelerationStructure</b> given the same geometry.
		/// </para>
		/// <para>
		/// Builds can also be done with the same configuration passed to <b>GetAccelerationStructurePrebuildInfo</b> overall except equal
		/// or smaller counts for the number of geometries/instances or the number of vertices/indices/AABBs in any given geometry. In this
		/// case the storage requirements reported with the original sizes passed to <b>GetRaytracingAccelerationStructurePrebuildInfo</b>
		/// will be valid  the build may actually consume less space but not more. This is handy for app scenarios where having
		/// conservatively large storage allocated for acceleration structures is fine.
		/// </para>
		/// <para>
		/// This method is on the device interface as opposed to command list on the assumption that drivers must be able to calculate
		/// resource requirements for an acceleration structure build from only looking at the CPU-visible portions of the call, without
		/// having to dereference any pointers to GPU memory containing actual vertex data, index data, etc.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-getraytracingaccelerationstructureprebuildinfo
		// void GetRaytracingAccelerationStructurePrebuildInfo( [in] const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS *pDesc,
		// [out] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO *pInfo );
		[PreserveSig]
		new void GetRaytracingAccelerationStructurePrebuildInfo(in D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS pDesc, out D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO pInfo);

		/// <summary>
		/// Reports the compatibility of serialized data, such as a serialized raytracing acceleration structure resulting from a call to
		/// <c>CopyRaytracingAccelerationStructure</c> with mode <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_SERIALIZE</c>, with
		/// the current device/driver.
		/// </summary>
		/// <param name="SerializedDataType">The type of the serialized data. For more information, see <c>D3D12_SERIALIZED_DATA_TYPE</c>.</param>
		/// <param name="pIdentifierToCheck">
		/// Identifier from the header of the serialized data to check with the driver. For more information, see <c>D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER</c>.
		/// </param>
		/// <returns>The returned compatibility status. For more information, see <c>D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS</c>.</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-checkdrivermatchingidentifier
		// D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS CheckDriverMatchingIdentifier( [in] D3D12_SERIALIZED_DATA_TYPE SerializedDataType, [in]
		// const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER *pIdentifierToCheck );
		[PreserveSig]
		new D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS CheckDriverMatchingIdentifier(D3D12_SERIALIZED_DATA_TYPE SerializedDataType,
			in D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER pIdentifierToCheck);

		/// <summary>Sets the mode for driver background processing optimizations.</summary>
		/// <param name="Mode">
		/// <para>Type: <b><c>D3D12_BACKGROUND_PROCESSING_MODE</c></b></para>
		/// <para>The level of dynamic optimization to apply to GPU work that's subsequently submitted.</para>
		/// </param>
		/// <param name="MeasurementsAction">
		/// <para>Type: <b><c>D3D12_MEASUREMENTS_ACTION</c></b></para>
		/// <para>The action to take with the results of earlier workload instrumentation.</para>
		/// </param>
		/// <param name="hEventToSignalUponCompletion">
		/// <para>Type: <b><c>HANDLE</c></b></para>
		/// <para>
		/// An optional handle to signal when the function is complete. For example, if MeasurementsAction is set to
		/// <c>D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS</c>, then hEventToSignalUponCompletion is signaled when all resulting compilations
		/// have finished.
		/// </para>
		/// </param>
		/// <param name="pbFurtherMeasurementsDesired">
		/// <para>Type: <b><c>BOOL</c>*</b></para>
		/// <para>
		/// An optional pointer to a Boolean value. The function sets the value to <c>true</c> to indicate that you should continue
		/// profiling, otherwise, <c>false</c>.
		/// </para>
		/// </param>
		/// <remarks>
		/// <para>
		/// A graphics driver can use idle-priority background CPU threads to dynamically recompile shader programs. That can improve GPU
		/// performance by specializing shader code to better match details of the hardware that it's running on, and/or the context in
		/// which it's being used.
		/// </para>
		/// <para>
		/// As a developer, you don't have to do anything to benefit from this feature (over time, as drivers adopt background processing
		/// optimizations, existing shaders will automatically be tuned more efficiently). But, when you're profiling your code, you'll
		/// probably want to call <b>SetBackgroundProcessingMode</b> to make sure that any driver background processing optimizations have
		/// taken place before you take timing measurements. Here's an example.
		/// </para>
		/// <para>
		/// <c>SetBackgroundProcessingMode( D3D12_BACKGROUND_PROCESSING_MODE_ALLOW_INTRUSIVE_MEASUREMENTS, D3D_MEASUREMENTS_ACTION_KEEP_ALL,
		/// nullptr, nullptr); // Here, prime the system by rendering some typical content. // For example, a level flythrough.
		/// SetBackgroundProcessingMode( D3D12_BACKGROUND_PROCESSING_MODE_ALLOWED, D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS, nullptr,
		/// nullptr); // Here, continue rendering. This time with dynamic optimizations applied. // And then take your measurements.</c>
		/// </para>
		/// <para>
		/// <c>PIX</c> automatically uses <b>SetBackgroundProcessingMode</b>first to prime the system,and then to prevent any further
		/// changes from taking place in the middle of its analysis. PIX waits on an event (to make sure all background shader recompiles
		/// have finished) before it starts taking measurements.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device6-setbackgroundprocessingmode HRESULT
		// SetBackgroundProcessingMode( [in] D3D12_BACKGROUND_PROCESSING_MODE Mode, [in] D3D12_MEASUREMENTS_ACTION MeasurementsAction, [in]
		// HANDLE hEventToSignalUponCompletion, [out] BOOL *pbFurtherMeasurementsDesired );
		[PreserveSig]
		new HRESULT SetBackgroundProcessingMode(D3D12_BACKGROUND_PROCESSING_MODE Mode, D3D12_MEASUREMENTS_ACTION MeasurementsAction,
			[In] HEVENT hEventToSignalUponCompletion, out bool pbFurtherMeasurementsDesired);

		/// <summary>
		/// Incrementally add to an existing state object. This incurs lower CPU overhead than creating a state object from scratch that is
		/// a superset of an existing one (for example, adding a few more shaders).
		/// </summary>
		/// <param name="pAddition">
		/// <para>Type: _In_ <b>const <c>D3D12_STATE_OBJECT_DESC</c>*</b></para>
		/// <para>
		/// Description of state object contents to add to existing state object. To help generate this see the
		/// <b>CD3D12_STATE_OBJECT_DESC</b> helper in class in <c>d3dx12.h</c>.
		/// </para>
		/// </param>
		/// <param name="pStateObjectToGrowFrom">
		/// <para>Type: _In_ <b><c>ID3D12StateObject</c>*</b></para>
		/// <para>Existing state object, which can be in use (for example, active raytracing) during this operation.</para>
		/// <para>The existing state object must not be of type <b>Collection</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: _In_ <b>REFIID</b></para>
		/// <para>Must be the IID of the <c>ID3D12StateObject</c> interface.</para>
		/// </param>
		/// <param name="ppNewStateObject">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>Returned state object.</para>
		/// <para>
		/// Behavior is undefined if shader identifiers are retrieved for new shaders from this call and they are accessed via shader tables
		/// by any already existing or in-flight command list that references some older state object. Use of the new shaders added to the
		/// state object can occur only from commands (such as <b>DispatchRays</b> or <b>ExecuteIndirect</b> calls) recorded in a command
		/// list after the call to <b>AddToStateObject</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <b>S_OK</b> for success. <b>E_INVALIDARG</b>, <b>E_OUTOFMEMORY</b> on failure. The debug layer provides detailed status information.
		/// </returns>
		/// <remarks>For more info, see <c>AddToStateObject</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device7-addtostateobject HRESULT AddToStateObject( const
		// D3D12_STATE_OBJECT_DESC *pAddition, ID3D12StateObject *pStateObjectToGrowFrom, REFIID riid, void **ppNewStateObject );
		[PreserveSig]
		new HRESULT AddToStateObject(in D3D12_STATE_OBJECT_DESC pAddition, [In] ID3D12StateObject pStateObjectToGrowFrom, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppNewStateObject);

		/// <summary>
		/// <para>
		/// <b>CreateProtectedResourceSession1</b> revises the <c><b>ID3D12Device4::CreateProtectedResourceSession</b></c> method with
		/// provision (in the structure passed via the pDesc parameter) for a globally unique identifier ( <b>GUID</b>) that indicates the
		/// type of protected resource session.
		/// </para>
		/// <para>
		/// Calling <b>ID3D12Device4::CreateProtectedResourceSession</b> is equivalent to calling
		/// <b>ID3D12Device7::CreateProtectedResourceSession1</b> with the <b>D3D12_PROTECTED_RESOURCES_SESSION_HARDWARE_PROTECTED</b> GUID.
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_PROTECTED_RESOURCE_SESSION_DESC1</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_PROTECTED_RESOURCE_SESSION_DESC1</b> structure, describing the session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: _In_ <b>REFIID</b></para>
		/// <para>
		/// The GUID of the interface to a protected session. Most commonly, <c>ID3D12ProtectedResourceSession1</c>, although it may be any
		/// <b>GUID</b> for any interface. If the protected session object doesn't support the interface for this <b>GUID</b>, the getter
		/// will return <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppSession">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the session for the given protected session (the specific interface type
		/// returned depends on riid).
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device7-createprotectedresourcesession1 HRESULT
		// CreateProtectedResourceSession1( const D3D12_PROTECTED_RESOURCE_SESSION_DESC1 *pDesc, REFIID riid, void **ppSession );
		[PreserveSig]
		new HRESULT CreateProtectedResourceSession1(in D3D12_PROTECTED_RESOURCE_SESSION_DESC1 pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppSession);

		/// <summary>
		/// <para>
		/// Gets rich info about the size and alignment of memory required for a collection of resources on this adapter. Also see <c>ID3D12Device4::GetResourceAllocationInfo1</c>.
		/// </para>
		/// <para>This version also returns an array of <c>D3D12_RESOURCE_DESC1</c> structures.</para>
		/// </summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array. This is also the size (the number of elements in) pResourceAllocationInfo1.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC1</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <param name="pResourceAllocationInfo1">
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO1</c>*</b></para>
		/// <para>
		/// An array of <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, containing additional details for each resource description
		/// passed as input. This makes it simpler for your application to allocate a heap for multiple resources, and without manually
		/// computing offsets for where each resource should be placed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// </returns>
		/// <remarks>For remarks, see <c>ID3D12Device4::GetResourceAllocationInfo1</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-getresourceallocationinfo2(uint_uint_constd3d12_resource_desc1_d3d12_resource_allocation_info1)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo2( UINT visibleMask, UINT numResourceDescs, const D3D12_RESOURCE_DESC1
		// *pResourceDescs, D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1 );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo2(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC1[] pResourceDescs,
			[Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[] pResourceAllocationInfo1);

		/// <summary>
		/// Creates both a resource and an implicit heap (optionally for a protected session), such that the heap is big enough to contain
		/// the entire resource, and the resource is mapped to the heap. Also see <c>ID3D12Device::CreateCommittedResource</c> for a code example.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: _In_ <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createcommittedresource2 HRESULT
		// CreateCommittedResource2( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC1
		// *pDesc, D3D12_RESOURCE_STATES InitialResourceState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, ID3D12ProtectedResourceSession
		// *pProtectedSession, REFIID riidResource, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource2(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC1 pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 6)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC1</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>
		/// When a resource is created together with a <b>D3D12_HEAP_TYPE_UPLOAD</b> heap, InitialState must be
		/// <b>D3D12_RESOURCE_STATE_GENERIC_READ</b>. When a resource is created together with a <b>D3D12_HEAP_TYPE_READBACK</b> heap,
		/// InitialState must be <b>D3D12_RESOURCE_STATE_COPY_DEST</b>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>See <c>ID3D12Device::CreatePlacedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createplacedresource1 HRESULT
		// CreatePlacedResource1( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC1 *pDesc, D3D12_RESOURCE_STATES
		// InitialState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource1([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC1 pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>For purposes of sampler feedback, creates a descriptor suitable for binding.</summary>
		/// <param name="pTargetedResource">
		/// <para>Type: _In_opt_ <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The targeted resource, such as a texture, to create a descriptor for.</para>
		/// </param>
		/// <param name="pFeedbackResource">
		/// <para>Type: _In_opt_ <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The feedback resource, such as a texture, to create a descriptor for.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: _In_ <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>The CPU descriptor handle.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createsamplerfeedbackunorderedaccessview void
		// CreateSamplerFeedbackUnorderedAccessView( ID3D12Resource *pTargetedResource, ID3D12Resource *pFeedbackResource,
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateSamplerFeedbackUnorderedAccessView([In, Optional] ID3D12Resource? pTargetedResource, [In, Optional] ID3D12Resource? pFeedbackResource,
			D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>
		/// Gets a resource layout that can be copied. Helps your app fill in <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> when suballocating space in upload heaps.
		/// </summary>
		/// <param name="pResourceDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A description of the resource, as a pointer to a <b>D3D12_RESOURCE_DESC1</b> structure.</para>
		/// </param>
		/// <param name="FirstSubresource">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>Index of the first subresource in the resource. The range of valid values is 0 to D3D12_REQ_SUBRESOURCES.</para>
		/// </param>
		/// <param name="NumSubresources">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The number of subresources in the resource. The range of valid values is 0 to (D3D12_REQ_SUBRESOURCES - <i>FirstSubresource</i>).</para>
		/// </param>
		/// <param name="BaseOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset, in bytes, to the resource.</para>
		/// </param>
		/// <param name="pLayouts">
		/// <para>Type: [out, optional] <b><c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c>*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> structures, to be filled
		/// with the description and placement of each subresource.
		/// </para>
		/// </param>
		/// <param name="pNumRows">
		/// <para>Type: [out, optional] <b>UINT*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, to be filled with the number of rows for each subresource.
		/// </para>
		/// </param>
		/// <param name="pRowSizeInBytes">
		/// <para>Type: [out, optional] <b>UINT64*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, each entry to be filled with the unpadded size in
		/// bytes of a row, of each subresource.
		/// </para>
		/// <para>For example, if a Texture2D resource has a width of 32 and bytes per pixel of 4, then <i>pRowSizeInBytes</i> returns 128.</para>
		/// <para>
		/// <i>pRowSizeInBytes</i> should not be confused with <b>row pitch</b>, as examining <i>pLayouts</i> and getting the row pitch from
		/// that will give you 256 as it is aligned to D3D12_TEXTURE_DATA_PITCH_ALIGNMENT.
		/// </para>
		/// </param>
		/// <param name="pTotalBytes">
		/// <para>Type: [out, optional] <b>UINT64*</b></para>
		/// <para>A pointer to an integer variable, to be filled with the total size, in bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>For remarks and examples, see <c>ID3D12Device::GetCopyableFootprints</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-getcopyablefootprints1 void
		// GetCopyableFootprints1( const D3D12_RESOURCE_DESC1 *pResourceDesc, UINT FirstSubresource, UINT NumSubresources, UINT64
		// BaseOffset, D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts, UINT *pNumRows, UINT64 *pRowSizeInBytes, UINT64 *pTotalBytes );
		[PreserveSig]
		new void GetCopyableFootprints1(in D3D12_RESOURCE_DESC1 pResourceDesc, uint FirstSubresource, int NumSubresources, ulong BaseOffset,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_PLACED_SUBRESOURCE_FOOTPRINT[]? pLayouts,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[]? pNumRows,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[]? pRowSizeInBytes, out ulong pTotalBytes);

		/// <summary>
		/// Creates an object that grants access to a shader cache, potentially opening an existing cache or creating a new one.
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_SHADER_CACHE_SESSION_DESC</c>*</b></para>
		/// <para>A <b>D3D12_SHADER_CACHE_SESSION_DESC</b> structure describing the shader cache session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>The globally unique identifier (GUID) for the shader cache session interface.</para>
		/// </param>
		/// <param name="ppvSession">
		/// <para>Type: _COM_Outptr_opt_ <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12ShaderCacheSession</c> interface for the shader cache session.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>DXGI_ERROR_ALREADY_EXISTS</description>
		/// <description>You tried to create a cache with an existing identifier. See <c>D3D12_SHADER_CACHE_SESSION_DESC::Identifier</c>.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-createshadercachesession HRESULT
		// CreateShaderCacheSession( const D3D12_SHADER_CACHE_SESSION_DESC *pDesc, REFIID riid, void **ppvSession );
		[PreserveSig]
		new HRESULT CreateShaderCacheSession(in D3D12_SHADER_CACHE_SESSION_DESC pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvSession);

		/// <summary>
		/// Modifies the behavior of caches used internally by Direct3D or by the driver. <b>ShaderCacheControl</b> may be used only in
		/// developer mode.
		/// </summary>
		/// <param name="Kinds">
		/// <para>Type: <b><c>D3D12_SHADER_CACHE_KIND_FLAGS</c></b></para>
		/// <para>The caches to modify. Any one of these caches may or may not exist.</para>
		/// </param>
		/// <param name="Control">
		/// <para>Type: <b><c>D3D12_SHADER_CACHE_CONTROL_FLAGS</c></b></para>
		/// <para>
		/// The way in which to modify the caches. You can't pass both <b>DISABLE</b> and <b>ENABLE</b> at the same time; and you must pass
		/// at least one flag.
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-shadercachecontrol HRESULT ShaderCacheControl(
		// D3D12_SHADER_CACHE_KIND_FLAGS Kinds, D3D12_SHADER_CACHE_CONTROL_FLAGS Control );
		[PreserveSig]
		new HRESULT ShaderCacheControl(D3D12_SHADER_CACHE_KIND_FLAGS Kinds, D3D12_SHADER_CACHE_CONTROL_FLAGS Control);

		/// <summary>
		/// <para>Creates a command queue with a creator ID.</para>
		/// <para>Also see <c>ID3D12Device::CreateCommandQueue</c>.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_COMMAND_QUEUE_DESC</c>*</b></para>
		/// <para>Specifies a <b>D3D12_COMMAND_QUEUE_DESC</b> that describes the command queue.</para>
		/// </param>
		/// <param name="CreatorID">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>A creator ID. See <b>Remarks</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>The globally unique identifier (GUID) for the command queue interface.</para>
		/// </param>
		/// <param name="ppCommandQueue">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandQueue</c> interface for the command queue.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// Returns <b>E_OUTOFMEMORY</b> if there's insufficient memory to create the command queue; otherwise <b>S_OK</b>. See <c>Direct3D
		/// 12 return codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When multiple components in the same process are sharing a single Direct3D 12 device, often they will end up with separate
		/// workloads on independent command queues. In some hardware implementations, independent queues can run in parallel only with
		/// specific other command queues.
		/// </para>
		/// <para>
		/// Direct3D 12 applies a first-come, first-serve grouping for queues, which might not work well for all application or component
		/// designs. To help inform Direct3D 12's grouping of queues, you can specify a creator ID (which is unique per component) that
		/// restricts the grouping to other queues with the same ID. When possible, a component should choose the same unique ID for all of
		/// its queues. Microsoft has reserved a few well-known creator IDs for use by Microsoft-developed implementations of APIs on top of
		/// Direct3D 12.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-createcommandqueue1 HRESULT CreateCommandQueue1(
		// const D3D12_COMMAND_QUEUE_DESC *pDesc, REFIID CreatorID, REFIID riid, void **ppCommandQueue );
		[PreserveSig]
		new HRESULT CreateCommandQueue1(in D3D12_COMMAND_QUEUE_DESC pDesc, in Guid CreatorID, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppCommandQueue);

		/// <summary>
		/// <para>Creates a committed resource with an initial layout rather than an initial state.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: _In_ <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createcommittedresource3 HRESULT
		// CreateCommittedResource3( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC1
		// *pDesc, D3D12_BARRIER_LAYOUT InitialLayout, const D3D12_CLEAR_VALUE *pOptimizedClearValue, ID3D12ProtectedResourceSession
		// *pProtectedSession, UINT32 NumCastableFormats, const DXGI_FORMAT *pCastableFormats, REFIID riidResource, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource3(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC1 pDesc,
			D3D12_BARRIER_LAYOUT InitialLayout, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, int NumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 6)] DXGI_FORMAT[]? pCastableFormats, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 8)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>See <b>Remarks</b> for <c>ID3D12Device::CreatePlacedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createplacedresource2 HRESULT
		// CreatePlacedResource2( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC1 *pDesc, D3D12_BARRIER_LAYOUT
		// InitialLayout, const D3D12_CLEAR_VALUE *pOptimizedClearValue, UINT32 NumCastableFormats, const DXGI_FORMAT *pCastableFormats,
		// REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource2([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC1 pDesc, D3D12_BARRIER_LAYOUT InitialLayout,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, int NumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 5)] DXGI_FORMAT[] pCastableFormats, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 7)] out object? ppvResource);

		/// <summary>
		/// <para>Creates a resource that is reserved, and not yet mapped to any pages in a heap.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>See <b>Remarks</b> for <c>ID3D12Device.CreateReservedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createreservedresource2 HRESULT
		// CreateReservedResource2( const D3D12_RESOURCE_DESC *pDesc, D3D12_BARRIER_LAYOUT InitialLayout, const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, ID3D12ProtectedResourceSession *pProtectedSession, UINT32 NumCastableFormats, const DXGI_FORMAT
		// *pCastableFormats, [in] REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource2(in D3D12_RESOURCE_DESC pDesc, D3D12_BARRIER_LAYOUT InitialLayout,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession,
			int NumCastableFormats, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] DXGI_FORMAT[]? pCastableFormats,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 7)] out object? ppvResource);

		[PreserveSig]
		new void CreateSampler2(in D3D12_SAMPLER_DESC pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		[PreserveSig]
		D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo3(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC1[] pResourceDescs,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] uint[]? pNumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] DXGI_FORMAT[]? ppCastableFormats,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[]? pResourceAllocationInfo1);
	}

	[ComImport]
	[Guid("14eecffc-4df8-40f7-a118-5c816f45695e")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ID3D12Device13 : ID3D12Device12, ID3D12Device11, ID3D12Device10, ID3D12Device9, ID3D12Device8, ID3D12Device7, ID3D12Device6, ID3D12Device5, ID3D12Device4, ID3D12Device3, ID3D12Device2, ID3D12Device1, ID3D12Device, ID3D12Object
	{
		/// <summary>Gets application-defined data from a device object.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> that is associated with the data.</para>
		/// </param>
		/// <param name="pDataSize">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a variable that on input contains the size, in bytes, of the buffer that <i>pData</i> points to, and on output
		/// contains the size, in bytes, of the amount of data that <b>GetPrivateData</b> retrieved.
		/// </para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a memory block that receives the data from the device object if <i>pDataSize</i> points to a value that specifies a
		/// buffer large enough to hold the data.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// If the data returned is a pointer to an <c>IUnknown</c>, or one of its derivative classes, which was previously set by
		/// SetPrivateDataInterface, that interface will have its reference count incremented before the private data is returned.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-getprivatedata HRESULT GetPrivateData( [in]
		// REFGUID guid, [in, out] UINT *pDataSize, [out, optional] void *pData );
		[PreserveSig]
		new HRESULT GetPrivateData(in Guid guid, ref uint pDataSize, [Out, Optional] IntPtr pData);

		/// <summary>Sets application-defined data to a device object and associates that data with an application-defined <b>GUID</b>.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the data.</para>
		/// </param>
		/// <param name="DataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size in bytes of the data.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>
		/// A pointer to a memory block that contains the data to be stored with this device object. If <i>pData</i> is <b>NULL</b>,
		/// <i>DataSize</i> must also be 0, and any data that was previously associated with the <b>GUID</b> specified in <i>guid</i> will
		/// be destroyed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// Rather than using the Direct3D 11 debug object naming scheme of calling <b>ID3D12Object::SetPrivateData</b> using
		/// <b>WKPDID_D3DDebugObjectName</b> with an ASCII name, call <c>ID3D12Object::SetName</c> with a UNICODE name.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedata HRESULT SetPrivateData( [in]
		// REFGUID guid, [in] UINT DataSize, [in, optional] const void *pData );
		[PreserveSig]
		new HRESULT SetPrivateData(in Guid guid, uint DataSize, [In, Optional] IntPtr pData);

		/// <summary>
		/// Associates an <c>IUnknown</c>-derived interface with the device object, and associates that interface with an
		/// application-defined <b>GUID</b>.
		/// </summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the interface.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const <c>IUnknown</c>*</b></para>
		/// <para>
		/// A pointer to the <c>IUnknown</c>-derived interface to be associated with the device object. Its reference count is incremented
		/// when set, and its reference count is decremented when either the <c>ID3D12Object</c> is destroyed, or when the data is
		/// overwritten by calling <c>SetPrivateData</c> or <b>SetPrivateDataInterface</b> with the same <b>GUID</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 return codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedatainterface HRESULT
		// SetPrivateDataInterface( [in] REFGUID guid, [in, optional] const IUnknown *pData );
		[PreserveSig]
		new HRESULT SetPrivateDataInterface(in Guid guid, [In, Optional, MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 0)] object? pData);

		/// <summary>Associates a name with the device object. This name is for use in debug diagnostics and tools.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the device object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>This method takes UNICODE names.</para>
		/// <para>
		/// Note that this is simply a convenience wrapper around <c>ID3D12Object::SetPrivateData</c> with
		/// <b>WKPDID_D3DDebugObjectNameW</b>. Therefore names which are set with <c>SetName</c> can be retrieved with
		/// <c>ID3D12Object::GetPrivateData</c> with the same GUID. Additionally, D3D12 supports narrow strings for names, using the
		/// <b>WKPDID_D3DDebugObjectName</b> GUID directly instead.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setname HRESULT SetName( [in] LPCWSTR Name );
		[PreserveSig]
		new HRESULT SetName([MarshalAs(UnmanagedType.LPWStr)] string Name);

		/// <summary>Reports the number of physical adapters (nodes) that are associated with this device.</summary>
		/// <returns>
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of physical adapters (nodes) that this device has.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getnodecount UINT GetNodeCount();
		[PreserveSig]
		new uint GetNodeCount();

		/// <summary>
		/// <para>Creates a command queue.</para>
		/// <para>Also see <c>ID3D12Device9::CreateCommandQueue1</c>.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_COMMAND_QUEUE_DESC</c>*</b></para>
		/// <para>Specifies a <b>D3D12_COMMAND_QUEUE_DESC</b> that describes the command queue.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier (GUID) for the command queue interface. See <b>Remarks</b>. An input parameter.</para>
		/// </param>
		/// <param name="ppCommandQueue">
		/// <para>Type: [out] <b><b>void</b>**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandQueue</c> interface for the command queue.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the command queue. See <c>Direct3D 12 return
		/// codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the command queue can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12CommandQueue) will get the <b>GUID</b> of the interface to a command queue.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandqueue HRESULT CreateCommandQueue(
		// const D3D12_COMMAND_QUEUE_DESC *pDesc, REFIID riid, void **ppCommandQueue );
		[PreserveSig]
		new HRESULT CreateCommandQueue(in D3D12_COMMAND_QUEUE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppCommandQueue);

		/// <summary>Creates a command allocator object.</summary>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>
		/// A <c>D3D12_COMMAND_LIST_TYPE</c>-typed value that specifies the type of command allocator to create. The type of command
		/// allocator can be the type that records either direct command lists or bundles.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the command allocator interface ( <c>ID3D12CommandAllocator</c>). The
		/// <b>REFIID</b>, or <b>GUID</b>, of the interface to the command allocator can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12CommandAllocator) will get the <b>GUID</b> of the interface to a command allocator.
		/// </para>
		/// </param>
		/// <param name="ppCommandAllocator">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandAllocator</c> interface for the command allocator.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the command allocator. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The device creates command lists from the command allocator. Examples The <c>D3D12Bundles</c> sample uses
		/// <b>ID3D12Device::CreateCommandAllocator</b> as follows:
		/// </para>
		/// <para>
		/// <c>ThrowIfFailed(pDevice-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&amp;m_commandAllocator)));
		/// ThrowIfFailed(pDevice-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_BUNDLE, IID_PPV_ARGS(&amp;m_bundleAllocator)));</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandallocator HRESULT
		// CreateCommandAllocator( [in] D3D12_COMMAND_LIST_TYPE type, REFIID riid, [out] void **ppCommandAllocator );
		[PreserveSig]
		new HRESULT CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE type, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppCommandAllocator);

		/// <summary>Creates a graphics pipeline state object.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c> structure that describes graphics pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>). The <b>REFIID</b>,
		/// or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For example,
		/// __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// The pipeline state object is an immutable state object. It contains no methods.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-creategraphicspipelinestate HRESULT
		// CreateGraphicsPipelineState( [in] const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreateGraphicsPipelineState(in D3D12_GRAPHICS_PIPELINE_STATE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>Creates a compute pipeline state object.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c> structure that describes compute pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>). The <b>REFIID</b>,
		/// or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For example,
		/// __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// The pipeline state object is an immutable state object. It contains no methods.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcomputepipelinestate HRESULT
		// CreateComputePipelineState( [in] const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreateComputePipelineState(in D3D12_COMPUTE_PIPELINE_STATE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>Creates a command list.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set a bit to identify the node (the device's
		/// physical adapter) for which to create the command list. Each bit in the mask corresponds to a single node. Only one bit must be
		/// set. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>Specifies the type of command list to create.</para>
		/// </param>
		/// <param name="pCommandAllocator">
		/// <para>Type: <b><c>ID3D12CommandAllocator</c>*</b></para>
		/// <para>A pointer to the command allocator object from which the device creates command lists.</para>
		/// </param>
		/// <param name="pInitialState">
		/// <para>Type: <b><c>ID3D12PipelineState</c>*</b></para>
		/// <para>
		/// An optional pointer to the pipeline state object that contains the initial pipeline state for the command list. If it is
		/// <c>nullptr</c>, then the runtime sets a dummy initial pipeline state, so that drivers don't have to deal with undefined state.
		/// The overhead for this is low, particularly for a command list, for which the overall cost of recording the command list likely
		/// dwarfs the cost of a single initial state setting. So there's little cost in not setting the initial pipeline state parameter,
		/// if doing so is inconvenient.
		/// </para>
		/// <para>
		/// For bundles, on the other hand, it might make more sense to try to set the initial state parameter (since bundles are likely
		/// smaller overall, and can be reused frequently).
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the command list interface to return in ppCommandList.</para>
		/// </param>
		/// <param name="ppCommandList">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12CommandList</c> or <c>ID3D12GraphicsCommandList</c>
		/// interface for the command list.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the command list.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>The device creates command lists from the command allocator.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandlist HRESULT CreateCommandList( [in]
		// UINT nodeMask, [in] D3D12_COMMAND_LIST_TYPE type, [in] ID3D12CommandAllocator *pCommandAllocator, [in, optional]
		// ID3D12PipelineState *pInitialState, [in] REFIID riid, [out] void **ppCommandList );
		[PreserveSig]
		new HRESULT CreateCommandList(uint nodeMask, D3D12_COMMAND_LIST_TYPE type, [In] ID3D12CommandAllocator pCommandAllocator, [In, Optional] ID3D12PipelineState? pInitialState,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppCommandList);

		/// <summary>Gets information about the features that are supported by the current graphics driver.</summary>
		/// <param name="Feature">
		/// <para>Type: <b><c>D3D12_FEATURE</c></b></para>
		/// <para>A constant from the <c>D3D12_FEATURE</c> enumeration describing the feature(s) that you want to query for support.</para>
		/// </param>
		/// <param name="pFeatureSupportData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a data structure that corresponds to the value of the <i>Feature</i> parameter. To determine the corresponding data
		/// structure for each constant, see <c>D3D12_FEATURE</c>.
		/// </para>
		/// </param>
		/// <param name="FeatureSupportDataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size of the structure pointed to by the <i>pFeatureSupportData</i> parameter.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// Returns <b>S_OK</b> if successful. Returns <b>E_INVALIDARG</b> if an unsupported data type is passed to the
		/// <i>pFeatureSupportData</i> parameter or if a size mismatch is detected for the <i>FeatureSupportDataSize</i> parameter.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// As a usage example, to check for ray tracing support, specify the <c>D3D12_FEATURE_DATA_D3D12_OPTIONS5</c> structure in the
		/// <i>pFeatureSupportData</i> parameter. When the function completes successfully, access the <i>RaytracingTier</i> field (which
		/// specifies the supported ray tracing tier) of the now-populated <b>D3D12_FEATURE_DATA_D3D12_OPTIONS5</b> structure.
		/// </para>
		/// <para>For more info, see <c>Capability Querying</c>.</para>
		/// <para><c></c><c></c><c></c> Hardware support for DXGI Formats</para>
		/// <para>To view tables of DXGI formats and hardware features, refer to:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 12.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 12.0 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 11.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 11.0 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>Hardware Support for Direct3D 10Level9 Formats</c></description>
		/// </item>
		/// <item>
		/// <description><c>Format Support for Direct3D Feature Level 10.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>Format Support for Direct3D Feature Level 10.0 Hardware</c></description>
		/// </item>
		/// </list>
		/// <para>Examples</para>
		/// <para>The <c>D3D1211on12</c> sample uses <b>ID3D12Device::CheckFeatureSupport</b> as follows:</para>
		/// <para>
		/// <c>inline UINT8 D3D12GetFormatPlaneCount( _In_ ID3D12Device* pDevice, DXGI_FORMAT Format ) { D3D12_FEATURE_DATA_FORMAT_INFO
		/// formatInfo = {Format}; if (FAILED(pDevice-&gt;CheckFeatureSupport(D3D12_FEATURE_FORMAT_INFO, &amp;formatInfo,
		/// sizeof(formatInfo)))) { return 0; } return formatInfo.PlaneCount; }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport HRESULT CheckFeatureSupport(
		// D3D12_FEATURE Feature, [in, out] void *pFeatureSupportData, UINT FeatureSupportDataSize );
		[PreserveSig]
		new HRESULT CheckFeatureSupport(D3D12_FEATURE Feature, [In, Out] IntPtr pFeatureSupportData, uint FeatureSupportDataSize);

		/// <summary>Creates a descriptor heap object.</summary>
		/// <param name="pDescriptorHeapDesc">
		/// <para>Type: <b>const <c>D3D12_DESCRIPTOR_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DESCRIPTOR_HEAP_DESC</c> structure that describes the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the descriptor heap interface. See Remarks. An input parameter.</para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b><b>void</b>**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the descriptor heap. <i>ppvHeap</i> can be NULL, to enable capability
		/// testing. When <i>ppvHeap</i> is NULL, no object will be created and S_FALSE will be returned when <i>pDescriptorHeapDesc</i> is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the descriptor heap object. See <c>Direct3D
		/// 12 Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the descriptor heap can be obtained by using the __uuidof() macro. For
		/// example, __uuidof( <c>ID3D12DescriptorHeap</c>) will get the <b>GUID</b> of the interface to a descriptor heap. Examples The
		/// <c>D3D12HelloWorld</c> sample uses <b>ID3D12Device::CreateDescriptorHeap</b> as follows:
		/// </para>
		/// <para>Describe and create a render target view (RTV) descriptor heap.</para>
		/// <para>
		/// <c>// Create descriptor heaps. { // Describe and create a render target view (RTV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// rtvHeapDesc = {}; rtvHeapDesc.NumDescriptors = FrameCount; rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; rtvHeapDesc.Flags
		/// = D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;rtvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_rtvHeap))); m_rtvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV); } // Create frame resources. {
		/// CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); // Create a RTV for each frame. for
		/// (UINT n = 0; n &lt; FrameCount; n++) { ThrowIfFailed(m_swapChain-&gt;GetBuffer(n, IID_PPV_ARGS(&amp;m_renderTargets[n])));
		/// m_device-&gt;CreateRenderTargetView(m_renderTargets[n].Get(), nullptr, rtvHandle); rtvHandle.Offset(1, m_rtvDescriptorSize); }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap HRESULT
		// CreateDescriptorHeap( [in] const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateDescriptorHeap(in D3D12_DESCRIPTOR_HEAP_DESC pDescriptorHeapDesc, in Guid riid, [Out] IntPtr ppvHeap);

		/// <summary>
		/// Gets the size of the handle increment for the given type of descriptor heap. This value is typically used to increment a handle
		/// into a descriptor array by the correct amount.
		/// </summary>
		/// <param name="DescriptorHeapType">
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to get the size of the handle
		/// increment for.
		/// </param>
		/// <returns>Returns the size of the handle increment for the given type of descriptor heap, including any necessary padding.</returns>
		/// <remarks>
		/// <para>
		/// The descriptor size returned by this method is used as one input to the helper structures <c>CD3DX12_CPU_DESCRIPTOR_HANDLE</c>
		/// and <c>CD3DX12_GPU_DESCRIPTOR_HANDLE</c>. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12Device::GetDescriptorHandleIncrementSize</b> as follows:
		/// </para>
		/// <para>
		/// Create the descriptor heap for the resources. The <c>m_rtvDescriptorSize</c> variable stores the render target view descriptor
		/// handle increment size, and is used in the <b>Create frame resources</b> section of the code.
		/// </para>
		/// <para>
		/// <c>// Create descriptor heaps. { // Describe and create a render target view (RTV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// rtvHeapDesc = {}; rtvHeapDesc.NumDescriptors = FrameCount; rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; rtvHeapDesc.Flags
		/// = D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;rtvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_rtvHeap))); // Describe and create a depth stencil view (DSV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// dsvHeapDesc = {}; dsvHeapDesc.NumDescriptors = 1; dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV; dsvHeapDesc.Flags =
		/// D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;dsvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_dsvHeap))); // Describe and create a constant buffer view (CBV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// cbvHeapDesc = {}; cbvHeapDesc.NumDescriptors = CbvCountPerFrame * FrameCount; cbvHeapDesc.Type =
		/// D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV; cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
		/// ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;cbvHeapDesc, IID_PPV_ARGS(&amp;m_cbvHeap))); // Describe and create a heap
		/// for occlusion queries. D3D12_QUERY_HEAP_DESC queryHeapDesc = {}; queryHeapDesc.Count = 1; queryHeapDesc.Type =
		/// D3D12_QUERY_HEAP_TYPE_OCCLUSION; ThrowIfFailed(m_device-&gt;CreateQueryHeap(&amp;queryHeapDesc,
		/// IID_PPV_ARGS(&amp;m_queryHeap))); m_rtvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV); m_cbvSrvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV); } // Create frame resources. {
		/// CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); // Create a RTV and a command
		/// allocator for each frame. for (UINT n = 0; n &lt; FrameCount; n++) { ThrowIfFailed(m_swapChain-&gt;GetBuffer(n,
		/// IID_PPV_ARGS(&amp;m_renderTargets[n]))); m_device-&gt;CreateRenderTargetView(m_renderTargets[n].Get(), nullptr, rtvHandle);
		/// rtvHandle.Offset(1, m_rtvDescriptorSize); ThrowIfFailed(m_device-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT,
		/// IID_PPV_ARGS(&amp;m_commandAllocators[n]))); } }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getdescriptorhandleincrementsize UINT
		// GetDescriptorHandleIncrementSize( [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType );
		[PreserveSig]
		new uint GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);

		/// <summary>Creates a root signature layout.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single GPU operation, set this to zero. If there are multiple GPU nodes, set bits to identify the nodes (the device's
		/// physical adapters) to which the root signature is to apply. Each bit in the mask corresponds to a single node. Refer to
		/// <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="pBlobWithRootSignature">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>A pointer to the source data for the serialized signature.</para>
		/// </param>
		/// <param name="blobLengthInBytes">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>The size, in bytes, of the block of memory that <i>pBlobWithRootSignature</i> points to.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the root signature interface. See Remarks. An input parameter.</para>
		/// </param>
		/// <param name="ppvRootSignature">
		/// <para>Type: <b><b>void</b>**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the root signature.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// <para>This method returns <b>E_INVALIDARG</b> if the blob that <i>pBlobWithRootSignature</i> points to is invalid.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// If an application procedurally generates a <c>D3D12_ROOT_SIGNATURE_DESC</c> data structure, it must pass a pointer to this
		/// <b>D3D12_ROOT_SIGNATURE_DESC</b> in a call to <c>D3D12SerializeRootSignature</c> to make the serialized form. The application
		/// then passes the serialized form to <i>pBlobWithRootSignature</i> in a call to <b>ID3D12Device::CreateRootSignature</b>.
		/// </para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the root signature layout can be obtained by using the __uuidof() macro.
		/// For example, __uuidof( <c>ID3D12RootSignature</c>) will get the <b>GUID</b> of the interface to a root signature. Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12Device::CreateRootSignature</b> as follows:
		/// </para>
		/// <para>Create an empty root signature.</para>
		/// <para>
		/// <c>CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc; rootSignatureDesc.Init(0, nullptr, 0, nullptr,
		/// D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT); ComPtr&lt;ID3DBlob&gt; signature; ComPtr&lt;ID3DBlob&gt; error;
		/// ThrowIfFailed(D3D12SerializeRootSignature(&amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &amp;signature, &amp;error));
		/// ThrowIfFailed(m_device-&gt;CreateRootSignature(0, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(), IID_PPV_ARGS(&amp;m_rootSignature)));</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrootsignature HRESULT CreateRootSignature(
		// [in] UINT nodeMask, [in] const void *pBlobWithRootSignature, [in] SIZE_T blobLengthInBytes, REFIID riid, [out] void
		// **ppvRootSignature );
		[PreserveSig]
		new HRESULT CreateRootSignature(uint nodeMask, [In] IntPtr pBlobWithRootSignature, [In] SizeT blobLengthInBytes, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppvRootSignature);

		/// <summary>Creates a constant-buffer view for accessing resource data.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_CONSTANT_BUFFER_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_CONSTANT_BUFFER_VIEW_DESC</c> structure that describes the constant-buffer view.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the constant-buffer view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createconstantbufferview void
		// CreateConstantBufferView( [in, optional] const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE
		// DestDescriptor );
		[PreserveSig]
		new void CreateConstantBufferView([In, Optional] StructPointer<D3D12_CONSTANT_BUFFER_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a shader-resource view for accessing data in a resource.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the shader resource.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_SHADER_RESOURCE_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_SHADER_RESOURCE_VIEW_DESC</c> structure that describes the shader-resource view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and for buffers SRVs target a full buffer and are typed (not raw or structured), and for textures SRVs target a full texture,
		/// all mips and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// Describes the CPU descriptor handle that represents the shader-resource view. This handle can be created in a shader-visible or
		/// non-shader-visible descriptor heap.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para><c></c><c></c><c></c> Processing YUV 4:2:0 video formats</para>
		/// <para>
		/// An app must map the luma (Y) plane separately from the chroma (UV) planes. Developers do this by calling
		/// <b>CreateShaderResourceView</b> twice for the same texture and passing in 1-channel and 2-channel formats. Passing in a
		/// 1-channel format compatible with the Y plane maps only the Y plane. Passing in a 2-channel format compatible with the UV planes
		/// (together) maps only the U and V planes as a single resource view.
		/// </para>
		/// <para>
		/// YUV 4:2:0 formats are listed in <c>DXGI_FORMAT</c>. Examples The <c>D3D12nBodyGravity</c> sample uses
		/// <b>ID3D12Device::CreateShaderResourceView</b> as follows:
		/// </para>
		/// <para>Describe and create two shader resource views based on one description.</para>
		/// <para>
		/// <c>D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {}; srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
		/// srvDesc.Format = DXGI_FORMAT_UNKNOWN; srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER; srvDesc.Buffer.FirstElement = 0;
		/// srvDesc.Buffer.NumElements = ParticleCount; srvDesc.Buffer.StructureByteStride = sizeof(Particle); srvDesc.Buffer.Flags =
		/// D3D12_BUFFER_SRV_FLAG_NONE; CD3DX12_CPU_DESCRIPTOR_HANDLE srvHandle0(m_srvUavHeap-&gt;GetCPUDescriptorHandleForHeapStart(),
		/// SrvParticlePosVelo0 + index, m_srvUavDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// srvHandle1(m_srvUavHeap-&gt;GetCPUDescriptorHandleForHeapStart(), SrvParticlePosVelo1 + index, m_srvUavDescriptorSize);
		/// m_device-&gt;CreateShaderResourceView(m_particleBuffer0[index].Get(), &amp;srvDesc, srvHandle0);
		/// m_device-&gt;CreateShaderResourceView(m_particleBuffer1[index].Get(), &amp;srvDesc, srvHandle1);</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createshaderresourceview void
		// CreateShaderResourceView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
		// [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateShaderResourceView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_SHADER_RESOURCE_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a view for unordered accessing.</summary>
		/// <param name="pResource">
		/// <para>Type: [in, optional] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the unordered access.</para>
		/// <para>At least one of <i>pResource</i> or <i>pDesc</i> must be provided.</para>
		/// <para>
		/// A null <i>pResource</i> is used to initialize a null descriptor, which guarantees Direct3D 11-like null binding behavior
		/// (reading 0s, writes are discarded), but must have a valid <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pCounterResource">
		/// <para>Type: [in, optional] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The <c>ID3D12Resource</c> for the counter (if any) associated with the UAV.</para>
		/// <para>
		/// If <i>pCounterResource</i> is not specified, then the <b>CounterOffsetInBytes</b> member of the <c>D3D12_BUFFER_UAV</c>
		/// structure must be 0.
		/// </para>
		/// <para>
		/// If <i>pCounterResource</i> is specified, then there is a counter associated with the UAV, and the runtime performs validation of
		/// the following requirements:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>The <b>StructureByteStride</b> member of the <c>D3D12_BUFFER_UAV</c> structure must be greater than 0.</description>
		/// </item>
		/// <item>
		/// <description>The format must be DXGI_FORMAT_UNKNOWN.</description>
		/// </item>
		/// <item>
		/// <description>The D3D12_BUFFER_UAV_FLAG_RAW flag (a <c>D3D12_BUFFER_UAV_FLAGS</c> enumeration constant) must not be set.</description>
		/// </item>
		/// <item>
		/// <description>Both of the resources ( <i>pResource</i> and <i>pCounterResource</i>) must be buffers.</description>
		/// </item>
		/// <item>
		/// <description>
		/// The <b>CounterOffsetInBytes</b> member of the <c>D3D12_BUFFER_UAV</c> structure must be a multiple of
		/// **D3D12_UAV_COUNTER_PLACEMENT_ALIGNMENT** (4096), and must be within the range of the counter resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description><i>pResource</i> cannot be NULL</description>
		/// </item>
		/// <item>
		/// <description><i>pDesc</i> cannot be NULL.</description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in, optional] <b>const <c>D3D12_UNORDERED_ACCESS_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_UNORDERED_ACCESS_VIEW_DESC</c> structure that describes the unordered-access view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and for buffers UAVs target a full buffer and are typed, and for textures UAVs target the first mip and all array slices. Not
		/// all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the unordered-access view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createunorderedaccessview void
		// CreateUnorderedAccessView( ID3D12Resource *pResource, ID3D12Resource *pCounterResource, const D3D12_UNORDERED_ACCESS_VIEW_DESC
		// *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateUnorderedAccessView([In, Optional] ID3D12Resource? pResource, [In, Optional] ID3D12Resource? pCounterResource,
			[In, Optional] StructPointer<D3D12_UNORDERED_ACCESS_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a render-target view for accessing resource data.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the render target.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RENDER_TARGET_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_RENDER_TARGET_VIEW_DESC</c> structure that describes the render-target view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and RTVs target the first mip and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the destination where the newly-created render target view will reside.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrendertargetview void
		// CreateRenderTargetView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_RENDER_TARGET_VIEW_DESC *pDesc, [in]
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateRenderTargetView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_RENDER_TARGET_VIEW_DESC> pDesc,
			[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a depth-stencil view for accessing resource data.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the depth stencil.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_DEPTH_STENCIL_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DEPTH_STENCIL_VIEW_DESC</c> structure that describes the depth-stencil view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and DSVs target the first mip and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the depth-stencil view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createdepthstencilview void
		// CreateDepthStencilView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc, [in]
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateDepthStencilView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_DEPTH_STENCIL_VIEW_DESC> pDesc,
			[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Create a sampler object that encapsulates sampling information for a texture.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_SAMPLER_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_SAMPLER_DESC</c> structure that describes the sampler.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the sampler.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsampler void CreateSampler( [in] const
		// D3D12_SAMPLER_DESC *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateSampler(in D3D12_SAMPLER_DESC pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Copies descriptors from a source to a destination.</summary>
		/// <param name="NumDestDescriptorRanges">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of destination descriptor ranges to copy to.</para>
		/// </param>
		/// <param name="pDestDescriptorRangeStarts">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>An array of <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> objects to copy to.</para>
		/// <para>All the destination and source descriptors must be in heaps of the same <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>.</para>
		/// </param>
		/// <param name="pDestDescriptorRangeSizes">
		/// <para>Type: <b>const <c>UINT</c>*</b></para>
		/// <para>An array of destination descriptor range sizes to copy to.</para>
		/// </param>
		/// <param name="NumSrcDescriptorRanges">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of source descriptor ranges to copy from.</para>
		/// </param>
		/// <param name="pSrcDescriptorRangeStarts">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>An array of <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> objects to copy from.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// All elements in the pSrcDescriptorRangeStarts parameter must be in a non shader-visible descriptor heap. This is because
		/// shader-visible descriptor heaps may be created in <b>WRITE_COMBINE</b> memory or GPU local memory, which is prohibitively slow
		/// to read from. If your application manages descriptor heaps via copying the descriptors required for a given pass or frame from
		/// local "storage" descriptor heaps to the GPU-bound descriptor heap, use shader-opaque heaps for the storage heaps and copy into
		/// the GPU-visible heap as required.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="pSrcDescriptorRangeSizes">
		/// <para>Type: <b>const <c>UINT</c>*</b></para>
		/// <para>An array of source descriptor range sizes to copy from.</para>
		/// </param>
		/// <param name="DescriptorHeapsType">
		/// <para>Type: <b><c>D3D12_DESCRIPTOR_HEAP_TYPE</c></b></para>
		/// <para>
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to copy with. This is required as
		/// different descriptor types may have different sizes.
		/// </para>
		/// <para>Both the source and destination descriptor heaps must have the same type, else the debug layer will emit an error.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// Where applicable, prefer <c><b>ID3D12Device::CopyDescriptorsSimple</b></c> to this method. It can have a better CPU cache miss
		/// rate due to the linear nature of the copy.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-copydescriptors void CopyDescriptors( [in] UINT
		// NumDestDescriptorRanges, [in] const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts, [in, optional] const UINT
		// *pDestDescriptorRangeSizes, [in] UINT NumSrcDescriptorRanges, [in] const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
		// [in, optional] const UINT *pSrcDescriptorRangeSizes, [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType );
		[PreserveSig]
		new void CopyDescriptors(int NumDestDescriptorRanges, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_CPU_DESCRIPTOR_HANDLE[] pDestDescriptorRangeStarts,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[]? pDestDescriptorRangeSizes, int NumSrcDescriptorRanges,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] D3D12_CPU_DESCRIPTOR_HANDLE[] pSrcDescriptorRangeStarts,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[]? pSrcDescriptorRangeSizes, D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);

		/// <summary>Copies descriptors from a source to a destination.</summary>
		/// <param name="NumDescriptors">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of descriptors to copy.</para>
		/// </param>
		/// <param name="DestDescriptorRangeStart">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> that describes the destination descriptors to start to copy to.</para>
		/// <para>The destination and source descriptors must be in heaps of the same <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>.</para>
		/// </param>
		/// <param name="SrcDescriptorRangeStart">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> that describes the source descriptors to start to copy from.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// The SrcDescriptorRangeStart parameter must be in a non shader-visible descriptor heap. This is because shader-visible descriptor
		/// heaps may be created in <b>WRITE_COMBINE</b> memory or GPU local memory, which is prohibitively slow to read from. If your
		/// application manages descriptor heaps via copying the descriptors required for a given pass or frame from local "storage"
		/// descriptor heaps to the GPU-bound descriptor heap, then use shader-opaque heaps for the storage heaps and copy into the
		/// GPU-visible heap as required.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="DescriptorHeapsType">
		/// <para>Type: <b><c>D3D12_DESCRIPTOR_HEAP_TYPE</c></b></para>
		/// <para>
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to copy with. This is required as
		/// different descriptor types may have different sizes.
		/// </para>
		/// <para>Both the source and destination descriptor heaps must have the same type, else the debug layer will emit an error.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// Where applicable, prefer this method to <c><b>ID3D12Device::CopyDescriptors</b></c>. It can have a better CPU cache miss rate
		/// due to the linear nature of the copy.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-copydescriptorssimple void CopyDescriptorsSimple(
		// [in] UINT NumDescriptors, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart, [in] D3D12_CPU_DESCRIPTOR_HANDLE
		// SrcDescriptorRangeStart, [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType );
		[PreserveSig]
		new void CopyDescriptorsSimple(uint NumDescriptors, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart, [In] D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
			D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);

		/// <summary>Gets the size and alignment of memory required for a collection of resources on this adapter.</summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// <para>If an error occurs, then <b>D3D12_RESOURCE_ALLOCATION_INFO::SizeInBytes</b> equals <b>UINT64_MAX</b>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When you're using <c>CreatePlacedResource</c>, your application must use <b>GetResourceAllocationInfo</b> in order to understand
		/// the size and alignment characteristics of texture resources. The results of this method vary depending on the particular
		/// adapter, and must be treated as unique to this adapter and driver version.
		/// </para>
		/// <para>
		/// Your application can't use the output of <b>GetResourceAllocationInfo</b> to understand packed mip properties of textures. To
		/// understand packed mip properties of textures, your application must use <c>GetResourceTiling</c>.
		/// </para>
		/// <para>
		/// Texture resource sizes significantly differ from the information returned by <b>GetResourceTiling</b>, because some adapter
		/// architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios. This even
		/// includes textures that have constraints on their texture layouts, or have standardized texture layouts. That extra memory can't
		/// be sparsely mapped nor remapped by an application using <c>CreateReservedResource</c> and <c>UpdateTileMappings</c>, so it isn't
		/// reported by <b>GetResourceTiling</b>.
		/// </para>
		/// <para>
		/// Your application can forgo using <b>GetResourceAllocationInfo</b> for buffer resources (
		/// <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>). Buffers have the same size on all adapters, which is merely the smallest multiple of
		/// 64KB that's greater or equal to <c>D3D12_RESOURCE_DESC::Width</c>.
		/// </para>
		/// <para>
		/// When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used.
		/// For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource, reports differing sizes
		/// based on the order of the array. If the 4MB aligned resource is in the middle, then the resulting <b>Size</b> is 12MB.
		/// Otherwise, the resulting <b>Size</b> is 8MB. The <b>Alignment</b> returned would always be 4MB, because it's the superset of all
		/// alignments in the resource array.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getresourceallocationinfo(uint_uint_constd3d12_resource_desc)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo( [in] UINT visibleMask, [in] UINT numResourceDescs, [in] const
		// D3D12_RESOURCE_DESC *pResourceDescs );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_RESOURCE_DESC[] pResourceDescs);

		/// <summary>
		/// Divulges the equivalent custom heap properties that are used for non-custom heap types, based on the adapter's architectural properties.
		/// </summary>
		/// <param name="nodeMask">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the device's
		/// physical adapter). Each bit in the mask corresponds to a single node. Only 1 bit must be set. See <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="heapType">
		/// <para>Type: <b><c>D3D12_HEAP_TYPE</c></b></para>
		/// <para>
		/// A <c>D3D12_HEAP_TYPE</c>-typed value that specifies the heap to get properties for. D3D12_HEAP_TYPE_CUSTOM is not supported as a
		/// parameter value.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_HEAP_PROPERTIES</c></b></para>
		/// <para>
		/// Returns a <c>D3D12_HEAP_PROPERTIES</c> structure that provides properties for the specified heap. The <b>Type</b> member of the
		/// returned D3D12_HEAP_PROPERTIES is always D3D12_HEAP_TYPE_CUSTOM.
		/// </para>
		/// <para>When <c>D3D12_FEATURE_DATA_ARCHITECTURE</c>::UMA is FALSE, the returned D3D12_HEAP_PROPERTIES members convert as follows:</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_COMBINE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L1.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// <para></para>
		/// <para>
		/// When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is FALSE, the returned
		/// D3D12_HEAP_PROPERTIES members convert as follows:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_COMBINE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// <para></para>
		/// <para>
		/// When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is TRUE, the returned
		/// D3D12_HEAP_PROPERTIES members convert as follows:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcustomheapproperties(uint_d3d12_heap_type)
		// D3D12_HEAP_PROPERTIES GetCustomHeapProperties( [in] UINT nodeMask, D3D12_HEAP_TYPE heapType );
		[PreserveSig]
		new D3D12_HEAP_PROPERTIES GetCustomHeapProperties(uint nodeMask, D3D12_HEAP_TYPE heapType);

		/// <summary>
		/// Creates both a resource and an implicit heap, such that the heap is big enough to contain the entire resource, and the resource
		/// is mapped to the heap.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource HRESULT
		// CreateCommittedResource( [in] const D3D12_HEAP_PROPERTIES *pHeapProperties, [in] D3D12_HEAP_FLAGS HeapFlags, [in] const
		// D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialResourceState, [in, optional] const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, [in] REFIID riidResource, [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>Creates a heap that can be used with placed resources and reserved resources.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_HEAP_DESC</b> structure that describes the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the heap interface to return in ppvHeap.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Heap</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// An optional pointer to a memory block that receives the requested interface pointer to the created heap object. <paramref
		/// name="ppvHeap"/> can be <c>nullptr</c>, to enable capability testing. When ppvHeap is <c>nullptr</c>, no object is created, and
		/// <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the heap.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para><b>CreateHeap</b> creates a heap that can be used with placed resources and reserved resources.</para>
		/// <para>
		/// Before releasing the final reference on the heap, your application must ensure that the GPU will no longer read or write to this heap.
		/// </para>
		/// <para>
		/// A placed resource object holds a reference on the heap it is created on; but a reserved resource doesn't hold a reference for
		/// each mapping made to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createheap HRESULT CreateHeap( [in] const
		// D3D12_HEAP_DESC *pDesc, [in] REFIID riid, [out, optional] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateHeap(in D3D12_HEAP_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>
		/// When a resource is created together with a <b>D3D12_HEAP_TYPE_UPLOAD</b> heap, InitialState must be
		/// <b>D3D12_RESOURCE_STATE_GENERIC_READ</b>. When a resource is created together with a <b>D3D12_HEAP_TYPE_READBACK</b> heap,
		/// InitialState must be <b>D3D12_RESOURCE_STATE_COPY_DEST</b>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreatePlacedResource</b> is similar to fully mapping a reserved resource to an offset within a heap; but the virtual address
		/// space associated with a heap may be reused as well.
		/// </para>
		/// <para>
		/// Placed resources are lighter weight to create and destroy than committed resources are. This is because no heap is created nor
		/// destroyed during those operations. In addition, placed resources enable an even lighter weight technique to reuse memory than
		/// resource creation and destructionthat is, reuse through aliasing, and aliasing barriers. Multiple placed resources may
		/// simultaneously overlap each other on the same heap, but only a single overlapping resource can be used at a time.
		/// </para>
		/// <para>
		/// There are two placed resource usage semanticsa simple model, and an advanced model. We recommend that you choose the simple
		/// model (it maximizes graphics tool support across the diverse ecosystem of GPUs), unless and until you find that you need the
		/// advanced model for your app.
		/// </para>
		/// <para>Simple model</para>
		/// <para>
		/// In this model, you can consider a placed resource to be in one of two states: active, or inactive. It's invalid for the GPU to
		/// either read or write from an inactive resource. Placed resources are created in the inactive state.
		/// </para>
		/// <para>
		/// To activate a resource with an aliasing barrier on a command list, your application must pass the resource in
		/// <c><b>D3D12_RESOURCE_ALIASING_BARRIER::pResourceAfter</b></c>. <b>pResourceBefore</b> can be left NULL during an activation. All
		/// resources that share physical memory with the activated resource now become inactive, which includes overlapping placed and
		/// reserved resources.
		/// </para>
		/// <para>Aliasing barriers should be grouped up and submitted together, in order to maximize efficiency.</para>
		/// <para>
		/// After activation, resources with either the render target or depth stencil flags must be further initialized. See the notes on
		/// the required resource initialization below.
		/// </para>
		/// <para>Notes on the required resource initialization</para>
		/// <para>
		/// Certain resource types still require initialization. Resources with either the render target or depth stencil flags must be
		/// initialized with either a clear operation or a collection of full subresource copies. If an aliasing barrier was used to denote
		/// the transition between two aliased resources, the initialization must occur after the aliasing barrier. This initialization is
		/// still required whenever a resource would've been activated in the simple model.
		/// </para>
		/// <para>
		/// Placed and reserved resources with either the render target or depth stencil flags must be initialized with one of the following
		/// operations before other operations are supported.
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>A Clear operation; for example <c>ClearRenderTargetView</c> or <c>ClearDepthStencilView</c>.</description>
		/// </item>
		/// <item>
		/// <description>A <c>DiscardResource</c> operation.</description>
		/// </item>
		/// <item>
		/// <description>A Copy operation; for example <c>CopyBufferRegion</c>, <c>CopyTextureRegion</c>, or <c>CopyResource</c>.</description>
		/// </item>
		/// </list>
		/// <para>
		/// Applications should prefer the most explicit operation that results in the least amount of texels modified. Consider the
		/// following examples.
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// Using a depth buffer to solve pixel visibility typically requires each depth texel start out at 1.0 or 0. Therefore, a Clear
		/// operation should be the most efficient option for aliased depth buffer initialization.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// An application may use an aliased render target as a destination for tone mapping. Since the application will render over every
		/// pixel during the tone mapping, <c>DiscardResource</c> should be the most efficient option for initialization.
		/// </description>
		/// </item>
		/// </list>
		/// <para>Advanced model</para>
		/// <para>In this model, you can ignore the active/inactive state abstraction. Instead, you must honor these lower-level rules.</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// An aliasing barrier must be between two different GPU resource accesses of the same physical memory, as long as those accesses
		/// are within the same <c>ExecuteCommandLists</c> call.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// The first rendering operation to certain types of aliased resource must still be an initialization, just like the simple model.
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// Initialization operations must occur either on an entire subresource, or on a 64KB granularity. An entire subresource
		/// initialization is supported for all resource types. A 64KB initialization granularity, aligned at a 64KB offset, is supported
		/// for buffers and textures with either the 64KB_UNDEFINED_SWIZZLE or 64KB_STANDARD_SWIZZLE texture layout (refer to <c>D3D12_TEXTURE_LAYOUT</c>).
		/// </para>
		/// <para>Notes on the aliasing barrier</para>
		/// <para>
		/// The aliasing barrier may set NULL for both pResourceAfter and pResourceBefore. The memory coherence definition of
		/// <c><b>ExecuteCommandLists</b></c> and an aliasing barrier are the same, such that two aliased accesses to the same physical
		/// memory need no aliasing barrier when the accesses are in two different <b>ExecuteCommandLists</b> invocations.
		/// </para>
		/// <para>
		/// For D3D12 advanced usage models, the synchronization definition of <c><b>ExecuteCommandLists</b></c> is equivalent to an
		/// aliasing barrier. Therefore, applications may either insert an aliasing barrier between reusing physical memory, or ensure the
		/// two aliased usages of physical memory occurs in two separate calls to <b>ExecuteCommandLists</b>.
		/// </para>
		/// <para>
		/// The amount of inactivation varies based on resource properties. Textures with undefined memory layouts are the worst case, as
		/// the entire texture must be inactivated atomically. For two overlapping resources with defined layouts, inactivation can result
		/// in only the overlapping aligned regions of a resource. Data inheritance can even be well-defined. For more details, see
		/// <c>Memory aliasing and data inheritance</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource HRESULT
		// CreatePlacedResource( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC *pDesc, D3D12_RESOURCE_STATES InitialState,
		// const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>Creates a resource that is reserved, and not yet mapped to any pages in a heap.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreateReservedResource</b> is equivalent to <c>D3D11_RESOURCE_MISC_TILED</c> in Direct3D 11. It creates a resource with
		/// virtual memory only, no backing store.
		/// </para>
		/// <para>You need to map the resource to physical memory (that is, to a heap) using <c>CopyTileMappings</c> and <c>UpdateTileMappings</c>.</para>
		/// <para>
		/// These resource types can only be created when the adapter supports tiled resource tier 1 or greater. The tiled resource tier
		/// defines the behavior of accessing a resource that is not mapped to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createreservedresource HRESULT
		// CreateReservedResource( [in] const D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialState, [in, optional] const
		// D3D12_CLEAR_VALUE *pOptimizedClearValue, [in] REFIID riid, [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource(in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppvResource);

		/// <summary>Creates a shared handle to a heap, resource, or fence object.</summary>
		/// <param name="pObject">
		/// <para>Type: <b><c>ID3D12DeviceChild</c>*</b></para>
		/// <para>
		/// A pointer to the <c>ID3D12DeviceChild</c> interface that represents the heap, resource, or fence object to create for sharing.
		/// The following interfaces (derived from <b>ID3D12DeviceChild</b>) are supported:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pAttributes">
		/// <para>Type: <b>const <c>SECURITY_ATTRIBUTES</c>*</b></para>
		/// <para>
		/// A pointer to a <c>SECURITY_ATTRIBUTES</c> structure that contains two separate but related data members: an optional security
		/// descriptor, and a <b>Boolean</b> value that determines whether child processes can inherit the returned handle.
		/// </para>
		/// <para>
		/// Set this parameter to <b>NULL</b> if you want child processes that the application might create to not inherit the handle
		/// returned by <b>CreateSharedHandle</b>, and if you want the resource that is associated with the returned handle to get a default
		/// security descriptor.
		/// </para>
		/// <para>
		/// The <b>lpSecurityDescriptor</b> member of the structure specifies a <c>SECURITY_DESCRIPTOR</c> for the resource. Set this member
		/// to <b>NULL</b> if you want the runtime to assign a default security descriptor to the resource that is associated with the
		/// returned handle. The ACLs in the default security descriptor for the resource come from the primary or impersonation token of
		/// the creator. For more info, see <c>Synchronization Object Security and Access Rights</c>.
		/// </para>
		/// </param>
		/// <param name="Access">
		/// <para>Type: <b><c>DWORD</c></b></para>
		/// <para>Currently the only value this parameter accepts is GENERIC_ALL.</para>
		/// </param>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>
		/// A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the shared heap. The name is limited to
		/// MAX_PATH characters. Name comparison is case-sensitive.
		/// </para>
		/// <para>
		/// If <i>Name</i> matches the name of an existing resource, <b>CreateSharedHandle</b> fails with
		/// <c>DXGI_ERROR_NAME_ALREADY_EXISTS</c>. This occurs because these objects share the same namespace.
		/// </para>
		/// <para>
		/// The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder
		/// of the name can contain any character except the backslash character (\). For more information, see <c>Kernel Object
		/// Namespaces</c>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the
		/// guidelines outlined for Terminal Services so that applications can support multiple users.
		/// </para>
		/// <para>The object can be created in a private namespace. For more information, see <c>Object Namespaces</c>.</para>
		/// </param>
		/// <param name="pHandle">
		/// <para>Type: <b><c>HANDLE</c>*</b></para>
		/// <para>
		/// A pointer to a variable that receives the NT HANDLE value to the resource to share. You can use this handle in calls to access
		/// the resource.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns S_OK if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>DXGI_ERROR_INVALID_CALL</c> if one of the parameters is invalid.</description>
		/// </item>
		/// <item>
		/// <description>
		/// <c>DXGI_ERROR_NAME_ALREADY_EXISTS</c> if the supplied name of the resource to share is already associated with another resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description>E_ACCESSDENIED if the object is being created in a protected namespace.</description>
		/// </item>
		/// <item>
		/// <description>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</description>
		/// </item>
		/// <item>
		/// <description>Possibly other error codes that are described in the <c>Direct3D 12 Return Codes</c> topic.</description>
		/// </item>
		/// </list>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Both heaps and committed resources can be shared. Sharing a committed resource shares the implicit heap along with the committed
		/// resource description, such that a compatible resource description can be mapped to the heap from another device.
		/// </para>
		/// <para>
		/// For Direct3D 11 and Direct3D 12 interop scenarios, a shared fence is opened in DirectX 11 with the
		/// <c>ID3D11Device5::OpenSharedFence</c> method, and a shared resource is opened with the <c>ID3D11Device::OpenSharedResource1</c> method.
		/// </para>
		/// <para>
		/// For Direct3D 12, a shared handle is opened with the <c>ID3D12Device::OpenSharedHandle</c> or the
		/// ID3D12Device::OpenSharedHandleByName method.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle HRESULT CreateSharedHandle(
		// [in] ID3D12DeviceChild *pObject, [in, optional] const SECURITY_ATTRIBUTES *pAttributes, DWORD Access, [in, optional] LPCWSTR
		// Name, [out] HANDLE *pHandle );
		[PreserveSig]
		new HRESULT CreateSharedHandle([In] ID3D12DeviceChild pObject, [In, Optional] SECURITY_ATTRIBUTES? pAttributes, ACCESS_MASK Access,
			[Optional, MarshalAs(UnmanagedType.LPWStr)] string? Name, out HANDLE pHandle);

		/// <summary>Opens a handle for shared resources, shared heaps, and shared fences, by using HANDLE and REFIID.</summary>
		/// <param name="NTHandle">
		/// <para>Type: <b>HANDLE</b></para>
		/// <para>The handle that was output by the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for one of the following interfaces:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// <para>
		/// The REFIID , or GUID , of the interface can be obtained by using the __uuidof() macro. For example, __uuidof(ID3D12Heap) will
		/// get the GUID of the interface to a resource.
		/// </para>
		/// </param>
		/// <param name="ppvObj">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to one of the following interfaces:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-opensharedhandle HRESULT OpenSharedHandle( [in]
		// HANDLE NTHandle, REFIID riid, [out, optional] void **ppvObj );
		[PreserveSig]
		new HRESULT OpenSharedHandle(HANDLE NTHandle, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvObj);

		/// <summary>Opens a handle for shared resources, shared heaps, and shared fences, by using Name and Access.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>The name that was optionally passed as the <i>Name</i> parameter in the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="Access">
		/// <para>Type: <b>DWORD</b></para>
		/// <para>The access level that was specified in the <i>Access</i> parameter in the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="pNTHandle">
		/// <para>Type: <b>HANDLE*</b></para>
		/// <para>Pointer to the shared handle.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-opensharedhandlebyname HRESULT
		// OpenSharedHandleByName( [in] LPCWSTR Name, DWORD Access, [out] HANDLE *pNTHandle );
		[PreserveSig]
		new HRESULT OpenSharedHandleByName([MarshalAs(UnmanagedType.LPWStr)] string Name, ACCESS_MASK Access, out HANDLE pNTHandle);

		/// <summary>Makes objects resident for the device.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to make resident for the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block that contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>
		/// Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following
		/// objects: Descriptor Heaps, Heaps, Committed Resources, and Query Heaps
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>MakeResident</b> loads the data associated with a resource from disk, and re-allocates the memory from the resource's
		/// appropriate memory pool. This method should be called on the object which owns the physical memory.
		/// </para>
		/// <para>
		/// Use this method, and <c>Evict</c>, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to
		/// be done by the app in D3D12.
		/// </para>
		/// <para>
		/// <b>MakeResident</b> and <c>Evict</c> can help applications manage the residency budget on many adapters. <b>MakeResident</b>
		/// explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <b>Evict</b> enables page-out.
		/// </para>
		/// <para>
		/// Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use
		/// <c>D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT</c> and <c>IDXGIAdapter3::QueryVideoMemoryInfo</c> to recognize when the
		/// maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the
		/// residency budget will always be constrained by the amount of GPU virtual address space. <c>Evict</c> will not free-up any
		/// residency budget on such systems.
		/// </para>
		/// <para>
		/// Applications must handle <b>MakeResident</b> failures, even if there appears to be enough residency budget available. Physical
		/// memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications
		/// should free up more residency budget before trying again.
		/// </para>
		/// <para>
		/// <b>MakeResident</b> is ref-counted, such that <c>Evict</c> must be called the same amount of times as <b>MakeResident</b> before
		/// <b>Evict</b> takes effect. Objects that support residency are made resident during creation, so a single <b>Evict</b> call will
		/// actually evict the object.
		/// </para>
		/// <para>
		/// Applications must use fences to ensure the GPU doesn't use non-resident objects. <b>MakeResident</b> must return before the GPU
		/// executes a command list that references the object. <c>Evict</c> must be called after the GPU finishes executing a command list
		/// that references the object.
		/// </para>
		/// <para>
		/// Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource
		/// descriptors and other GPU virtual address references are not invalidated after <c>Evict</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-makeresident HRESULT MakeResident( UINT
		// NumObjects, [in] ID3D12Pageable * const *ppObjects );
		[PreserveSig]
		new HRESULT MakeResident(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects);

		/// <summary>Enables the page-out of data, which precludes GPU access of that data.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to evict from the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block that contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>
		/// Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following
		/// objects: Descriptor Heaps, Heaps, Committed Resources, and Query Heaps
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>Evict</b> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it
		/// was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns
		/// both virtual and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed
		/// resources are borrowing memory from a heap.
		/// </para>
		/// <para>Refer to the remarks for <c>MakeResident</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-evict HRESULT Evict( UINT NumObjects, [in]
		// ID3D12Pageable * const *ppObjects );
		[PreserveSig]
		new HRESULT Evict(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects);

		/// <summary>Creates a fence object.</summary>
		/// <param name="InitialValue">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>The initial value for the fence.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_FENCE_FLAGS</c></b></para>
		/// <para>
		/// A combination of <c>D3D12_FENCE_FLAGS</c>-typed values that are combined by using a bitwise OR operation. The resulting value
		/// specifies options for the fence.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the fence interface ( <c>ID3D12Fence</c>). The <b>REFIID</b>, or <b>GUID</b>,
		/// of the interface to the fence can be obtained by using the __uuidof() macro. For example, __uuidof(ID3D12Fence) will get the
		/// <b>GUID</b> of the interface to a fence.
		/// </para>
		/// </param>
		/// <param name="ppFence">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12Fence</c> interface that is used to access the fence.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createfence HRESULT CreateFence( UINT64
		// InitialValue, D3D12_FENCE_FLAGS Flags, REFIID riid, [out] void **ppFence );
		[PreserveSig]
		new HRESULT CreateFence(ulong InitialValue, D3D12_FENCE_FLAGS Flags, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppFence);

		/// <summary>
		/// Gets the reason that the device was removed, or <b>S_OK</b> if the device isn't removed. To be called back when a device is
		/// removed, consider using <c>ID3D12Fence::SetEventOnCompletion</c> with a value of <b>UINT64_MAX</b>. That's because device
		/// removal causes all fences to be signaled to that value (which also implies completing all events waited on, because they'll all
		/// be less than <b>UINT64_MAX</b>).
		/// </summary>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns the reason that the device was removed.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getdeviceremovedreason HRESULT GetDeviceRemovedReason();
		[PreserveSig]
		new HRESULT GetDeviceRemovedReason();

		/// <summary>
		/// Gets a resource layout that can be copied. Helps the app fill-in <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> when suballocating space in upload heaps.
		/// </summary>
		/// <param name="pResourceDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A description of the resource, as a pointer to a <c>D3D12_RESOURCE_DESC</c> structure.</para>
		/// </param>
		/// <param name="FirstSubresource">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Index of the first subresource in the resource. The range of valid values is 0 to D3D12_REQ_SUBRESOURCES.</para>
		/// </param>
		/// <param name="NumSubresources">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of subresources in the resource. The range of valid values is 0 to (D3D12_REQ_SUBRESOURCES - <i>FirstSubresource</i>).</para>
		/// </param>
		/// <param name="BaseOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset, in bytes, to the resource.</para>
		/// </param>
		/// <param name="pLayouts">
		/// <para>Type: <b><c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c>*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> structures, to be filled
		/// with the description and placement of each subresource.
		/// </para>
		/// </param>
		/// <param name="pNumRows">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, to be filled with the number of rows for each subresource.
		/// </para>
		/// </param>
		/// <param name="pRowSizeInBytes">
		/// <para>Type: <b>UINT64*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, each entry to be filled with the unpadded size in
		/// bytes of a row, of each subresource.
		/// </para>
		/// <para>For example, if a Texture2D resource has a width of 32 and bytes per pixel of 4,</para>
		/// <para>then <i>pRowSizeInBytes</i> returns 128.</para>
		/// <para>
		/// <i>pRowSizeInBytes</i> should not be confused with <b>row pitch</b>, as examining <i>pLayouts</i> and getting the row pitch from
		/// that will give you 256 as it is aligned to D3D12_TEXTURE_DATA_PITCH_ALIGNMENT.
		/// </para>
		/// </param>
		/// <param name="pTotalBytes">
		/// <para>Type: <b>UINT64*</b></para>
		/// <para>A pointer to an integer variable, to be filled with the total size, in bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// This routine assists the application in filling out <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> structures, when suballocating space in upload heaps. The resulting structures are GPU
		/// adapter-agnostic, meaning that the values will not vary from one GPU adapter to the next. <b>GetCopyableFootprints</b> uses
		/// specified details about resource formats, texture layouts, and alignment requirements (from the <c>D3D12_RESOURCE_DESC</c>
		/// structure) to fill out the subresource structures. Applications have access to all these details, so this method, or a variation
		/// of it, could be written as part of the app. Examples The <c>D3D12Multithreading</c> sample uses
		/// <b>ID3D12Device::GetCopyableFootprints</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Returns required size of a buffer to be used for data upload inline UINT64 GetRequiredIntermediateSize( _In_
		/// ID3D12Resource* pDestinationResource, _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		/// _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources) { D3D12_RESOURCE_DESC Desc =
		/// pDestinationResource-&gt;GetDesc(); UINT64 RequiredSize = 0; ID3D12Device* pDevice;
		/// pDestinationResource-&gt;GetDevice(__uuidof(*pDevice), reinterpret_cast&lt;void**&gt;(&amp;pDevice));
		/// pDevice-&gt;GetCopyableFootprints(&amp;Desc, FirstSubresource, NumSubresources, 0, nullptr, nullptr, nullptr,
		/// &amp;RequiredSize); pDevice-&gt;Release(); return RequiredSize; }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcopyablefootprints void GetCopyableFootprints(
		// [in] const D3D12_RESOURCE_DESC *pResourceDesc, [in] UINT FirstSubresource, [in] UINT NumSubresources, UINT64 BaseOffset, [out,
		// optional] D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts, [out, optional] UINT *pNumRows, [out, optional] UINT64 *pRowSizeInBytes,
		// [out, optional] UINT64 *pTotalBytes );
		[PreserveSig]
		new void GetCopyableFootprints(in D3D12_RESOURCE_DESC pResourceDesc, uint FirstSubresource, int NumSubresources, ulong BaseOffset,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_PLACED_SUBRESOURCE_FOOTPRINT[]? pLayouts,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[]? pNumRows,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[]? pRowSizeInBytes,
			out ulong pTotalBytes);

		/// <summary>Creates a query heap. A query heap contains an array of queries.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_QUERY_HEAP_DESC</c>*</b></para>
		/// <para>Specifies the query heap in a <c>D3D12_QUERY_HEAP_DESC</c> structure.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>Specifies a REFIID that uniquely identifies the heap.</para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// Specifies a pointer to the heap, that will be returned on successful completion of the method. <i>ppvHeap</i> can be NULL, to
		/// enable capability testing. When <i>ppvHeap</i> is NULL, no object will be created and S_FALSE will be returned when <i>pDesc</i>
		/// is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Refer to <c>Queries</c> for more information. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12Device::CreateQueryHeap</b> as follows:
		/// </para>
		/// <para>Create a query heap and a query result buffer.</para>
		/// <para>
		/// <c>// Pipeline objects. D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
		/// ComPtr&lt;ID3D12Device&gt; m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
		/// ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocators[FrameCount]; ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
		/// ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature; ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_cbvHeap; ComPtr&lt;ID3D12DescriptorHeap&gt; m_dsvHeap; ComPtr&lt;ID3D12QueryHeap&gt;
		/// m_queryHeap; UINT m_rtvDescriptorSize; UINT m_cbvSrvDescriptorSize; UINT m_frameIndex; // Synchronization objects.
		/// ComPtr&lt;ID3D12Fence&gt; m_fence; UINT64 m_fenceValues[FrameCount]; HANDLE m_fenceEvent; // Asset objects.
		/// ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState; ComPtr&lt;ID3D12PipelineState&gt; m_queryState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; ComPtr&lt;ID3D12Resource&gt; m_vertexBuffer; ComPtr&lt;ID3D12Resource&gt;
		/// m_constantBuffer; ComPtr&lt;ID3D12Resource&gt; m_depthStencil; ComPtr&lt;ID3D12Resource&gt; m_queryResult;
		/// D3D12_VERTEX_BUFFER_VIEW m_vertexBufferView;</c>
		/// </para>
		/// <para>
		/// <c>// Describe and create a heap for occlusion queries. D3D12_QUERY_HEAP_DESC queryHeapDesc = {}; queryHeapDesc.Count = 1;
		/// queryHeapDesc.Type = D3D12_QUERY_HEAP_TYPE_OCCLUSION; ThrowIfFailed(m_device-&gt;CreateQueryHeap(&amp;queryHeapDesc, IID_PPV_ARGS(&amp;m_queryHeap)));</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createqueryheap HRESULT CreateQueryHeap( [in]
		// const D3D12_QUERY_HEAP_DESC *pDesc, REFIID riid, [out, optional] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateQueryHeap(in D3D12_QUERY_HEAP_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>A development-time aid for certain types of profiling and experimental prototyping.</summary>
		/// <param name="Enable">
		/// <para>Type: <b>BOOL</b></para>
		/// <para>Specifies a BOOL that turns the stable power state on or off.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method is only useful during the development of applications. It enables developers to profile GPU usage of multiple
		/// algorithms without experiencing artifacts from <c>dynamic frequency scaling</c>.
		/// </para>
		/// <para>
		/// Do not call this method in normal execution for a shipped application. This method only works while the machine is in
		/// <c>developer mode</c>. If developer mode is not enabled, then device removal will occur. Instead, call this method in response
		/// to an off-by-default, developer-facing switch. Calling it in response to command line parameters, config files, registry keys,
		/// and developer console commands are reasonable usage scenarios.
		/// </para>
		/// <para>
		/// A stable power state typically fixes GPU clock rates at a slower setting that is significantly lower than that experienced by
		/// users under normal application load. This reduction in clock rate affects the entire system. Slow clock rates are required to
		/// ensure processors dont exhaust power, current, and thermal limits. Normal usage scenarios commonly leverage a processors
		/// ability to dynamically over-clock. Any conclusions made by comparing two designs under a stable power state should be
		/// double-checked with supporting results from real usage scenarios.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-setstablepowerstate HRESULT SetStablePowerState(
		// BOOL Enable );
		[PreserveSig]
		new HRESULT SetStablePowerState(bool Enable);

		/// <summary>This method creates a command signature.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_COMMAND_SIGNATURE_DESC</c>*</b></para>
		/// <para>Describes the command signature to be created with the <c>D3D12_COMMAND_SIGNATURE_DESC</c> structure.</para>
		/// </param>
		/// <param name="pRootSignature">
		/// <para>Type: <b><c>ID3D12RootSignature</c>*</b></para>
		/// <para>Specifies the <c>ID3D12RootSignature</c> that the command signature applies to.</para>
		/// <para>
		/// The root signature is required if any of the commands in the signature will update bindings on the pipeline. If the only command
		/// present is a draw or dispatch, the root signature parameter can be set to NULL.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the command signature interface ( <c>ID3D12CommandSignature</c>). The
		/// <b>REFIID</b>, or <b>GUID</b>, of the interface to the command signature can be obtained by using the __uuidof() macro. For
		/// example, __uuidof( <b>ID3D12CommandSignature</b>) will get the <b>GUID</b> of the interface to a command signature.
		/// </para>
		/// </param>
		/// <param name="ppvCommandSignature">
		/// <para>Type: <b>void**</b></para>
		/// <para>Specifies a pointer, that on successful completion of the method will point to the created command signature ( <c>ID3D12CommandSignature</c>).</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandsignature HRESULT
		// CreateCommandSignature( [in] const D3D12_COMMAND_SIGNATURE_DESC *pDesc, [in, optional] ID3D12RootSignature *pRootSignature,
		// REFIID riid, [out, optional] void **ppvCommandSignature );
		[PreserveSig]
		new HRESULT CreateCommandSignature(in D3D12_COMMAND_SIGNATURE_DESC pDesc, [In, Optional] ID3D12RootSignature? pRootSignature,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppvCommandSignature);

		/// <summary>Gets info about how a tiled resource is broken into tiles.</summary>
		/// <param name="pTiledResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies a tiled <c>ID3D12Resource</c> to get info about.</para>
		/// </param>
		/// <param name="pNumTilesForEntireResource">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>A pointer to a variable that receives the number of tiles needed to store the entire tiled resource.</para>
		/// </param>
		/// <param name="pPackedMipDesc">
		/// <para>Type: <b><c>D3D12_PACKED_MIP_INFO</c>*</b></para>
		/// <para>
		/// A pointer to a <c>D3D12_PACKED_MIP_INFO</c> structure that <b>GetResourceTiling</b> fills with info about how the tiled
		/// resource's mipmaps are packed.
		/// </para>
		/// </param>
		/// <param name="pStandardTileShapeForNonPackedMips">
		/// <para>Type: <b><c>D3D12_TILE_SHAPE</c>*</b></para>
		/// <para>
		/// Specifies a <c>D3D12_TILE_SHAPE</c> structure that <b>GetResourceTiling</b> fills with info about the tile shape. This is info
		/// about how pixels fit in the tiles, independent of tiled resource's dimensions, not including packed mipmaps. If the entire tiled
		/// resource is packed, this parameter is meaningless because the tiled resource has no defined layout for packed mipmaps. In this
		/// situation, <b>GetResourceTiling</b> sets the members of D3D12_TILE_SHAPE to zeros.
		/// </para>
		/// </param>
		/// <param name="pNumSubresourceTilings">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>
		/// A pointer to a variable that contains the number of tiles in the subresource. On input, this is the number of subresources to
		/// query tilings for; on output, this is the number that was actually retrieved at <i>pSubresourceTilingsForNonPackedMips</i>
		/// (clamped to what's available).
		/// </para>
		/// </param>
		/// <param name="FirstSubresourceTilingToGet">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// The number of the first subresource tile to get. <b>GetResourceTiling</b> ignores this parameter if the number that
		/// <i>pNumSubresourceTilings</i> points to is 0.
		/// </para>
		/// </param>
		/// <param name="pSubresourceTilingsForNonPackedMips">
		/// <para>Type: <b><c>D3D12_SUBRESOURCE_TILING</c>*</b></para>
		/// <para>
		/// Specifies a <c>D3D12_SUBRESOURCE_TILING</c> structure that <b>GetResourceTiling</b> fills with info about subresource tiles. If
		/// subresource tiles are part of packed mipmaps, <b>GetResourceTiling</b> sets the members of D3D12_SUBRESOURCE_TILING to zeros,
		/// except the <i>StartTileIndexInOverallResource</i> member, which <b>GetResourceTiling</b> sets to D3D12_PACKED_TILE (0xffffffff).
		/// The D3D12_PACKED_TILE constant indicates that the whole <b>D3D12_SUBRESOURCE_TILING</b> structure is meaningless for this
		/// situation, and the info that the <i>pPackedMipDesc</i> parameter points to applies.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// To estimate the total resource size of textures needed when calculating heap sizes and calling <c>CreatePlacedResource</c>, use
		/// <c>GetResourceAllocationInfo</c> instead of <b>GetResourceTiling</b>. <b>GetResourceTiling</b> cannot be used for this.
		/// </para>
		/// <para>For more information on tiled resources, refer to <c>Volume Tiled Resources</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getresourcetiling void GetResourceTiling( [in]
		// ID3D12Resource *pTiledResource, [out, optional] UINT *pNumTilesForEntireResource, [out, optional] D3D12_PACKED_MIP_INFO
		// *pPackedMipDesc, [out, optional] D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips, [in, out, optional] UINT
		// *pNumSubresourceTilings, [in] UINT FirstSubresourceTilingToGet, [out] D3D12_SUBRESOURCE_TILING
		// *pSubresourceTilingsForNonPackedMips );
		[PreserveSig]
		new void GetResourceTiling([In] ID3D12Resource pTiledResource, [Out, Optional] StructPointer<uint> pNumTilesForEntireResource,
			[Out, Optional] StructPointer<D3D12_PACKED_MIP_INFO> pPackedMipDesc, [Out, Optional] StructPointer<D3D12_TILE_SHAPE> pStandardTileShapeForNonPackedMips,
			[In, Out, Optional] StructPointer<uint> pNumSubresourceTilings, uint FirstSubresourceTilingToGet,
			[Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] D3D12_SUBRESOURCE_TILING[] pSubresourceTilingsForNonPackedMips);

		/// <summary>Gets a locally unique identifier for the current device (adapter).</summary>
		/// <returns>
		/// <para>Type: <b><c>LUID</c></b></para>
		/// <para>The locally unique identifier for the adapter.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this
		/// identifier to define robust mappings across various APIs (Direct3D 12, DXGI).
		/// </para>
		/// <para>
		/// A locally unique identifier (LUID) is a 64-bit value that is guaranteed to be unique only on the system on which it was
		/// generated. The uniqueness of a locally unique identifier (LUID) is guaranteed only until the system is restarted.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getadapterluid LUID GetAdapterLuid();
		[PreserveSig]
		new LUID GetAdapterLuid();

		/// <summary>
		/// <para>
		/// Creates a cached pipeline library. For pipeline state objects (PSOs) that are expected to share data together, grouping them
		/// into a library before serializing them means that there's less overhead due to metadata, as well as the opportunity to avoid
		/// redundant or duplicated data being written to disk.
		/// </para>
		/// <para>
		/// You can query for <b>ID3D12PipelineLibrary</b> support with <b><c>ID3D12Device::CheckFeatureSupport</c></b>, with
		/// <b><c>D3D12_FEATURE_SHADER_CACHE</c></b> and <b><c>D3D12_FEATURE_DATA_SHADER_CACHE</c></b>. If the Flags member of
		/// <b><c>D3D12_FEATURE_DATA_SHADER_CACHE</c></b> contains the flag <b><c>D3D12_SHADER_CACHE_SUPPORT_LIBRARY</c></b>, the
		/// <b>ID3D12PipelineLibrary</b> interface is supported. If not, then <b>DXGI_ERROR_NOT_SUPPORTED</b> will always be returned when
		/// this function is called.
		/// </para>
		/// </summary>
		/// <param name="pLibraryBlob">
		/// <para>Type: [in] <b>const void*</b></para>
		/// <para>
		/// If the input library blob is empty, then the initial content of the library is empty. If the input library blob is not empty,
		/// then it is validated for integrity, parsed, and the pointer is stored. The pointer provided as input to this method must remain
		/// valid for the lifetime of the object returned. For efficiency reasons, the data is not copied.
		/// </para>
		/// </param>
		/// <param name="BlobLength">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>Specifies the length of pLibraryBlob in bytes.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// Specifies a unique REFIID for the <c>ID3D12PipelineLibrary</c> object. Typically set this and the following parameter with the
		/// macro <c>IID_PPV_ARGS(&amp;Library)</c>, where <b>Library</b> is the name of the object.
		/// </para>
		/// </param>
		/// <param name="ppPipelineLibrary">
		/// <para>Type: [out] <b>void**</b></para>
		/// <para>Returns a pointer to the created library.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>, including
		/// <b>E_INVALIDARG</b> if the blob is corrupted or unrecognized, <b>D3D12_ERROR_DRIVER_VERSION_MISMATCH</b> if the provided data
		/// came from an old driver or runtime, and <b>D3D12_ERROR_ADAPTER_NOT_FOUND</b> if the data came from different hardware.
		/// </para>
		/// <para>
		/// If you pass <c>nullptr</c> for pPipelineLibrary then the runtime still performs the validation of the blob but avoid creating
		/// the actual library and returns S_FALSE if the library would have been created.
		/// </para>
		/// <para>Also, the feature requires an updated driver, and attempting to use it on old drivers will return DXGI_ERROR_UNSUPPORTED.</para>
		/// </returns>
		/// <remarks>
		/// <para>A pipeline library enables the following operations.</para>
		/// <list type="bullet">
		/// <item>
		/// <description>Adding pipeline state objects (PSOs) to an existing library object (refer to <c>StorePipeline</c>).</description>
		/// </item>
		/// <item>
		/// <description>Serializing a PSO library into a contiguous block of memory for disk storage (refer to <c>Serialize</c>).</description>
		/// </item>
		/// <item>
		/// <description>De-serializing a PSO library from persistent storage (this is handled by <b>CreatePipelineLibrary</b>).</description>
		/// </item>
		/// <item>
		/// <description>Retrieving individual PSOs from the library (refer to <c>LoadComputePipeline</c> and <c>LoadGraphicsPipeline</c>).</description>
		/// </item>
		/// </list>
		/// <para>At no point in the lifecycle of a pipeline library is there duplication between PSOs with identical sub-components.</para>
		/// <para>
		/// A recommended solution for managing the lifetime of the provided pointer while only having to ref-count the returned interface
		/// is to leverage <c>ID3D12Object::SetPrivateDataInterface</c>, and use an object which implements <b>IUnknown</b>, and frees the
		/// memory when the ref-count reaches 0.
		/// </para>
		/// <para>Thread Safety</para>
		/// <para>
		/// The pipeline library is thread-safe to use, and will internally synchronize as necessary, with one exception: multiple threads
		/// loading the same PSO (via <c><b>LoadComputePipeline</b></c>, <c><b>LoadGraphicsPipeline</b></c>, or <c><b>LoadPipeline</b></c>)
		/// should synchronize themselves, as this act may modify the state of that pipeline within the library in a non-thread-safe manner.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-createpipelinelibrary HRESULT
		// CreatePipelineLibrary( const void *pLibraryBlob, SIZE_T BlobLength, REFIID riid, void **ppPipelineLibrary );
		[PreserveSig]
		new HRESULT CreatePipelineLibrary([In] IntPtr pLibraryBlob, [In] SizeT BlobLength, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppPipelineLibrary);

		/// <summary>Specifies an event that should be fired when one or more of a collection of fences reach specific values.</summary>
		/// <param name="ppFences">
		/// <para>Type: <b>ID3D12Fence*</b></para>
		/// <para>An array of length <i>NumFences</i> that specifies the <c>ID3D12Fence</c> objects.</para>
		/// </param>
		/// <param name="pFenceValues">
		/// <para>Type: <b>const UINT64*</b></para>
		/// <para>An array of length <i>NumFences</i> that specifies the fence values required for the event is to be signaled.</para>
		/// </param>
		/// <param name="NumFences">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of fences to be included.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_MULTIPLE_FENCE_WAIT_FLAGS</c></b></para>
		/// <para>Specifies one of the <c>D3D12_MULTIPLE_FENCE_WAIT_FLAGS</c> that determines how to proceed.</para>
		/// </param>
		/// <param name="hEvent">
		/// <para>Type: <b>HANDLE</b></para>
		/// <para>A handle to the event object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns an HRESULT success or error code.</para>
		/// </returns>
		/// <remarks>
		/// <para>To specify a single fence refer to the <c>SetEventOnCompletion</c> method.</para>
		/// <para>If hEvent is a null handle, then this API will not return until the specified fence value(s) have been reached.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-seteventonmultiplefencecompletion HRESULT
		// SetEventOnMultipleFenceCompletion( [in] ID3D12Fence * const *ppFences, [in] const UINT64 *pFenceValues, UINT NumFences,
		// D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags, HANDLE hEvent );
		[PreserveSig]
		new HRESULT SetEventOnMultipleFenceCompletion([In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 2)] ID3D12Fence[] ppFences,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[] pFenceValues, int NumFences, D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
			HEVENT hEvent);

		/// <summary>This method sets residency priorities of a specified list of objects.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of objects in the <i>ppObjects</i> and <i>pPriorities</i> arrays.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b>ID3D12Pageable*</b></para>
		/// <para>Specifies an array, of length <i>NumObjects</i>, containing references to <c>ID3D12Pageable</c> objects.</para>
		/// </param>
		/// <param name="pPriorities">
		/// <para>Type: <b>const <c>D3D12_RESIDENCY_PRIORITY</c>*</b></para>
		/// <para>Specifies an array, of length <i>NumObjects</i>, of <c>D3D12_RESIDENCY_PRIORITY</c> values for the list of objects.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns an HRESULT success or error code.</para>
		/// </returns>
		/// <remarks>For more information, refer to <c>Residency</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority HRESULT
		// SetResidencyPriority( UINT NumObjects, [in] ID3D12Pageable * const *ppObjects, [in] const D3D12_RESIDENCY_PRIORITY *pPriorities );
		[PreserveSig]
		new HRESULT SetResidencyPriority(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_RESIDENCY_PRIORITY[] pPriorities);

		/// <summary>Creates a pipeline state object from a pipeline state stream description.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_PIPELINE_STATE_STREAM_DESC</c>*</b></para>
		/// <para>The address of a <c>D3D12_PIPELINE_STATE_STREAM_DESC</c> structure that describes the pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// </para>
		/// <para>The pipeline state object is an immutable state object. It contains no methods.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// This function takes the pipeline description as a <c>D3D12_PIPELINE_STATE_STREAM_DESC</c> and combines the functionality of the
		/// <c>ID3D12Device::CreateGraphicsPipelineState</c> and <c>ID3D12Device::CreateComputePipelineState</c> functions, which take their
		/// pipeline description as the less-flexible <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c> and <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c>
		/// structs, respectively.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device2-createpipelinestate HRESULT CreatePipelineState(
		// const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreatePipelineState(in D3D12_PIPELINE_STATE_STREAM_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>
		/// Creates a special-purpose diagnostic heap in system memory from an address. The created heap can persist even in the event of a
		/// GPU-fault or device-removed scenario.
		/// </summary>
		/// <param name="pAddress">
		/// <para>Type: <b>const void*</b></para>
		/// <para>The address used to create the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the heap interface ( <c>ID3D12Heap</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the heap can be obtained by using the <b>__uuidof()</b> macro. For
		/// example, <b>__uuidof(ID3D12Heap)</b> will retrieve the <b>GUID</b> of the interface to a heap.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block. On success, the D3D12 runtime will write a pointer to the newly-opened heap into the memory block.
		/// The type of the pointer depends on the provided <b>riid</b> parameter.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to open the existing heap. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>The heap is created in system memory and permits CPU access. It wraps the entire VirtualAlloc region.</para>
		/// <para>
		/// Heaps can be used for placed and reserved resources, as orthogonally as other heaps. Restrictions may still exist based on the
		/// flags that cannot be app-chosen.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-openexistingheapfromaddress HRESULT
		// OpenExistingHeapFromAddress( [in] const void *pAddress, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT OpenExistingHeapFromAddress([In] IntPtr pAddress, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>
		/// Creates a special-purpose diagnostic heap in system memory from a file mapping object. The created heap can persist even in the
		/// event of a GPU-fault or device-removed scenario.
		/// </summary>
		/// <param name="hFileMapping">
		/// <para>Type: <b><c>HANDLE</c></b></para>
		/// <para>The handle to the file mapping object to use to create the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the heap interface ( <c>ID3D12Heap</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the heap can be obtained by using the <b>__uuidof()</b> macro. For
		/// example, <b>__uuidof(ID3D12Heap)</b> will retrieve the <b>GUID</b> of the interface to a heap.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block. On success, the D3D12 runtime will write a pointer to the newly-opened heap into the memory block.
		/// The type of the pointer depends on the provided <b>riid</b> parameter.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to open the existing heap. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>The heap is created in system memory, and it permits CPU access. It wraps the entire VirtualAlloc region.</para>
		/// <para>
		/// Heaps can be used for placed and reserved resources, as orthogonally as other heaps. Restrictions may still exist based on the
		/// flags that cannot be app-chosen.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-openexistingheapfromfilemapping HRESULT
		// OpenExistingHeapFromFileMapping( HANDLE hFileMapping, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT OpenExistingHeapFromFileMapping([In] IntPtr hFileMapping, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>Asynchronously makes objects resident for the device.</summary>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_RESIDENCY_FLAGS</c></b></para>
		/// <para>Controls whether the objects should be made resident if the application is over its memory budget.</para>
		/// </param>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to make resident for the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block; contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>descriptor heaps</description>
		/// </item>
		/// <item>
		/// <description>heaps</description>
		/// </item>
		/// <item>
		/// <description>committed resources</description>
		/// </item>
		/// <item>
		/// <description>query heaps</description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pFenceToSignal">
		/// <para>Type: <b><c>ID3D12Fence</c>*</b></para>
		/// <para>A pointer to the fence used to signal when the work is done.</para>
		/// </param>
		/// <param name="FenceValueToSignal">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>An unsigned 64-bit value signaled to the fence when the work is done.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>EnqueueMakeResident</b> performs the same actions as <c>MakeResident</c>, but does not wait for the resources to be made
		/// resident. Instead, <b>EnqueueMakeResident</b> signals a fence when the work is done.
		/// </para>
		/// <para>
		/// The system will not allow work that references the resources that are being made resident by using <b>EnqueueMakeResident</b>
		/// before its fence is signaled. Instead, calls to this API are guaranteed to signal their corresponding fence in order, so the
		/// same fence can be used from call to call.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-enqueuemakeresident HRESULT EnqueueMakeResident(
		// D3D12_RESIDENCY_FLAGS Flags, UINT NumObjects, [in] ID3D12Pageable * const *ppObjects, [in] ID3D12Fence *pFenceToSignal, UINT64
		// FenceValueToSignal );
		[PreserveSig]
		new HRESULT EnqueueMakeResident(D3D12_RESIDENCY_FLAGS Flags, int NumObjects,
			[MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 1)] ID3D12Pageable[] ppObjects,
			[In] ID3D12Fence pFenceToSignal, ulong FenceValueToSignal);

		/// <summary>Creates a command list in the closed state. Also see <c>ID3D12Device::CreateCommandList</c>.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set a bit to identify the node (the device's
		/// physical adapter) for which to create the command list. Each bit in the mask corresponds to a single node. Only one bit must be
		/// set. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>Specifies the type of command list to create.</para>
		/// </param>
		/// <param name="flags">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_FLAGS</c></b></para>
		/// <para>Specifies creation flags.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the command list interface to return in ppCommandList.</para>
		/// </param>
		/// <param name="ppCommandList">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12CommandList</c> or <c>ID3D12GraphicsCommandList</c>
		/// interface for the command list.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the command list.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createcommandlist1 HRESULT CreateCommandList1(
		// [in] UINT nodeMask, [in] D3D12_COMMAND_LIST_TYPE type, D3D12_COMMAND_LIST_FLAGS flags, [in] REFIID riid, [out] void
		// **ppCommandList );
		[PreserveSig]
		new HRESULT CreateCommandList1(uint nodeMask, D3D12_COMMAND_LIST_TYPE type, D3D12_COMMAND_LIST_FLAGS flags, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppCommandList);

		/// <summary>
		/// <para>
		/// Creates an object that represents a session for content protection. You can then provide that session when you're creating
		/// resource or heap objects, to indicate that they should be protected.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>Memory contents can't be transferred from a protected resource to an unprotected resource.</para>
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_PROTECTED_RESOURCE_SESSION_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_PROTECTED_RESOURCE_SESSION_DESC</b> structure, describing the session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the <c>ID3D12ProtectedResourceSession</c> interface.</para>
		/// </param>
		/// <param name="ppSession">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives an <c>ID3D12ProtectedResourceSession</c> interface pointer to the created session object.
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createprotectedresourcesession HRESULT
		// CreateProtectedResourceSession( [in] const D3D12_PROTECTED_RESOURCE_SESSION_DESC *pDesc, [in] REFIID riid, [out] void **ppSession );
		[PreserveSig]
		new HRESULT CreateProtectedResourceSession(in D3D12_PROTECTED_RESOURCE_SESSION_DESC pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppSession);

		/// <summary>
		/// Creates both a resource and an implicit heap (optionally for a protected session), such that the heap is big enough to contain
		/// the entire resource, and the resource is mapped to the heap. Also see <c>ID3D12Device::CreateCommittedResource</c> for a code example.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createcommittedresource1 HRESULT
		// CreateCommittedResource1( [in] const D3D12_HEAP_PROPERTIES *pHeapProperties, [in] D3D12_HEAP_FLAGS HeapFlags, [in] const
		// D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialResourceState, [in, optional] const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riidResource, [out,
		// optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource1(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 6)] out object? ppvResource);

		/// <summary>
		/// Creates a heap (optionally for a protected session) that can be used with placed resources and reserved resources. Also see <c>ID3D12Device::CreateHeap</c>.
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_HEAP_DESC</b> structure that describes the heap.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// heap should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// <para>A heap with a protected session can't be created with the <c>D3D12_HEAP_FLAG_SHARED_CROSS_ADAPTER</c> flag.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the heap interface to return in ppvHeap.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Heap</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created heap object.</para>
		/// <para>
		/// <paramref name="ppvHeap"/> can be <c>nullptr</c>, to enable capability testing. When ppvHeap is <c>nullptr</c>, no object is
		/// created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the heap.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para><b>CreateHeap1</b> creates a heap that can be used with placed resources and reserved resources.</para>
		/// <para>
		/// Before releasing the final reference on the heap, your application must ensure that the GPU will no longer read or write to this heap.
		/// </para>
		/// <para>
		/// A placed resource object holds a reference on the heap it is created on; but a reserved resource doesn't hold a reference for
		/// each mapping made to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createheap1 HRESULT CreateHeap1( [in] const
		// D3D12_HEAP_DESC *pDesc, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riid, [out, optional] void
		// **ppvHeap );
		[PreserveSig]
		new HRESULT CreateHeap1(in D3D12_HEAP_DESC pDesc, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppvHeap);

		/// <summary>
		/// <para>
		/// Creates a resource (optionally for a protected session) that is reserved, and not yet mapped to any pages in a heap. Also see <c>ID3D12Device::CreateReservedResource</c>.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>Only tiles from heaps created with the same protected resource session can be mapped into a protected reserved resource.</para>
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/>&gt; specifies a value for which clear operations are most optimal. When the created
		/// resource is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or
		/// <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b> flags, you should choose the value with which the clear operation will most
		/// commonly be called. You can call the clear operation with other values, but those operations won't be as efficient as when the
		/// value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreateReservedResource</b> is equivalent to <c>D3D11_RESOURCE_MISC_TILED</c> in Direct3D 11. It creates a resource with
		/// virtual memory only, no backing store.
		/// </para>
		/// <para>You need to map the resource to physical memory (that is, to a heap) using <c>CopyTileMappings</c> and <c>UpdateTileMappings</c>.</para>
		/// <para>
		/// These resource types can only be created when the adapter supports tiled resource tier 1 or greater. The tiled resource tier
		/// defines the behavior of accessing a resource that is not mapped to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createreservedresource1 HRESULT
		// CreateReservedResource1( [in] const D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialState, [in, optional] const
		// D3D12_CLEAR_VALUE *pOptimizedClearValue, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riid,
		// [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource1(in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Gets rich info about the size and alignment of memory required for a collection of resources on this adapter. Also see <c>ID3D12Device::GetResourceAllocationInfo</c>.
		/// </para>
		/// <para>
		/// In addition to the <c>D3D12_RESOURCE_ALLOCATION_INFO</c> returned from the method, this version also returns an array of
		/// <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, which provide additional details for each resource description passed as
		/// input. See the pResourceAllocationInfo1 parameter.
		/// </para>
		/// </summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array. This is also the size (the number of elements in) pResourceAllocationInfo1.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <param name="pResourceAllocationInfo1">
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO1</c>*</b></para>
		/// <para>
		/// An array of <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, containing additional details for each resource description
		/// passed as input. This makes it simpler for your application to allocate a heap for multiple resources, and without manually
		/// computing offsets for where each resource should be placed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When you're using <c>CreatePlacedResource</c>, your application must use <b>GetResourceAllocationInfo</b> in order to understand
		/// the size and alignment characteristics of texture resources. The results of this method vary depending on the particular
		/// adapter, and must be treated as unique to this adapter and driver version.
		/// </para>
		/// <para>
		/// Your application can't use the output of <b>GetResourceAllocationInfo</b> to understand packed mip properties of textures. To
		/// understand packed mip properties of textures, your application must use <c>GetResourceTiling</c>.
		/// </para>
		/// <para>
		/// Texture resource sizes significantly differ from the information returned by <b>GetResourceTiling</b>, because some adapter
		/// architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios. This even
		/// includes textures that have constraints on their texture layouts, or have standardized texture layouts. That extra memory can't
		/// be sparsely mapped nor remapped by an application using <c>CreateReservedResource</c> and <c>UpdateTileMappings</c>, so it isn't
		/// reported by <b>GetResourceTiling</b>.
		/// </para>
		/// <para>
		/// Your application can forgo using <b>GetResourceAllocationInfo</b> for buffer resources (
		/// <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>). Buffers have the same size on all adapters, which is merely the smallest multiple of
		/// 64KB that's greater or equal to <c>D3D12_RESOURCE_DESC::Width</c>.
		/// </para>
		/// <para>
		/// When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used.
		/// For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource, reports differing sizes
		/// based on the order of the array. If the 4MB aligned resource is in the middle, then the resulting <b>Size</b> is 12MB.
		/// Otherwise, the resulting <b>Size</b> is 8MB. The <b>Alignment</b> returned would always be 4MB, because it's the superset of all
		/// alignments in the resource array.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-getresourceallocationinfo1(uint_uint_constd3d12_resource_desc_d3d12_resource_allocation_info1)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo1( [in] UINT visibleMask, [in] UINT numResourceDescs, [in] const
		// D3D12_RESOURCE_DESC *pResourceDescs, [out] D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1 );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo1(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC[] pResourceDescs,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[]? pResourceAllocationInfo1);

		/// <summary>
		/// Creates a lifetime tracker associated with an application-defined callback; the callback receives notifications when the
		/// lifetime of a tracked object is changed.
		/// </summary>
		/// <param name="pOwner">
		/// <para>Type: <b><c>ID3D12LifetimeOwner</c>*</b></para>
		/// <para>A pointer to an <b>ID3D12LifetimeOwner</b> interface representing the application-defined callback.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the interface identifier (IID) of the interface to return in ppvTracker.</para>
		/// </param>
		/// <param name="ppvTracker">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives the requested interface pointer to the created object.</para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createlifetimetracker HRESULT
		// CreateLifetimeTracker( [in] ID3D12LifetimeOwner *pOwner, [in] REFIID riid, [out] void **ppvTracker );
		[PreserveSig]
		new HRESULT CreateLifetimeTracker([In] ID3D12LifetimeOwner pOwner, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvTracker);

		/// <summary>
		/// You can call <b>RemoveDevice</b> to indicate to the Direct3D 12 runtime that the GPU device encountered a problem, and can no
		/// longer be used. Doing so will cause all devices' monitored fences to be signaled. Your application typically doesn't need to
		/// explicitly call <b>RemoveDevice</b>.
		/// </summary>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Because device removal triggers all fences to be signaled to <c>UINT64_MAX</c>, you can create a callback for device removal
		/// using an event.
		/// </para>
		/// <para>
		/// <c>HANDLE deviceRemovedEvent = CreateEventW(NULL, FALSE, FALSE, NULL); assert(deviceRemovedEvent != NULL);
		/// _deviceFence-&gt;SetEventOnCompletion(UINT64_MAX, deviceRemoved); HANDLE waitHandle; RegisterWaitForSingleObject(
		/// &amp;waitHandle, deviceRemovedEvent, OnDeviceRemoved, _device.Get(), // Pass the device as our context INFINITE, // No timeout 0
		/// // No flags ); void OnDeviceRemoved(PVOID context, BOOLEAN) { ID3D12Device* removedDevice = (ID3D12Device*)context; HRESULT
		/// removedReason = removedDevice-&gt;GetDeviceRemovedReason(); // Perform app-specific device removed operation, such as logging or
		/// inspecting DRED output }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-removedevice void RemoveDevice();
		[PreserveSig]
		new void RemoveDevice();

		/// <summary>Queries reflection metadata about available meta commands.</summary>
		/// <param name="pNumMetaCommands">
		/// <para>Type: [in, out] <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a <c>UINT</c> containing the number of meta commands to query for. This field determines the size of the
		/// <i>pDescs</i> array, unless <i>pDescs</i> is <b>nullptr</b>.
		/// </para>
		/// </param>
		/// <param name="pDescs">
		/// <para>Type: [out, optional] <b><c>D3D12_META_COMMAND_DESC</c>*</b></para>
		/// <para>
		/// An optional pointer to an array of <c>D3D12_META_COMMAND_DESC</c> containing the descriptions of the available meta commands.
		/// Pass <c>nullptr</c> to have the number of available meta commands returned in <i>pNumMetaCommands</i>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-enumeratemetacommands HRESULT
		// EnumerateMetaCommands( UINT *pNumMetaCommands, D3D12_META_COMMAND_DESC *pDescs );
		[PreserveSig]
		new HRESULT EnumerateMetaCommands(ref int pNumMetaCommands, [Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_META_COMMAND_DESC[]? pDescs);

		/// <summary>Queries reflection metadata about the parameters of the specified meta command.</summary>
		/// <param name="CommandId">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier (GUID) of the meta command whose parameters you wish to be returned in <i>pParameterDescs</i>.</para>
		/// </param>
		/// <param name="Stage">
		/// <para>Type: <b>D3D12_META_COMMAND_PARAMETER_STAGE</b></para>
		/// <para>
		/// A <c>D3D12_META_COMMAND_PARAMETER_STAGE</c> specifying the stage of the parameters that you wish to be included in the query.
		/// </para>
		/// </param>
		/// <param name="pTotalStructureSizeInBytes">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// An optional pointer to a <c>UINT</c> containing the size of the structure containing the parameter values, which you pass when
		/// creating/initializing/executing the meta command, as appropriate.
		/// </para>
		/// </param>
		/// <param name="pParameterCount">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a <c>UINT</c> containing the number of parameters to query for. This field determines the size of the
		/// <i>pParameterDescs</i> array, unless <i>pParameterDescs</i> is <b>nullptr</b>.
		/// </para>
		/// </param>
		/// <param name="pParameterDescs">
		/// <para>Type: <b>D3D12_META_COMMAND_PARAMETER_DESC*</b></para>
		/// <para>
		/// An optional pointer to an array of <c>D3D12_META_COMMAND_PARAMETER_DESC</c> containing the descriptions of the parameters. Pass
		/// <b>nullptr</b> to have the parameter count returned in <i>pParameterCount</i>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HRESULT</b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-enumeratemetacommandparameters HRESULT
		// EnumerateMetaCommandParameters( [in] REFGUID CommandId, [in] D3D12_META_COMMAND_PARAMETER_STAGE Stage, [out, optional] UINT
		// *pTotalStructureSizeInBytes, [in, out] UINT *pParameterCount, [out, optional] D3D12_META_COMMAND_PARAMETER_DESC *pParameterDescs );
		[PreserveSig]
		new HRESULT EnumerateMetaCommandParameters(in Guid CommandId, D3D12_META_COMMAND_PARAMETER_STAGE Stage, out uint pTotalStructureSizeInBytes,
			ref int pParameterCount, [Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] D3D12_META_COMMAND_PARAMETER_DESC[]? pParameterDescs);

		/// <summary>Creates an instance of the specified meta command.</summary>
		/// <param name="CommandId">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier (GUID) of the meta command that you wish to instantiate.</para>
		/// </param>
		/// <param name="NodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-adapter operation, set this to zero. If there are multiple adapter nodes, set a bit to identify the node (one of the
		/// device's physical adapters) to which the meta command applies. Each bit in the mask corresponds to a single node. Only one bit
		/// must be set. See <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="pCreationParametersData">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>An optional pointer to a constant structure containing the values of the parameters for creating the meta command.</para>
		/// </param>
		/// <param name="CreationParametersDataSizeInBytes">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>A <c>SIZE_T</c> containing the size of the structure pointed to by <i>pCreationParametersData</i>, if set, otherwise 0.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// A reference to the globally unique identifier (GUID) of the interface that you wish to be returned in <i>ppMetaCommand</i>. This
		/// is expected to be the GUID of <c>ID3D12MetaCommand</c>.
		/// </para>
		/// </param>
		/// <param name="ppMetaCommand">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the meta command. This is the address of a pointer to an
		/// <c>ID3D12MetaCommand</c>, representing the meta command created.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HRESULT</b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>DXGI_ERROR_UNSUPPORTED</description>
		/// <description>The current hardware does not support the algorithm being requested</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createmetacommand HRESULT CreateMetaCommand(
		// [in] REFGUID CommandId, [in] UINT NodeMask, [in, optional] const void *pCreationParametersData, [in] SIZE_T
		// CreationParametersDataSizeInBytes, REFIID riid, [out] void **ppMetaCommand );
		[PreserveSig]
		new HRESULT CreateMetaCommand(in Guid CommandId, uint NodeMask, [In, Optional] IntPtr pCreationParametersData, [In] SizeT CreationParametersDataSizeInBytes,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppMetaCommand);

		/// <summary>Creates an <c>ID3D12StateObject</c>.</summary>
		/// <param name="pDesc">The description of the state object to create.</param>
		/// <param name="riid">The GUID of the interface to create. Use <i>__uuidof(ID3D12StateObject)</i>.</param>
		/// <param name="ppStateObject">The returned state object.</param>
		/// <returns>
		/// <para>Returns S_OK if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>E_INVALIDARG if one of the input parameters is invalid.</description>
		/// </item>
		/// <item>
		/// <description>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</description>
		/// </item>
		/// <item>
		/// <description>Possibly other error codes that are described in the <c>Direct3D 12 Return Codes</c> topic.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createstateobject HRESULT CreateStateObject(
		// [in] const D3D12_STATE_OBJECT_DESC *pDesc, REFIID riid, [out] void **ppStateObject );
		[PreserveSig]
		new HRESULT CreateStateObject(in D3D12_STATE_OBJECT_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppStateObject);

		/// <summary>Query the driver for resource requirements to build an acceleration structure.</summary>
		/// <param name="pDesc">
		/// <para>
		/// Description of the acceleration structure build. This structure is shared with <c>BuildRaytracingAccelerationStructure</c>. For
		/// more information, see <c>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS</c>.
		/// </para>
		/// <para>
		/// The implementation is allowed to look at all the CPU parameters in this struct and nested structs. It may not
		/// inspect/dereference any GPU virtual addresses, other than to check to see if a pointer is NULL or not, such as the optional
		/// transform in <c>D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC</c>, without dereferencing it. In other words, the calculation of
		/// resource requirements for the acceleration structure does not depend on the actual geometry data (such as vertex positions),
		/// rather it can only depend on overall properties, such as the number of triangles, number of instances etc.
		/// </para>
		/// </param>
		/// <param name="pInfo">The result of the query (in a <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO</c> structure).</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The input acceleration structure description is the same as what goes into <c>BuildRaytracingAccelerationStructure</c>. The
		/// result of this function lets the application provide the correct amount of output storage and scratch storage to
		/// <b>BuildRaytracingAccelerationStructure</b> given the same geometry.
		/// </para>
		/// <para>
		/// Builds can also be done with the same configuration passed to <b>GetAccelerationStructurePrebuildInfo</b> overall except equal
		/// or smaller counts for the number of geometries/instances or the number of vertices/indices/AABBs in any given geometry. In this
		/// case the storage requirements reported with the original sizes passed to <b>GetRaytracingAccelerationStructurePrebuildInfo</b>
		/// will be valid  the build may actually consume less space but not more. This is handy for app scenarios where having
		/// conservatively large storage allocated for acceleration structures is fine.
		/// </para>
		/// <para>
		/// This method is on the device interface as opposed to command list on the assumption that drivers must be able to calculate
		/// resource requirements for an acceleration structure build from only looking at the CPU-visible portions of the call, without
		/// having to dereference any pointers to GPU memory containing actual vertex data, index data, etc.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-getraytracingaccelerationstructureprebuildinfo
		// void GetRaytracingAccelerationStructurePrebuildInfo( [in] const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS *pDesc,
		// [out] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO *pInfo );
		[PreserveSig]
		new void GetRaytracingAccelerationStructurePrebuildInfo(in D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS pDesc, out D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO pInfo);

		/// <summary>
		/// Reports the compatibility of serialized data, such as a serialized raytracing acceleration structure resulting from a call to
		/// <c>CopyRaytracingAccelerationStructure</c> with mode <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_SERIALIZE</c>, with
		/// the current device/driver.
		/// </summary>
		/// <param name="SerializedDataType">The type of the serialized data. For more information, see <c>D3D12_SERIALIZED_DATA_TYPE</c>.</param>
		/// <param name="pIdentifierToCheck">
		/// Identifier from the header of the serialized data to check with the driver. For more information, see <c>D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER</c>.
		/// </param>
		/// <returns>The returned compatibility status. For more information, see <c>D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS</c>.</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-checkdrivermatchingidentifier
		// D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS CheckDriverMatchingIdentifier( [in] D3D12_SERIALIZED_DATA_TYPE SerializedDataType, [in]
		// const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER *pIdentifierToCheck );
		[PreserveSig]
		new D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS CheckDriverMatchingIdentifier(D3D12_SERIALIZED_DATA_TYPE SerializedDataType,
			in D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER pIdentifierToCheck);

		/// <summary>Sets the mode for driver background processing optimizations.</summary>
		/// <param name="Mode">
		/// <para>Type: <b><c>D3D12_BACKGROUND_PROCESSING_MODE</c></b></para>
		/// <para>The level of dynamic optimization to apply to GPU work that's subsequently submitted.</para>
		/// </param>
		/// <param name="MeasurementsAction">
		/// <para>Type: <b><c>D3D12_MEASUREMENTS_ACTION</c></b></para>
		/// <para>The action to take with the results of earlier workload instrumentation.</para>
		/// </param>
		/// <param name="hEventToSignalUponCompletion">
		/// <para>Type: <b><c>HANDLE</c></b></para>
		/// <para>
		/// An optional handle to signal when the function is complete. For example, if MeasurementsAction is set to
		/// <c>D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS</c>, then hEventToSignalUponCompletion is signaled when all resulting compilations
		/// have finished.
		/// </para>
		/// </param>
		/// <param name="pbFurtherMeasurementsDesired">
		/// <para>Type: <b><c>BOOL</c>*</b></para>
		/// <para>
		/// An optional pointer to a Boolean value. The function sets the value to <c>true</c> to indicate that you should continue
		/// profiling, otherwise, <c>false</c>.
		/// </para>
		/// </param>
		/// <remarks>
		/// <para>
		/// A graphics driver can use idle-priority background CPU threads to dynamically recompile shader programs. That can improve GPU
		/// performance by specializing shader code to better match details of the hardware that it's running on, and/or the context in
		/// which it's being used.
		/// </para>
		/// <para>
		/// As a developer, you don't have to do anything to benefit from this feature (over time, as drivers adopt background processing
		/// optimizations, existing shaders will automatically be tuned more efficiently). But, when you're profiling your code, you'll
		/// probably want to call <b>SetBackgroundProcessingMode</b> to make sure that any driver background processing optimizations have
		/// taken place before you take timing measurements. Here's an example.
		/// </para>
		/// <para>
		/// <c>SetBackgroundProcessingMode( D3D12_BACKGROUND_PROCESSING_MODE_ALLOW_INTRUSIVE_MEASUREMENTS, D3D_MEASUREMENTS_ACTION_KEEP_ALL,
		/// nullptr, nullptr); // Here, prime the system by rendering some typical content. // For example, a level flythrough.
		/// SetBackgroundProcessingMode( D3D12_BACKGROUND_PROCESSING_MODE_ALLOWED, D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS, nullptr,
		/// nullptr); // Here, continue rendering. This time with dynamic optimizations applied. // And then take your measurements.</c>
		/// </para>
		/// <para>
		/// <c>PIX</c> automatically uses <b>SetBackgroundProcessingMode</b>first to prime the system,and then to prevent any further
		/// changes from taking place in the middle of its analysis. PIX waits on an event (to make sure all background shader recompiles
		/// have finished) before it starts taking measurements.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device6-setbackgroundprocessingmode HRESULT
		// SetBackgroundProcessingMode( [in] D3D12_BACKGROUND_PROCESSING_MODE Mode, [in] D3D12_MEASUREMENTS_ACTION MeasurementsAction, [in]
		// HANDLE hEventToSignalUponCompletion, [out] BOOL *pbFurtherMeasurementsDesired );
		[PreserveSig]
		new HRESULT SetBackgroundProcessingMode(D3D12_BACKGROUND_PROCESSING_MODE Mode, D3D12_MEASUREMENTS_ACTION MeasurementsAction,
			[In] HEVENT hEventToSignalUponCompletion, out bool pbFurtherMeasurementsDesired);

		/// <summary>
		/// Incrementally add to an existing state object. This incurs lower CPU overhead than creating a state object from scratch that is
		/// a superset of an existing one (for example, adding a few more shaders).
		/// </summary>
		/// <param name="pAddition">
		/// <para>Type: _In_ <b>const <c>D3D12_STATE_OBJECT_DESC</c>*</b></para>
		/// <para>
		/// Description of state object contents to add to existing state object. To help generate this see the
		/// <b>CD3D12_STATE_OBJECT_DESC</b> helper in class in <c>d3dx12.h</c>.
		/// </para>
		/// </param>
		/// <param name="pStateObjectToGrowFrom">
		/// <para>Type: _In_ <b><c>ID3D12StateObject</c>*</b></para>
		/// <para>Existing state object, which can be in use (for example, active raytracing) during this operation.</para>
		/// <para>The existing state object must not be of type <b>Collection</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: _In_ <b>REFIID</b></para>
		/// <para>Must be the IID of the <c>ID3D12StateObject</c> interface.</para>
		/// </param>
		/// <param name="ppNewStateObject">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>Returned state object.</para>
		/// <para>
		/// Behavior is undefined if shader identifiers are retrieved for new shaders from this call and they are accessed via shader tables
		/// by any already existing or in-flight command list that references some older state object. Use of the new shaders added to the
		/// state object can occur only from commands (such as <b>DispatchRays</b> or <b>ExecuteIndirect</b> calls) recorded in a command
		/// list after the call to <b>AddToStateObject</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <b>S_OK</b> for success. <b>E_INVALIDARG</b>, <b>E_OUTOFMEMORY</b> on failure. The debug layer provides detailed status information.
		/// </returns>
		/// <remarks>For more info, see <c>AddToStateObject</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device7-addtostateobject HRESULT AddToStateObject( const
		// D3D12_STATE_OBJECT_DESC *pAddition, ID3D12StateObject *pStateObjectToGrowFrom, REFIID riid, void **ppNewStateObject );
		[PreserveSig]
		new HRESULT AddToStateObject(in D3D12_STATE_OBJECT_DESC pAddition, [In] ID3D12StateObject pStateObjectToGrowFrom, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppNewStateObject);

		/// <summary>
		/// <para>
		/// <b>CreateProtectedResourceSession1</b> revises the <c><b>ID3D12Device4::CreateProtectedResourceSession</b></c> method with
		/// provision (in the structure passed via the pDesc parameter) for a globally unique identifier ( <b>GUID</b>) that indicates the
		/// type of protected resource session.
		/// </para>
		/// <para>
		/// Calling <b>ID3D12Device4::CreateProtectedResourceSession</b> is equivalent to calling
		/// <b>ID3D12Device7::CreateProtectedResourceSession1</b> with the <b>D3D12_PROTECTED_RESOURCES_SESSION_HARDWARE_PROTECTED</b> GUID.
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_PROTECTED_RESOURCE_SESSION_DESC1</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_PROTECTED_RESOURCE_SESSION_DESC1</b> structure, describing the session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: _In_ <b>REFIID</b></para>
		/// <para>
		/// The GUID of the interface to a protected session. Most commonly, <c>ID3D12ProtectedResourceSession1</c>, although it may be any
		/// <b>GUID</b> for any interface. If the protected session object doesn't support the interface for this <b>GUID</b>, the getter
		/// will return <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppSession">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the session for the given protected session (the specific interface type
		/// returned depends on riid).
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device7-createprotectedresourcesession1 HRESULT
		// CreateProtectedResourceSession1( const D3D12_PROTECTED_RESOURCE_SESSION_DESC1 *pDesc, REFIID riid, void **ppSession );
		[PreserveSig]
		new HRESULT CreateProtectedResourceSession1(in D3D12_PROTECTED_RESOURCE_SESSION_DESC1 pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppSession);

		/// <summary>
		/// <para>
		/// Gets rich info about the size and alignment of memory required for a collection of resources on this adapter. Also see <c>ID3D12Device4::GetResourceAllocationInfo1</c>.
		/// </para>
		/// <para>This version also returns an array of <c>D3D12_RESOURCE_DESC1</c> structures.</para>
		/// </summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array. This is also the size (the number of elements in) pResourceAllocationInfo1.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC1</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <param name="pResourceAllocationInfo1">
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO1</c>*</b></para>
		/// <para>
		/// An array of <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, containing additional details for each resource description
		/// passed as input. This makes it simpler for your application to allocate a heap for multiple resources, and without manually
		/// computing offsets for where each resource should be placed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// </returns>
		/// <remarks>For remarks, see <c>ID3D12Device4::GetResourceAllocationInfo1</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-getresourceallocationinfo2(uint_uint_constd3d12_resource_desc1_d3d12_resource_allocation_info1)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo2( UINT visibleMask, UINT numResourceDescs, const D3D12_RESOURCE_DESC1
		// *pResourceDescs, D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1 );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo2(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC1[] pResourceDescs,
			[Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[] pResourceAllocationInfo1);

		/// <summary>
		/// Creates both a resource and an implicit heap (optionally for a protected session), such that the heap is big enough to contain
		/// the entire resource, and the resource is mapped to the heap. Also see <c>ID3D12Device::CreateCommittedResource</c> for a code example.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: _In_ <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createcommittedresource2 HRESULT
		// CreateCommittedResource2( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC1
		// *pDesc, D3D12_RESOURCE_STATES InitialResourceState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, ID3D12ProtectedResourceSession
		// *pProtectedSession, REFIID riidResource, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource2(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC1 pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 6)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC1</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>
		/// When a resource is created together with a <b>D3D12_HEAP_TYPE_UPLOAD</b> heap, InitialState must be
		/// <b>D3D12_RESOURCE_STATE_GENERIC_READ</b>. When a resource is created together with a <b>D3D12_HEAP_TYPE_READBACK</b> heap,
		/// InitialState must be <b>D3D12_RESOURCE_STATE_COPY_DEST</b>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>See <c>ID3D12Device::CreatePlacedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createplacedresource1 HRESULT
		// CreatePlacedResource1( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC1 *pDesc, D3D12_RESOURCE_STATES
		// InitialState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource1([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC1 pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>For purposes of sampler feedback, creates a descriptor suitable for binding.</summary>
		/// <param name="pTargetedResource">
		/// <para>Type: _In_opt_ <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The targeted resource, such as a texture, to create a descriptor for.</para>
		/// </param>
		/// <param name="pFeedbackResource">
		/// <para>Type: _In_opt_ <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The feedback resource, such as a texture, to create a descriptor for.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: _In_ <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>The CPU descriptor handle.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createsamplerfeedbackunorderedaccessview void
		// CreateSamplerFeedbackUnorderedAccessView( ID3D12Resource *pTargetedResource, ID3D12Resource *pFeedbackResource,
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateSamplerFeedbackUnorderedAccessView([In, Optional] ID3D12Resource? pTargetedResource, [In, Optional] ID3D12Resource? pFeedbackResource,
			D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>
		/// Gets a resource layout that can be copied. Helps your app fill in <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> when suballocating space in upload heaps.
		/// </summary>
		/// <param name="pResourceDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A description of the resource, as a pointer to a <b>D3D12_RESOURCE_DESC1</b> structure.</para>
		/// </param>
		/// <param name="FirstSubresource">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>Index of the first subresource in the resource. The range of valid values is 0 to D3D12_REQ_SUBRESOURCES.</para>
		/// </param>
		/// <param name="NumSubresources">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The number of subresources in the resource. The range of valid values is 0 to (D3D12_REQ_SUBRESOURCES - <i>FirstSubresource</i>).</para>
		/// </param>
		/// <param name="BaseOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset, in bytes, to the resource.</para>
		/// </param>
		/// <param name="pLayouts">
		/// <para>Type: [out, optional] <b><c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c>*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> structures, to be filled
		/// with the description and placement of each subresource.
		/// </para>
		/// </param>
		/// <param name="pNumRows">
		/// <para>Type: [out, optional] <b>UINT*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, to be filled with the number of rows for each subresource.
		/// </para>
		/// </param>
		/// <param name="pRowSizeInBytes">
		/// <para>Type: [out, optional] <b>UINT64*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, each entry to be filled with the unpadded size in
		/// bytes of a row, of each subresource.
		/// </para>
		/// <para>For example, if a Texture2D resource has a width of 32 and bytes per pixel of 4, then <i>pRowSizeInBytes</i> returns 128.</para>
		/// <para>
		/// <i>pRowSizeInBytes</i> should not be confused with <b>row pitch</b>, as examining <i>pLayouts</i> and getting the row pitch from
		/// that will give you 256 as it is aligned to D3D12_TEXTURE_DATA_PITCH_ALIGNMENT.
		/// </para>
		/// </param>
		/// <param name="pTotalBytes">
		/// <para>Type: [out, optional] <b>UINT64*</b></para>
		/// <para>A pointer to an integer variable, to be filled with the total size, in bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>For remarks and examples, see <c>ID3D12Device::GetCopyableFootprints</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-getcopyablefootprints1 void
		// GetCopyableFootprints1( const D3D12_RESOURCE_DESC1 *pResourceDesc, UINT FirstSubresource, UINT NumSubresources, UINT64
		// BaseOffset, D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts, UINT *pNumRows, UINT64 *pRowSizeInBytes, UINT64 *pTotalBytes );
		[PreserveSig]
		new void GetCopyableFootprints1(in D3D12_RESOURCE_DESC1 pResourceDesc, uint FirstSubresource, int NumSubresources, ulong BaseOffset,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_PLACED_SUBRESOURCE_FOOTPRINT[]? pLayouts,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[]? pNumRows,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[]? pRowSizeInBytes, out ulong pTotalBytes);

		/// <summary>
		/// Creates an object that grants access to a shader cache, potentially opening an existing cache or creating a new one.
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_SHADER_CACHE_SESSION_DESC</c>*</b></para>
		/// <para>A <b>D3D12_SHADER_CACHE_SESSION_DESC</b> structure describing the shader cache session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>The globally unique identifier (GUID) for the shader cache session interface.</para>
		/// </param>
		/// <param name="ppvSession">
		/// <para>Type: _COM_Outptr_opt_ <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12ShaderCacheSession</c> interface for the shader cache session.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>DXGI_ERROR_ALREADY_EXISTS</description>
		/// <description>You tried to create a cache with an existing identifier. See <c>D3D12_SHADER_CACHE_SESSION_DESC::Identifier</c>.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-createshadercachesession HRESULT
		// CreateShaderCacheSession( const D3D12_SHADER_CACHE_SESSION_DESC *pDesc, REFIID riid, void **ppvSession );
		[PreserveSig]
		new HRESULT CreateShaderCacheSession(in D3D12_SHADER_CACHE_SESSION_DESC pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvSession);

		/// <summary>
		/// Modifies the behavior of caches used internally by Direct3D or by the driver. <b>ShaderCacheControl</b> may be used only in
		/// developer mode.
		/// </summary>
		/// <param name="Kinds">
		/// <para>Type: <b><c>D3D12_SHADER_CACHE_KIND_FLAGS</c></b></para>
		/// <para>The caches to modify. Any one of these caches may or may not exist.</para>
		/// </param>
		/// <param name="Control">
		/// <para>Type: <b><c>D3D12_SHADER_CACHE_CONTROL_FLAGS</c></b></para>
		/// <para>
		/// The way in which to modify the caches. You can't pass both <b>DISABLE</b> and <b>ENABLE</b> at the same time; and you must pass
		/// at least one flag.
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-shadercachecontrol HRESULT ShaderCacheControl(
		// D3D12_SHADER_CACHE_KIND_FLAGS Kinds, D3D12_SHADER_CACHE_CONTROL_FLAGS Control );
		[PreserveSig]
		new HRESULT ShaderCacheControl(D3D12_SHADER_CACHE_KIND_FLAGS Kinds, D3D12_SHADER_CACHE_CONTROL_FLAGS Control);

		/// <summary>
		/// <para>Creates a command queue with a creator ID.</para>
		/// <para>Also see <c>ID3D12Device::CreateCommandQueue</c>.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_COMMAND_QUEUE_DESC</c>*</b></para>
		/// <para>Specifies a <b>D3D12_COMMAND_QUEUE_DESC</b> that describes the command queue.</para>
		/// </param>
		/// <param name="CreatorID">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>A creator ID. See <b>Remarks</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>The globally unique identifier (GUID) for the command queue interface.</para>
		/// </param>
		/// <param name="ppCommandQueue">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandQueue</c> interface for the command queue.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// Returns <b>E_OUTOFMEMORY</b> if there's insufficient memory to create the command queue; otherwise <b>S_OK</b>. See <c>Direct3D
		/// 12 return codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When multiple components in the same process are sharing a single Direct3D 12 device, often they will end up with separate
		/// workloads on independent command queues. In some hardware implementations, independent queues can run in parallel only with
		/// specific other command queues.
		/// </para>
		/// <para>
		/// Direct3D 12 applies a first-come, first-serve grouping for queues, which might not work well for all application or component
		/// designs. To help inform Direct3D 12's grouping of queues, you can specify a creator ID (which is unique per component) that
		/// restricts the grouping to other queues with the same ID. When possible, a component should choose the same unique ID for all of
		/// its queues. Microsoft has reserved a few well-known creator IDs for use by Microsoft-developed implementations of APIs on top of
		/// Direct3D 12.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-createcommandqueue1 HRESULT CreateCommandQueue1(
		// const D3D12_COMMAND_QUEUE_DESC *pDesc, REFIID CreatorID, REFIID riid, void **ppCommandQueue );
		[PreserveSig]
		new HRESULT CreateCommandQueue1(in D3D12_COMMAND_QUEUE_DESC pDesc, in Guid CreatorID, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppCommandQueue);

		/// <summary>
		/// <para>Creates a committed resource with an initial layout rather than an initial state.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: _In_ <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createcommittedresource3 HRESULT
		// CreateCommittedResource3( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC1
		// *pDesc, D3D12_BARRIER_LAYOUT InitialLayout, const D3D12_CLEAR_VALUE *pOptimizedClearValue, ID3D12ProtectedResourceSession
		// *pProtectedSession, UINT32 NumCastableFormats, const DXGI_FORMAT *pCastableFormats, REFIID riidResource, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource3(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC1 pDesc,
			D3D12_BARRIER_LAYOUT InitialLayout, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, int NumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 6)] DXGI_FORMAT[]? pCastableFormats, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 8)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>See <b>Remarks</b> for <c>ID3D12Device::CreatePlacedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createplacedresource2 HRESULT
		// CreatePlacedResource2( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC1 *pDesc, D3D12_BARRIER_LAYOUT
		// InitialLayout, const D3D12_CLEAR_VALUE *pOptimizedClearValue, UINT32 NumCastableFormats, const DXGI_FORMAT *pCastableFormats,
		// REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource2([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC1 pDesc, D3D12_BARRIER_LAYOUT InitialLayout,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, int NumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 5)] DXGI_FORMAT[] pCastableFormats, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 7)] out object? ppvResource);

		/// <summary>
		/// <para>Creates a resource that is reserved, and not yet mapped to any pages in a heap.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>See <b>Remarks</b> for <c>ID3D12Device.CreateReservedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createreservedresource2 HRESULT
		// CreateReservedResource2( const D3D12_RESOURCE_DESC *pDesc, D3D12_BARRIER_LAYOUT InitialLayout, const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, ID3D12ProtectedResourceSession *pProtectedSession, UINT32 NumCastableFormats, const DXGI_FORMAT
		// *pCastableFormats, [in] REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource2(in D3D12_RESOURCE_DESC pDesc, D3D12_BARRIER_LAYOUT InitialLayout,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession,
			int NumCastableFormats, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] DXGI_FORMAT[]? pCastableFormats,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 7)] out object? ppvResource);

		[PreserveSig]
		new void CreateSampler2(in D3D12_SAMPLER_DESC pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo3(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC1[] pResourceDescs,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] uint[]? pNumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] DXGI_FORMAT[]? ppCastableFormats,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[]? pResourceAllocationInfo1);

		[PreserveSig]
		HRESULT OpenExistingHeapFromAddress1([In] IntPtr pAddress, SizeT size, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppvHeap);
	}

	[ComImport]
	[Guid("5f6e592d-d895-44c2-8e4a-88ad4926d323")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ID3D12Device14 : ID3D12Device13, ID3D12Device12, ID3D12Device11, ID3D12Device10, ID3D12Device9, ID3D12Device8, ID3D12Device7, ID3D12Device6, ID3D12Device5, ID3D12Device4, ID3D12Device3, ID3D12Device2, ID3D12Device1, ID3D12Device, ID3D12Object
	{
		/// <summary>Gets application-defined data from a device object.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> that is associated with the data.</para>
		/// </param>
		/// <param name="pDataSize">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a variable that on input contains the size, in bytes, of the buffer that <i>pData</i> points to, and on output
		/// contains the size, in bytes, of the amount of data that <b>GetPrivateData</b> retrieved.
		/// </para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a memory block that receives the data from the device object if <i>pDataSize</i> points to a value that specifies a
		/// buffer large enough to hold the data.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// If the data returned is a pointer to an <c>IUnknown</c>, or one of its derivative classes, which was previously set by
		/// SetPrivateDataInterface, that interface will have its reference count incremented before the private data is returned.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-getprivatedata HRESULT GetPrivateData( [in]
		// REFGUID guid, [in, out] UINT *pDataSize, [out, optional] void *pData );
		[PreserveSig]
		new HRESULT GetPrivateData(in Guid guid, ref uint pDataSize, [Out, Optional] IntPtr pData);

		/// <summary>Sets application-defined data to a device object and associates that data with an application-defined <b>GUID</b>.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the data.</para>
		/// </param>
		/// <param name="DataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size in bytes of the data.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>
		/// A pointer to a memory block that contains the data to be stored with this device object. If <i>pData</i> is <b>NULL</b>,
		/// <i>DataSize</i> must also be 0, and any data that was previously associated with the <b>GUID</b> specified in <i>guid</i> will
		/// be destroyed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// Rather than using the Direct3D 11 debug object naming scheme of calling <b>ID3D12Object::SetPrivateData</b> using
		/// <b>WKPDID_D3DDebugObjectName</b> with an ASCII name, call <c>ID3D12Object::SetName</c> with a UNICODE name.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedata HRESULT SetPrivateData( [in]
		// REFGUID guid, [in] UINT DataSize, [in, optional] const void *pData );
		[PreserveSig]
		new HRESULT SetPrivateData(in Guid guid, uint DataSize, [In, Optional] IntPtr pData);

		/// <summary>
		/// Associates an <c>IUnknown</c>-derived interface with the device object, and associates that interface with an
		/// application-defined <b>GUID</b>.
		/// </summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the interface.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const <c>IUnknown</c>*</b></para>
		/// <para>
		/// A pointer to the <c>IUnknown</c>-derived interface to be associated with the device object. Its reference count is incremented
		/// when set, and its reference count is decremented when either the <c>ID3D12Object</c> is destroyed, or when the data is
		/// overwritten by calling <c>SetPrivateData</c> or <b>SetPrivateDataInterface</b> with the same <b>GUID</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 return codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedatainterface HRESULT
		// SetPrivateDataInterface( [in] REFGUID guid, [in, optional] const IUnknown *pData );
		[PreserveSig]
		new HRESULT SetPrivateDataInterface(in Guid guid, [In, Optional, MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 0)] object? pData);

		/// <summary>Associates a name with the device object. This name is for use in debug diagnostics and tools.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the device object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>This method takes UNICODE names.</para>
		/// <para>
		/// Note that this is simply a convenience wrapper around <c>ID3D12Object::SetPrivateData</c> with
		/// <b>WKPDID_D3DDebugObjectNameW</b>. Therefore names which are set with <c>SetName</c> can be retrieved with
		/// <c>ID3D12Object::GetPrivateData</c> with the same GUID. Additionally, D3D12 supports narrow strings for names, using the
		/// <b>WKPDID_D3DDebugObjectName</b> GUID directly instead.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setname HRESULT SetName( [in] LPCWSTR Name );
		[PreserveSig]
		new HRESULT SetName([MarshalAs(UnmanagedType.LPWStr)] string Name);

		/// <summary>Reports the number of physical adapters (nodes) that are associated with this device.</summary>
		/// <returns>
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of physical adapters (nodes) that this device has.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getnodecount UINT GetNodeCount();
		[PreserveSig]
		new uint GetNodeCount();

		/// <summary>
		/// <para>Creates a command queue.</para>
		/// <para>Also see <c>ID3D12Device9::CreateCommandQueue1</c>.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_COMMAND_QUEUE_DESC</c>*</b></para>
		/// <para>Specifies a <b>D3D12_COMMAND_QUEUE_DESC</b> that describes the command queue.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier (GUID) for the command queue interface. See <b>Remarks</b>. An input parameter.</para>
		/// </param>
		/// <param name="ppCommandQueue">
		/// <para>Type: [out] <b><b>void</b>**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandQueue</c> interface for the command queue.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the command queue. See <c>Direct3D 12 return
		/// codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the command queue can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12CommandQueue) will get the <b>GUID</b> of the interface to a command queue.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandqueue HRESULT CreateCommandQueue(
		// const D3D12_COMMAND_QUEUE_DESC *pDesc, REFIID riid, void **ppCommandQueue );
		[PreserveSig]
		new HRESULT CreateCommandQueue(in D3D12_COMMAND_QUEUE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppCommandQueue);

		/// <summary>Creates a command allocator object.</summary>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>
		/// A <c>D3D12_COMMAND_LIST_TYPE</c>-typed value that specifies the type of command allocator to create. The type of command
		/// allocator can be the type that records either direct command lists or bundles.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the command allocator interface ( <c>ID3D12CommandAllocator</c>). The
		/// <b>REFIID</b>, or <b>GUID</b>, of the interface to the command allocator can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12CommandAllocator) will get the <b>GUID</b> of the interface to a command allocator.
		/// </para>
		/// </param>
		/// <param name="ppCommandAllocator">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandAllocator</c> interface for the command allocator.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the command allocator. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The device creates command lists from the command allocator. Examples The <c>D3D12Bundles</c> sample uses
		/// <b>ID3D12Device::CreateCommandAllocator</b> as follows:
		/// </para>
		/// <para>
		/// <c>ThrowIfFailed(pDevice-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&amp;m_commandAllocator)));
		/// ThrowIfFailed(pDevice-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_BUNDLE, IID_PPV_ARGS(&amp;m_bundleAllocator)));</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandallocator HRESULT
		// CreateCommandAllocator( [in] D3D12_COMMAND_LIST_TYPE type, REFIID riid, [out] void **ppCommandAllocator );
		[PreserveSig]
		new HRESULT CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE type, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppCommandAllocator);

		/// <summary>Creates a graphics pipeline state object.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c> structure that describes graphics pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>). The <b>REFIID</b>,
		/// or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For example,
		/// __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// The pipeline state object is an immutable state object. It contains no methods.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-creategraphicspipelinestate HRESULT
		// CreateGraphicsPipelineState( [in] const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreateGraphicsPipelineState(in D3D12_GRAPHICS_PIPELINE_STATE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>Creates a compute pipeline state object.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c> structure that describes compute pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>). The <b>REFIID</b>,
		/// or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For example,
		/// __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// The pipeline state object is an immutable state object. It contains no methods.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcomputepipelinestate HRESULT
		// CreateComputePipelineState( [in] const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreateComputePipelineState(in D3D12_COMPUTE_PIPELINE_STATE_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>Creates a command list.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set a bit to identify the node (the device's
		/// physical adapter) for which to create the command list. Each bit in the mask corresponds to a single node. Only one bit must be
		/// set. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>Specifies the type of command list to create.</para>
		/// </param>
		/// <param name="pCommandAllocator">
		/// <para>Type: <b><c>ID3D12CommandAllocator</c>*</b></para>
		/// <para>A pointer to the command allocator object from which the device creates command lists.</para>
		/// </param>
		/// <param name="pInitialState">
		/// <para>Type: <b><c>ID3D12PipelineState</c>*</b></para>
		/// <para>
		/// An optional pointer to the pipeline state object that contains the initial pipeline state for the command list. If it is
		/// <c>nullptr</c>, then the runtime sets a dummy initial pipeline state, so that drivers don't have to deal with undefined state.
		/// The overhead for this is low, particularly for a command list, for which the overall cost of recording the command list likely
		/// dwarfs the cost of a single initial state setting. So there's little cost in not setting the initial pipeline state parameter,
		/// if doing so is inconvenient.
		/// </para>
		/// <para>
		/// For bundles, on the other hand, it might make more sense to try to set the initial state parameter (since bundles are likely
		/// smaller overall, and can be reused frequently).
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the command list interface to return in ppCommandList.</para>
		/// </param>
		/// <param name="ppCommandList">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12CommandList</c> or <c>ID3D12GraphicsCommandList</c>
		/// interface for the command list.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the command list.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>The device creates command lists from the command allocator.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandlist HRESULT CreateCommandList( [in]
		// UINT nodeMask, [in] D3D12_COMMAND_LIST_TYPE type, [in] ID3D12CommandAllocator *pCommandAllocator, [in, optional]
		// ID3D12PipelineState *pInitialState, [in] REFIID riid, [out] void **ppCommandList );
		[PreserveSig]
		new HRESULT CreateCommandList(uint nodeMask, D3D12_COMMAND_LIST_TYPE type, [In] ID3D12CommandAllocator pCommandAllocator, [In, Optional] ID3D12PipelineState? pInitialState,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppCommandList);

		/// <summary>Gets information about the features that are supported by the current graphics driver.</summary>
		/// <param name="Feature">
		/// <para>Type: <b><c>D3D12_FEATURE</c></b></para>
		/// <para>A constant from the <c>D3D12_FEATURE</c> enumeration describing the feature(s) that you want to query for support.</para>
		/// </param>
		/// <param name="pFeatureSupportData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a data structure that corresponds to the value of the <i>Feature</i> parameter. To determine the corresponding data
		/// structure for each constant, see <c>D3D12_FEATURE</c>.
		/// </para>
		/// </param>
		/// <param name="FeatureSupportDataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size of the structure pointed to by the <i>pFeatureSupportData</i> parameter.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// Returns <b>S_OK</b> if successful. Returns <b>E_INVALIDARG</b> if an unsupported data type is passed to the
		/// <i>pFeatureSupportData</i> parameter or if a size mismatch is detected for the <i>FeatureSupportDataSize</i> parameter.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// As a usage example, to check for ray tracing support, specify the <c>D3D12_FEATURE_DATA_D3D12_OPTIONS5</c> structure in the
		/// <i>pFeatureSupportData</i> parameter. When the function completes successfully, access the <i>RaytracingTier</i> field (which
		/// specifies the supported ray tracing tier) of the now-populated <b>D3D12_FEATURE_DATA_D3D12_OPTIONS5</b> structure.
		/// </para>
		/// <para>For more info, see <c>Capability Querying</c>.</para>
		/// <para><c></c><c></c><c></c> Hardware support for DXGI Formats</para>
		/// <para>To view tables of DXGI formats and hardware features, refer to:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 12.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 12.0 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 11.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>DXGI Format Support for Direct3D Feature Level 11.0 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>Hardware Support for Direct3D 10Level9 Formats</c></description>
		/// </item>
		/// <item>
		/// <description><c>Format Support for Direct3D Feature Level 10.1 Hardware</c></description>
		/// </item>
		/// <item>
		/// <description><c>Format Support for Direct3D Feature Level 10.0 Hardware</c></description>
		/// </item>
		/// </list>
		/// <para>Examples</para>
		/// <para>The <c>D3D1211on12</c> sample uses <b>ID3D12Device::CheckFeatureSupport</b> as follows:</para>
		/// <para>
		/// <c>inline UINT8 D3D12GetFormatPlaneCount( _In_ ID3D12Device* pDevice, DXGI_FORMAT Format ) { D3D12_FEATURE_DATA_FORMAT_INFO
		/// formatInfo = {Format}; if (FAILED(pDevice-&gt;CheckFeatureSupport(D3D12_FEATURE_FORMAT_INFO, &amp;formatInfo,
		/// sizeof(formatInfo)))) { return 0; } return formatInfo.PlaneCount; }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport HRESULT CheckFeatureSupport(
		// D3D12_FEATURE Feature, [in, out] void *pFeatureSupportData, UINT FeatureSupportDataSize );
		[PreserveSig]
		new HRESULT CheckFeatureSupport(D3D12_FEATURE Feature, [In, Out] IntPtr pFeatureSupportData, uint FeatureSupportDataSize);

		/// <summary>Creates a descriptor heap object.</summary>
		/// <param name="pDescriptorHeapDesc">
		/// <para>Type: <b>const <c>D3D12_DESCRIPTOR_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DESCRIPTOR_HEAP_DESC</c> structure that describes the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the descriptor heap interface. See Remarks. An input parameter.</para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b><b>void</b>**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the descriptor heap. <i>ppvHeap</i> can be NULL, to enable capability
		/// testing. When <i>ppvHeap</i> is NULL, no object will be created and S_FALSE will be returned when <i>pDescriptorHeapDesc</i> is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the descriptor heap object. See <c>Direct3D
		/// 12 Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the descriptor heap can be obtained by using the __uuidof() macro. For
		/// example, __uuidof( <c>ID3D12DescriptorHeap</c>) will get the <b>GUID</b> of the interface to a descriptor heap. Examples The
		/// <c>D3D12HelloWorld</c> sample uses <b>ID3D12Device::CreateDescriptorHeap</b> as follows:
		/// </para>
		/// <para>Describe and create a render target view (RTV) descriptor heap.</para>
		/// <para>
		/// <c>// Create descriptor heaps. { // Describe and create a render target view (RTV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// rtvHeapDesc = {}; rtvHeapDesc.NumDescriptors = FrameCount; rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; rtvHeapDesc.Flags
		/// = D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;rtvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_rtvHeap))); m_rtvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV); } // Create frame resources. {
		/// CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); // Create a RTV for each frame. for
		/// (UINT n = 0; n &lt; FrameCount; n++) { ThrowIfFailed(m_swapChain-&gt;GetBuffer(n, IID_PPV_ARGS(&amp;m_renderTargets[n])));
		/// m_device-&gt;CreateRenderTargetView(m_renderTargets[n].Get(), nullptr, rtvHandle); rtvHandle.Offset(1, m_rtvDescriptorSize); }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap HRESULT
		// CreateDescriptorHeap( [in] const D3D12_DESCRIPTOR_HEAP_DESC *pDescriptorHeapDesc, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateDescriptorHeap(in D3D12_DESCRIPTOR_HEAP_DESC pDescriptorHeapDesc, in Guid riid, [Out] IntPtr ppvHeap);

		/// <summary>
		/// Gets the size of the handle increment for the given type of descriptor heap. This value is typically used to increment a handle
		/// into a descriptor array by the correct amount.
		/// </summary>
		/// <param name="DescriptorHeapType">
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to get the size of the handle
		/// increment for.
		/// </param>
		/// <returns>Returns the size of the handle increment for the given type of descriptor heap, including any necessary padding.</returns>
		/// <remarks>
		/// <para>
		/// The descriptor size returned by this method is used as one input to the helper structures <c>CD3DX12_CPU_DESCRIPTOR_HANDLE</c>
		/// and <c>CD3DX12_GPU_DESCRIPTOR_HANDLE</c>. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12Device::GetDescriptorHandleIncrementSize</b> as follows:
		/// </para>
		/// <para>
		/// Create the descriptor heap for the resources. The <c>m_rtvDescriptorSize</c> variable stores the render target view descriptor
		/// handle increment size, and is used in the <b>Create frame resources</b> section of the code.
		/// </para>
		/// <para>
		/// <c>// Create descriptor heaps. { // Describe and create a render target view (RTV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// rtvHeapDesc = {}; rtvHeapDesc.NumDescriptors = FrameCount; rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; rtvHeapDesc.Flags
		/// = D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;rtvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_rtvHeap))); // Describe and create a depth stencil view (DSV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// dsvHeapDesc = {}; dsvHeapDesc.NumDescriptors = 1; dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV; dsvHeapDesc.Flags =
		/// D3D12_DESCRIPTOR_HEAP_FLAG_NONE; ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;dsvHeapDesc,
		/// IID_PPV_ARGS(&amp;m_dsvHeap))); // Describe and create a constant buffer view (CBV) descriptor heap. D3D12_DESCRIPTOR_HEAP_DESC
		/// cbvHeapDesc = {}; cbvHeapDesc.NumDescriptors = CbvCountPerFrame * FrameCount; cbvHeapDesc.Type =
		/// D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV; cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
		/// ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;cbvHeapDesc, IID_PPV_ARGS(&amp;m_cbvHeap))); // Describe and create a heap
		/// for occlusion queries. D3D12_QUERY_HEAP_DESC queryHeapDesc = {}; queryHeapDesc.Count = 1; queryHeapDesc.Type =
		/// D3D12_QUERY_HEAP_TYPE_OCCLUSION; ThrowIfFailed(m_device-&gt;CreateQueryHeap(&amp;queryHeapDesc,
		/// IID_PPV_ARGS(&amp;m_queryHeap))); m_rtvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV); m_cbvSrvDescriptorSize =
		/// m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV); } // Create frame resources. {
		/// CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); // Create a RTV and a command
		/// allocator for each frame. for (UINT n = 0; n &lt; FrameCount; n++) { ThrowIfFailed(m_swapChain-&gt;GetBuffer(n,
		/// IID_PPV_ARGS(&amp;m_renderTargets[n]))); m_device-&gt;CreateRenderTargetView(m_renderTargets[n].Get(), nullptr, rtvHandle);
		/// rtvHandle.Offset(1, m_rtvDescriptorSize); ThrowIfFailed(m_device-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT,
		/// IID_PPV_ARGS(&amp;m_commandAllocators[n]))); } }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getdescriptorhandleincrementsize UINT
		// GetDescriptorHandleIncrementSize( [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType );
		[PreserveSig]
		new uint GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType);

		/// <summary>Creates a root signature layout.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single GPU operation, set this to zero. If there are multiple GPU nodes, set bits to identify the nodes (the device's
		/// physical adapters) to which the root signature is to apply. Each bit in the mask corresponds to a single node. Refer to
		/// <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="pBlobWithRootSignature">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>A pointer to the source data for the serialized signature.</para>
		/// </param>
		/// <param name="blobLengthInBytes">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>The size, in bytes, of the block of memory that <i>pBlobWithRootSignature</i> points to.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><b>REFIID</b></b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the root signature interface. See Remarks. An input parameter.</para>
		/// </param>
		/// <param name="ppvRootSignature">
		/// <para>Type: <b><b>void</b>**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the root signature.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// <para>This method returns <b>E_INVALIDARG</b> if the blob that <i>pBlobWithRootSignature</i> points to is invalid.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// If an application procedurally generates a <c>D3D12_ROOT_SIGNATURE_DESC</c> data structure, it must pass a pointer to this
		/// <b>D3D12_ROOT_SIGNATURE_DESC</b> in a call to <c>D3D12SerializeRootSignature</c> to make the serialized form. The application
		/// then passes the serialized form to <i>pBlobWithRootSignature</i> in a call to <b>ID3D12Device::CreateRootSignature</b>.
		/// </para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the root signature layout can be obtained by using the __uuidof() macro.
		/// For example, __uuidof( <c>ID3D12RootSignature</c>) will get the <b>GUID</b> of the interface to a root signature. Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12Device::CreateRootSignature</b> as follows:
		/// </para>
		/// <para>Create an empty root signature.</para>
		/// <para>
		/// <c>CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc; rootSignatureDesc.Init(0, nullptr, 0, nullptr,
		/// D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT); ComPtr&lt;ID3DBlob&gt; signature; ComPtr&lt;ID3DBlob&gt; error;
		/// ThrowIfFailed(D3D12SerializeRootSignature(&amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &amp;signature, &amp;error));
		/// ThrowIfFailed(m_device-&gt;CreateRootSignature(0, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(), IID_PPV_ARGS(&amp;m_rootSignature)));</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrootsignature HRESULT CreateRootSignature(
		// [in] UINT nodeMask, [in] const void *pBlobWithRootSignature, [in] SIZE_T blobLengthInBytes, REFIID riid, [out] void
		// **ppvRootSignature );
		[PreserveSig]
		new HRESULT CreateRootSignature(uint nodeMask, [In] IntPtr pBlobWithRootSignature, [In] SizeT blobLengthInBytes, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppvRootSignature);

		/// <summary>Creates a constant-buffer view for accessing resource data.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_CONSTANT_BUFFER_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_CONSTANT_BUFFER_VIEW_DESC</c> structure that describes the constant-buffer view.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the constant-buffer view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createconstantbufferview void
		// CreateConstantBufferView( [in, optional] const D3D12_CONSTANT_BUFFER_VIEW_DESC *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE
		// DestDescriptor );
		[PreserveSig]
		new void CreateConstantBufferView([In, Optional] StructPointer<D3D12_CONSTANT_BUFFER_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a shader-resource view for accessing data in a resource.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the shader resource.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_SHADER_RESOURCE_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_SHADER_RESOURCE_VIEW_DESC</c> structure that describes the shader-resource view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and for buffers SRVs target a full buffer and are typed (not raw or structured), and for textures SRVs target a full texture,
		/// all mips and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// Describes the CPU descriptor handle that represents the shader-resource view. This handle can be created in a shader-visible or
		/// non-shader-visible descriptor heap.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para><c></c><c></c><c></c> Processing YUV 4:2:0 video formats</para>
		/// <para>
		/// An app must map the luma (Y) plane separately from the chroma (UV) planes. Developers do this by calling
		/// <b>CreateShaderResourceView</b> twice for the same texture and passing in 1-channel and 2-channel formats. Passing in a
		/// 1-channel format compatible with the Y plane maps only the Y plane. Passing in a 2-channel format compatible with the UV planes
		/// (together) maps only the U and V planes as a single resource view.
		/// </para>
		/// <para>
		/// YUV 4:2:0 formats are listed in <c>DXGI_FORMAT</c>. Examples The <c>D3D12nBodyGravity</c> sample uses
		/// <b>ID3D12Device::CreateShaderResourceView</b> as follows:
		/// </para>
		/// <para>Describe and create two shader resource views based on one description.</para>
		/// <para>
		/// <c>D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {}; srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
		/// srvDesc.Format = DXGI_FORMAT_UNKNOWN; srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER; srvDesc.Buffer.FirstElement = 0;
		/// srvDesc.Buffer.NumElements = ParticleCount; srvDesc.Buffer.StructureByteStride = sizeof(Particle); srvDesc.Buffer.Flags =
		/// D3D12_BUFFER_SRV_FLAG_NONE; CD3DX12_CPU_DESCRIPTOR_HANDLE srvHandle0(m_srvUavHeap-&gt;GetCPUDescriptorHandleForHeapStart(),
		/// SrvParticlePosVelo0 + index, m_srvUavDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// srvHandle1(m_srvUavHeap-&gt;GetCPUDescriptorHandleForHeapStart(), SrvParticlePosVelo1 + index, m_srvUavDescriptorSize);
		/// m_device-&gt;CreateShaderResourceView(m_particleBuffer0[index].Get(), &amp;srvDesc, srvHandle0);
		/// m_device-&gt;CreateShaderResourceView(m_particleBuffer1[index].Get(), &amp;srvDesc, srvHandle1);</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createshaderresourceview void
		// CreateShaderResourceView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_SHADER_RESOURCE_VIEW_DESC *pDesc,
		// [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateShaderResourceView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_SHADER_RESOURCE_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a view for unordered accessing.</summary>
		/// <param name="pResource">
		/// <para>Type: [in, optional] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the unordered access.</para>
		/// <para>At least one of <i>pResource</i> or <i>pDesc</i> must be provided.</para>
		/// <para>
		/// A null <i>pResource</i> is used to initialize a null descriptor, which guarantees Direct3D 11-like null binding behavior
		/// (reading 0s, writes are discarded), but must have a valid <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pCounterResource">
		/// <para>Type: [in, optional] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The <c>ID3D12Resource</c> for the counter (if any) associated with the UAV.</para>
		/// <para>
		/// If <i>pCounterResource</i> is not specified, then the <b>CounterOffsetInBytes</b> member of the <c>D3D12_BUFFER_UAV</c>
		/// structure must be 0.
		/// </para>
		/// <para>
		/// If <i>pCounterResource</i> is specified, then there is a counter associated with the UAV, and the runtime performs validation of
		/// the following requirements:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>The <b>StructureByteStride</b> member of the <c>D3D12_BUFFER_UAV</c> structure must be greater than 0.</description>
		/// </item>
		/// <item>
		/// <description>The format must be DXGI_FORMAT_UNKNOWN.</description>
		/// </item>
		/// <item>
		/// <description>The D3D12_BUFFER_UAV_FLAG_RAW flag (a <c>D3D12_BUFFER_UAV_FLAGS</c> enumeration constant) must not be set.</description>
		/// </item>
		/// <item>
		/// <description>Both of the resources ( <i>pResource</i> and <i>pCounterResource</i>) must be buffers.</description>
		/// </item>
		/// <item>
		/// <description>
		/// The <b>CounterOffsetInBytes</b> member of the <c>D3D12_BUFFER_UAV</c> structure must be a multiple of
		/// **D3D12_UAV_COUNTER_PLACEMENT_ALIGNMENT** (4096), and must be within the range of the counter resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description><i>pResource</i> cannot be NULL</description>
		/// </item>
		/// <item>
		/// <description><i>pDesc</i> cannot be NULL.</description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in, optional] <b>const <c>D3D12_UNORDERED_ACCESS_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_UNORDERED_ACCESS_VIEW_DESC</c> structure that describes the unordered-access view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and for buffers UAVs target a full buffer and are typed, and for textures UAVs target the first mip and all array slices. Not
		/// all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the unordered-access view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createunorderedaccessview void
		// CreateUnorderedAccessView( ID3D12Resource *pResource, ID3D12Resource *pCounterResource, const D3D12_UNORDERED_ACCESS_VIEW_DESC
		// *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateUnorderedAccessView([In, Optional] ID3D12Resource? pResource, [In, Optional] ID3D12Resource? pCounterResource,
			[In, Optional] StructPointer<D3D12_UNORDERED_ACCESS_VIEW_DESC> pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a render-target view for accessing resource data.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the render target.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RENDER_TARGET_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_RENDER_TARGET_VIEW_DESC</c> structure that describes the render-target view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and RTVs target the first mip and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the destination where the newly-created render target view will reside.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrendertargetview void
		// CreateRenderTargetView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_RENDER_TARGET_VIEW_DESC *pDesc, [in]
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateRenderTargetView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_RENDER_TARGET_VIEW_DESC> pDesc,
			[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Creates a depth-stencil view for accessing resource data.</summary>
		/// <param name="pResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> object that represents the depth stencil.</para>
		/// <para>
		/// At least one of <i>pResource</i> or <i>pDesc</i> must be provided. A null <i>pResource</i> is used to initialize a null
		/// descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid
		/// <i>pDesc</i> in order to determine the descriptor type.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_DEPTH_STENCIL_VIEW_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DEPTH_STENCIL_VIEW_DESC</c> structure that describes the depth-stencil view.</para>
		/// <para>
		/// A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null
		/// descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless)
		/// and DSVs target the first mip and all array slices. Not all resources support null descriptor initialization.
		/// </para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the depth-stencil view.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createdepthstencilview void
		// CreateDepthStencilView( [in, optional] ID3D12Resource *pResource, [in, optional] const D3D12_DEPTH_STENCIL_VIEW_DESC *pDesc, [in]
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateDepthStencilView([In, Optional] ID3D12Resource? pResource, [In, Optional] StructPointer<D3D12_DEPTH_STENCIL_VIEW_DESC> pDesc,
			[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Create a sampler object that encapsulates sampling information for a texture.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_SAMPLER_DESC</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_SAMPLER_DESC</c> structure that describes the sampler.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap that holds the sampler.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsampler void CreateSampler( [in] const
		// D3D12_SAMPLER_DESC *pDesc, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateSampler(in D3D12_SAMPLER_DESC pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>Copies descriptors from a source to a destination.</summary>
		/// <param name="NumDestDescriptorRanges">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of destination descriptor ranges to copy to.</para>
		/// </param>
		/// <param name="pDestDescriptorRangeStarts">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>An array of <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> objects to copy to.</para>
		/// <para>All the destination and source descriptors must be in heaps of the same <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>.</para>
		/// </param>
		/// <param name="pDestDescriptorRangeSizes">
		/// <para>Type: <b>const <c>UINT</c>*</b></para>
		/// <para>An array of destination descriptor range sizes to copy to.</para>
		/// </param>
		/// <param name="NumSrcDescriptorRanges">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of source descriptor ranges to copy from.</para>
		/// </param>
		/// <param name="pSrcDescriptorRangeStarts">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>An array of <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> objects to copy from.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// All elements in the pSrcDescriptorRangeStarts parameter must be in a non shader-visible descriptor heap. This is because
		/// shader-visible descriptor heaps may be created in <b>WRITE_COMBINE</b> memory or GPU local memory, which is prohibitively slow
		/// to read from. If your application manages descriptor heaps via copying the descriptors required for a given pass or frame from
		/// local "storage" descriptor heaps to the GPU-bound descriptor heap, use shader-opaque heaps for the storage heaps and copy into
		/// the GPU-visible heap as required.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="pSrcDescriptorRangeSizes">
		/// <para>Type: <b>const <c>UINT</c>*</b></para>
		/// <para>An array of source descriptor range sizes to copy from.</para>
		/// </param>
		/// <param name="DescriptorHeapsType">
		/// <para>Type: <b><c>D3D12_DESCRIPTOR_HEAP_TYPE</c></b></para>
		/// <para>
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to copy with. This is required as
		/// different descriptor types may have different sizes.
		/// </para>
		/// <para>Both the source and destination descriptor heaps must have the same type, else the debug layer will emit an error.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// Where applicable, prefer <c><b>ID3D12Device::CopyDescriptorsSimple</b></c> to this method. It can have a better CPU cache miss
		/// rate due to the linear nature of the copy.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-copydescriptors void CopyDescriptors( [in] UINT
		// NumDestDescriptorRanges, [in] const D3D12_CPU_DESCRIPTOR_HANDLE *pDestDescriptorRangeStarts, [in, optional] const UINT
		// *pDestDescriptorRangeSizes, [in] UINT NumSrcDescriptorRanges, [in] const D3D12_CPU_DESCRIPTOR_HANDLE *pSrcDescriptorRangeStarts,
		// [in, optional] const UINT *pSrcDescriptorRangeSizes, [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType );
		[PreserveSig]
		new void CopyDescriptors(int NumDestDescriptorRanges, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_CPU_DESCRIPTOR_HANDLE[] pDestDescriptorRangeStarts,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[]? pDestDescriptorRangeSizes, int NumSrcDescriptorRanges,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] D3D12_CPU_DESCRIPTOR_HANDLE[] pSrcDescriptorRangeStarts,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[]? pSrcDescriptorRangeSizes, D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);

		/// <summary>Copies descriptors from a source to a destination.</summary>
		/// <param name="NumDescriptors">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of descriptors to copy.</para>
		/// </param>
		/// <param name="DestDescriptorRangeStart">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> that describes the destination descriptors to start to copy to.</para>
		/// <para>The destination and source descriptors must be in heaps of the same <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>.</para>
		/// </param>
		/// <param name="SrcDescriptorRangeStart">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b> that describes the source descriptors to start to copy from.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// The SrcDescriptorRangeStart parameter must be in a non shader-visible descriptor heap. This is because shader-visible descriptor
		/// heaps may be created in <b>WRITE_COMBINE</b> memory or GPU local memory, which is prohibitively slow to read from. If your
		/// application manages descriptor heaps via copying the descriptors required for a given pass or frame from local "storage"
		/// descriptor heaps to the GPU-bound descriptor heap, then use shader-opaque heaps for the storage heaps and copy into the
		/// GPU-visible heap as required.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="DescriptorHeapsType">
		/// <para>Type: <b><c>D3D12_DESCRIPTOR_HEAP_TYPE</c></b></para>
		/// <para>
		/// The <c>D3D12_DESCRIPTOR_HEAP_TYPE</c>-typed value that specifies the type of descriptor heap to copy with. This is required as
		/// different descriptor types may have different sizes.
		/// </para>
		/// <para>Both the source and destination descriptor heaps must have the same type, else the debug layer will emit an error.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// Where applicable, prefer this method to <c><b>ID3D12Device::CopyDescriptors</b></c>. It can have a better CPU cache miss rate
		/// due to the linear nature of the copy.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-copydescriptorssimple void CopyDescriptorsSimple(
		// [in] UINT NumDescriptors, [in] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart, [in] D3D12_CPU_DESCRIPTOR_HANDLE
		// SrcDescriptorRangeStart, [in] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType );
		[PreserveSig]
		new void CopyDescriptorsSimple(uint NumDescriptors, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart, [In] D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
			D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType);

		/// <summary>Gets the size and alignment of memory required for a collection of resources on this adapter.</summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// <para>If an error occurs, then <b>D3D12_RESOURCE_ALLOCATION_INFO::SizeInBytes</b> equals <b>UINT64_MAX</b>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When you're using <c>CreatePlacedResource</c>, your application must use <b>GetResourceAllocationInfo</b> in order to understand
		/// the size and alignment characteristics of texture resources. The results of this method vary depending on the particular
		/// adapter, and must be treated as unique to this adapter and driver version.
		/// </para>
		/// <para>
		/// Your application can't use the output of <b>GetResourceAllocationInfo</b> to understand packed mip properties of textures. To
		/// understand packed mip properties of textures, your application must use <c>GetResourceTiling</c>.
		/// </para>
		/// <para>
		/// Texture resource sizes significantly differ from the information returned by <b>GetResourceTiling</b>, because some adapter
		/// architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios. This even
		/// includes textures that have constraints on their texture layouts, or have standardized texture layouts. That extra memory can't
		/// be sparsely mapped nor remapped by an application using <c>CreateReservedResource</c> and <c>UpdateTileMappings</c>, so it isn't
		/// reported by <b>GetResourceTiling</b>.
		/// </para>
		/// <para>
		/// Your application can forgo using <b>GetResourceAllocationInfo</b> for buffer resources (
		/// <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>). Buffers have the same size on all adapters, which is merely the smallest multiple of
		/// 64KB that's greater or equal to <c>D3D12_RESOURCE_DESC::Width</c>.
		/// </para>
		/// <para>
		/// When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used.
		/// For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource, reports differing sizes
		/// based on the order of the array. If the 4MB aligned resource is in the middle, then the resulting <b>Size</b> is 12MB.
		/// Otherwise, the resulting <b>Size</b> is 8MB. The <b>Alignment</b> returned would always be 4MB, because it's the superset of all
		/// alignments in the resource array.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getresourceallocationinfo(uint_uint_constd3d12_resource_desc)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo( [in] UINT visibleMask, [in] UINT numResourceDescs, [in] const
		// D3D12_RESOURCE_DESC *pResourceDescs );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_RESOURCE_DESC[] pResourceDescs);

		/// <summary>
		/// Divulges the equivalent custom heap properties that are used for non-custom heap types, based on the adapter's architectural properties.
		/// </summary>
		/// <param name="nodeMask">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the device's
		/// physical adapter). Each bit in the mask corresponds to a single node. Only 1 bit must be set. See <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="heapType">
		/// <para>Type: <b><c>D3D12_HEAP_TYPE</c></b></para>
		/// <para>
		/// A <c>D3D12_HEAP_TYPE</c>-typed value that specifies the heap to get properties for. D3D12_HEAP_TYPE_CUSTOM is not supported as a
		/// parameter value.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_HEAP_PROPERTIES</c></b></para>
		/// <para>
		/// Returns a <c>D3D12_HEAP_PROPERTIES</c> structure that provides properties for the specified heap. The <b>Type</b> member of the
		/// returned D3D12_HEAP_PROPERTIES is always D3D12_HEAP_TYPE_CUSTOM.
		/// </para>
		/// <para>When <c>D3D12_FEATURE_DATA_ARCHITECTURE</c>::UMA is FALSE, the returned D3D12_HEAP_PROPERTIES members convert as follows:</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_COMBINE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L1.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// <para></para>
		/// <para>
		/// When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is FALSE, the returned
		/// D3D12_HEAP_PROPERTIES members convert as follows:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_COMBINE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// <para></para>
		/// <para>
		/// When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is TRUE, the returned
		/// D3D12_HEAP_PROPERTIES members convert as follows:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Heap Type</description>
		/// <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
		/// </listheader>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_UPLOAD</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_DEFAULT</description>
		/// <description><b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// <item>
		/// <description>D3D12_HEAP_TYPE_READBACK</description>
		/// <description><b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcustomheapproperties(uint_d3d12_heap_type)
		// D3D12_HEAP_PROPERTIES GetCustomHeapProperties( [in] UINT nodeMask, D3D12_HEAP_TYPE heapType );
		[PreserveSig]
		new D3D12_HEAP_PROPERTIES GetCustomHeapProperties(uint nodeMask, D3D12_HEAP_TYPE heapType);

		/// <summary>
		/// Creates both a resource and an implicit heap, such that the heap is big enough to contain the entire resource, and the resource
		/// is mapped to the heap.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource HRESULT
		// CreateCommittedResource( [in] const D3D12_HEAP_PROPERTIES *pHeapProperties, [in] D3D12_HEAP_FLAGS HeapFlags, [in] const
		// D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialResourceState, [in, optional] const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, [in] REFIID riidResource, [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>Creates a heap that can be used with placed resources and reserved resources.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_HEAP_DESC</b> structure that describes the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the heap interface to return in ppvHeap.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Heap</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// An optional pointer to a memory block that receives the requested interface pointer to the created heap object. <paramref
		/// name="ppvHeap"/> can be <c>nullptr</c>, to enable capability testing. When ppvHeap is <c>nullptr</c>, no object is created, and
		/// <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the heap.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para><b>CreateHeap</b> creates a heap that can be used with placed resources and reserved resources.</para>
		/// <para>
		/// Before releasing the final reference on the heap, your application must ensure that the GPU will no longer read or write to this heap.
		/// </para>
		/// <para>
		/// A placed resource object holds a reference on the heap it is created on; but a reserved resource doesn't hold a reference for
		/// each mapping made to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createheap HRESULT CreateHeap( [in] const
		// D3D12_HEAP_DESC *pDesc, [in] REFIID riid, [out, optional] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateHeap(in D3D12_HEAP_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>
		/// When a resource is created together with a <b>D3D12_HEAP_TYPE_UPLOAD</b> heap, InitialState must be
		/// <b>D3D12_RESOURCE_STATE_GENERIC_READ</b>. When a resource is created together with a <b>D3D12_HEAP_TYPE_READBACK</b> heap,
		/// InitialState must be <b>D3D12_RESOURCE_STATE_COPY_DEST</b>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreatePlacedResource</b> is similar to fully mapping a reserved resource to an offset within a heap; but the virtual address
		/// space associated with a heap may be reused as well.
		/// </para>
		/// <para>
		/// Placed resources are lighter weight to create and destroy than committed resources are. This is because no heap is created nor
		/// destroyed during those operations. In addition, placed resources enable an even lighter weight technique to reuse memory than
		/// resource creation and destructionthat is, reuse through aliasing, and aliasing barriers. Multiple placed resources may
		/// simultaneously overlap each other on the same heap, but only a single overlapping resource can be used at a time.
		/// </para>
		/// <para>
		/// There are two placed resource usage semanticsa simple model, and an advanced model. We recommend that you choose the simple
		/// model (it maximizes graphics tool support across the diverse ecosystem of GPUs), unless and until you find that you need the
		/// advanced model for your app.
		/// </para>
		/// <para>Simple model</para>
		/// <para>
		/// In this model, you can consider a placed resource to be in one of two states: active, or inactive. It's invalid for the GPU to
		/// either read or write from an inactive resource. Placed resources are created in the inactive state.
		/// </para>
		/// <para>
		/// To activate a resource with an aliasing barrier on a command list, your application must pass the resource in
		/// <c><b>D3D12_RESOURCE_ALIASING_BARRIER::pResourceAfter</b></c>. <b>pResourceBefore</b> can be left NULL during an activation. All
		/// resources that share physical memory with the activated resource now become inactive, which includes overlapping placed and
		/// reserved resources.
		/// </para>
		/// <para>Aliasing barriers should be grouped up and submitted together, in order to maximize efficiency.</para>
		/// <para>
		/// After activation, resources with either the render target or depth stencil flags must be further initialized. See the notes on
		/// the required resource initialization below.
		/// </para>
		/// <para>Notes on the required resource initialization</para>
		/// <para>
		/// Certain resource types still require initialization. Resources with either the render target or depth stencil flags must be
		/// initialized with either a clear operation or a collection of full subresource copies. If an aliasing barrier was used to denote
		/// the transition between two aliased resources, the initialization must occur after the aliasing barrier. This initialization is
		/// still required whenever a resource would've been activated in the simple model.
		/// </para>
		/// <para>
		/// Placed and reserved resources with either the render target or depth stencil flags must be initialized with one of the following
		/// operations before other operations are supported.
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>A Clear operation; for example <c>ClearRenderTargetView</c> or <c>ClearDepthStencilView</c>.</description>
		/// </item>
		/// <item>
		/// <description>A <c>DiscardResource</c> operation.</description>
		/// </item>
		/// <item>
		/// <description>A Copy operation; for example <c>CopyBufferRegion</c>, <c>CopyTextureRegion</c>, or <c>CopyResource</c>.</description>
		/// </item>
		/// </list>
		/// <para>
		/// Applications should prefer the most explicit operation that results in the least amount of texels modified. Consider the
		/// following examples.
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// Using a depth buffer to solve pixel visibility typically requires each depth texel start out at 1.0 or 0. Therefore, a Clear
		/// operation should be the most efficient option for aliased depth buffer initialization.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// An application may use an aliased render target as a destination for tone mapping. Since the application will render over every
		/// pixel during the tone mapping, <c>DiscardResource</c> should be the most efficient option for initialization.
		/// </description>
		/// </item>
		/// </list>
		/// <para>Advanced model</para>
		/// <para>In this model, you can ignore the active/inactive state abstraction. Instead, you must honor these lower-level rules.</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// An aliasing barrier must be between two different GPU resource accesses of the same physical memory, as long as those accesses
		/// are within the same <c>ExecuteCommandLists</c> call.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// The first rendering operation to certain types of aliased resource must still be an initialization, just like the simple model.
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// Initialization operations must occur either on an entire subresource, or on a 64KB granularity. An entire subresource
		/// initialization is supported for all resource types. A 64KB initialization granularity, aligned at a 64KB offset, is supported
		/// for buffers and textures with either the 64KB_UNDEFINED_SWIZZLE or 64KB_STANDARD_SWIZZLE texture layout (refer to <c>D3D12_TEXTURE_LAYOUT</c>).
		/// </para>
		/// <para>Notes on the aliasing barrier</para>
		/// <para>
		/// The aliasing barrier may set NULL for both pResourceAfter and pResourceBefore. The memory coherence definition of
		/// <c><b>ExecuteCommandLists</b></c> and an aliasing barrier are the same, such that two aliased accesses to the same physical
		/// memory need no aliasing barrier when the accesses are in two different <b>ExecuteCommandLists</b> invocations.
		/// </para>
		/// <para>
		/// For D3D12 advanced usage models, the synchronization definition of <c><b>ExecuteCommandLists</b></c> is equivalent to an
		/// aliasing barrier. Therefore, applications may either insert an aliasing barrier between reusing physical memory, or ensure the
		/// two aliased usages of physical memory occurs in two separate calls to <b>ExecuteCommandLists</b>.
		/// </para>
		/// <para>
		/// The amount of inactivation varies based on resource properties. Textures with undefined memory layouts are the worst case, as
		/// the entire texture must be inactivated atomically. For two overlapping resources with defined layouts, inactivation can result
		/// in only the overlapping aligned regions of a resource. Data inheritance can even be well-defined. For more details, see
		/// <c>Memory aliasing and data inheritance</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource HRESULT
		// CreatePlacedResource( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC *pDesc, D3D12_RESOURCE_STATES InitialState,
		// const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>Creates a resource that is reserved, and not yet mapped to any pages in a heap.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreateReservedResource</b> is equivalent to <c>D3D11_RESOURCE_MISC_TILED</c> in Direct3D 11. It creates a resource with
		/// virtual memory only, no backing store.
		/// </para>
		/// <para>You need to map the resource to physical memory (that is, to a heap) using <c>CopyTileMappings</c> and <c>UpdateTileMappings</c>.</para>
		/// <para>
		/// These resource types can only be created when the adapter supports tiled resource tier 1 or greater. The tiled resource tier
		/// defines the behavior of accessing a resource that is not mapped to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createreservedresource HRESULT
		// CreateReservedResource( [in] const D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialState, [in, optional] const
		// D3D12_CLEAR_VALUE *pOptimizedClearValue, [in] REFIID riid, [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource(in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppvResource);

		/// <summary>Creates a shared handle to a heap, resource, or fence object.</summary>
		/// <param name="pObject">
		/// <para>Type: <b><c>ID3D12DeviceChild</c>*</b></para>
		/// <para>
		/// A pointer to the <c>ID3D12DeviceChild</c> interface that represents the heap, resource, or fence object to create for sharing.
		/// The following interfaces (derived from <b>ID3D12DeviceChild</b>) are supported:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pAttributes">
		/// <para>Type: <b>const <c>SECURITY_ATTRIBUTES</c>*</b></para>
		/// <para>
		/// A pointer to a <c>SECURITY_ATTRIBUTES</c> structure that contains two separate but related data members: an optional security
		/// descriptor, and a <b>Boolean</b> value that determines whether child processes can inherit the returned handle.
		/// </para>
		/// <para>
		/// Set this parameter to <b>NULL</b> if you want child processes that the application might create to not inherit the handle
		/// returned by <b>CreateSharedHandle</b>, and if you want the resource that is associated with the returned handle to get a default
		/// security descriptor.
		/// </para>
		/// <para>
		/// The <b>lpSecurityDescriptor</b> member of the structure specifies a <c>SECURITY_DESCRIPTOR</c> for the resource. Set this member
		/// to <b>NULL</b> if you want the runtime to assign a default security descriptor to the resource that is associated with the
		/// returned handle. The ACLs in the default security descriptor for the resource come from the primary or impersonation token of
		/// the creator. For more info, see <c>Synchronization Object Security and Access Rights</c>.
		/// </para>
		/// </param>
		/// <param name="Access">
		/// <para>Type: <b><c>DWORD</c></b></para>
		/// <para>Currently the only value this parameter accepts is GENERIC_ALL.</para>
		/// </param>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>
		/// A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the shared heap. The name is limited to
		/// MAX_PATH characters. Name comparison is case-sensitive.
		/// </para>
		/// <para>
		/// If <i>Name</i> matches the name of an existing resource, <b>CreateSharedHandle</b> fails with
		/// <c>DXGI_ERROR_NAME_ALREADY_EXISTS</c>. This occurs because these objects share the same namespace.
		/// </para>
		/// <para>
		/// The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder
		/// of the name can contain any character except the backslash character (\). For more information, see <c>Kernel Object
		/// Namespaces</c>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the
		/// guidelines outlined for Terminal Services so that applications can support multiple users.
		/// </para>
		/// <para>The object can be created in a private namespace. For more information, see <c>Object Namespaces</c>.</para>
		/// </param>
		/// <param name="pHandle">
		/// <para>Type: <b><c>HANDLE</c>*</b></para>
		/// <para>
		/// A pointer to a variable that receives the NT HANDLE value to the resource to share. You can use this handle in calls to access
		/// the resource.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns S_OK if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>DXGI_ERROR_INVALID_CALL</c> if one of the parameters is invalid.</description>
		/// </item>
		/// <item>
		/// <description>
		/// <c>DXGI_ERROR_NAME_ALREADY_EXISTS</c> if the supplied name of the resource to share is already associated with another resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description>E_ACCESSDENIED if the object is being created in a protected namespace.</description>
		/// </item>
		/// <item>
		/// <description>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</description>
		/// </item>
		/// <item>
		/// <description>Possibly other error codes that are described in the <c>Direct3D 12 Return Codes</c> topic.</description>
		/// </item>
		/// </list>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Both heaps and committed resources can be shared. Sharing a committed resource shares the implicit heap along with the committed
		/// resource description, such that a compatible resource description can be mapped to the heap from another device.
		/// </para>
		/// <para>
		/// For Direct3D 11 and Direct3D 12 interop scenarios, a shared fence is opened in DirectX 11 with the
		/// <c>ID3D11Device5::OpenSharedFence</c> method, and a shared resource is opened with the <c>ID3D11Device::OpenSharedResource1</c> method.
		/// </para>
		/// <para>
		/// For Direct3D 12, a shared handle is opened with the <c>ID3D12Device::OpenSharedHandle</c> or the
		/// ID3D12Device::OpenSharedHandleByName method.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle HRESULT CreateSharedHandle(
		// [in] ID3D12DeviceChild *pObject, [in, optional] const SECURITY_ATTRIBUTES *pAttributes, DWORD Access, [in, optional] LPCWSTR
		// Name, [out] HANDLE *pHandle );
		[PreserveSig]
		new HRESULT CreateSharedHandle([In] ID3D12DeviceChild pObject, [In, Optional] SECURITY_ATTRIBUTES? pAttributes, ACCESS_MASK Access,
			[Optional, MarshalAs(UnmanagedType.LPWStr)] string? Name, out HANDLE pHandle);

		/// <summary>Opens a handle for shared resources, shared heaps, and shared fences, by using HANDLE and REFIID.</summary>
		/// <param name="NTHandle">
		/// <para>Type: <b>HANDLE</b></para>
		/// <para>The handle that was output by the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for one of the following interfaces:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// <para>
		/// The REFIID , or GUID , of the interface can be obtained by using the __uuidof() macro. For example, __uuidof(ID3D12Heap) will
		/// get the GUID of the interface to a resource.
		/// </para>
		/// </param>
		/// <param name="ppvObj">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to one of the following interfaces:</para>
		/// <list type="bullet">
		/// <item>
		/// <description><c>ID3D12Heap</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Resource</c></description>
		/// </item>
		/// <item>
		/// <description><c>ID3D12Fence</c></description>
		/// </item>
		/// </list>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-opensharedhandle HRESULT OpenSharedHandle( [in]
		// HANDLE NTHandle, REFIID riid, [out, optional] void **ppvObj );
		[PreserveSig]
		new HRESULT OpenSharedHandle(HANDLE NTHandle, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvObj);

		/// <summary>Opens a handle for shared resources, shared heaps, and shared fences, by using Name and Access.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>The name that was optionally passed as the <i>Name</i> parameter in the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="Access">
		/// <para>Type: <b>DWORD</b></para>
		/// <para>The access level that was specified in the <i>Access</i> parameter in the call to <c>ID3D12Device::CreateSharedHandle</c>.</para>
		/// </param>
		/// <param name="pNTHandle">
		/// <para>Type: <b>HANDLE*</b></para>
		/// <para>Pointer to the shared handle.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-opensharedhandlebyname HRESULT
		// OpenSharedHandleByName( [in] LPCWSTR Name, DWORD Access, [out] HANDLE *pNTHandle );
		[PreserveSig]
		new HRESULT OpenSharedHandleByName([MarshalAs(UnmanagedType.LPWStr)] string Name, ACCESS_MASK Access, out HANDLE pNTHandle);

		/// <summary>Makes objects resident for the device.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to make resident for the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block that contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>
		/// Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following
		/// objects: Descriptor Heaps, Heaps, Committed Resources, and Query Heaps
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>MakeResident</b> loads the data associated with a resource from disk, and re-allocates the memory from the resource's
		/// appropriate memory pool. This method should be called on the object which owns the physical memory.
		/// </para>
		/// <para>
		/// Use this method, and <c>Evict</c>, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to
		/// be done by the app in D3D12.
		/// </para>
		/// <para>
		/// <b>MakeResident</b> and <c>Evict</c> can help applications manage the residency budget on many adapters. <b>MakeResident</b>
		/// explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <b>Evict</b> enables page-out.
		/// </para>
		/// <para>
		/// Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use
		/// <c>D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT</c> and <c>IDXGIAdapter3::QueryVideoMemoryInfo</c> to recognize when the
		/// maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the
		/// residency budget will always be constrained by the amount of GPU virtual address space. <c>Evict</c> will not free-up any
		/// residency budget on such systems.
		/// </para>
		/// <para>
		/// Applications must handle <b>MakeResident</b> failures, even if there appears to be enough residency budget available. Physical
		/// memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications
		/// should free up more residency budget before trying again.
		/// </para>
		/// <para>
		/// <b>MakeResident</b> is ref-counted, such that <c>Evict</c> must be called the same amount of times as <b>MakeResident</b> before
		/// <b>Evict</b> takes effect. Objects that support residency are made resident during creation, so a single <b>Evict</b> call will
		/// actually evict the object.
		/// </para>
		/// <para>
		/// Applications must use fences to ensure the GPU doesn't use non-resident objects. <b>MakeResident</b> must return before the GPU
		/// executes a command list that references the object. <c>Evict</c> must be called after the GPU finishes executing a command list
		/// that references the object.
		/// </para>
		/// <para>
		/// Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource
		/// descriptors and other GPU virtual address references are not invalidated after <c>Evict</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-makeresident HRESULT MakeResident( UINT
		// NumObjects, [in] ID3D12Pageable * const *ppObjects );
		[PreserveSig]
		new HRESULT MakeResident(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects);

		/// <summary>Enables the page-out of data, which precludes GPU access of that data.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to evict from the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block that contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>
		/// Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following
		/// objects: Descriptor Heaps, Heaps, Committed Resources, and Query Heaps
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>Evict</b> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it
		/// was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns
		/// both virtual and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed
		/// resources are borrowing memory from a heap.
		/// </para>
		/// <para>Refer to the remarks for <c>MakeResident</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-evict HRESULT Evict( UINT NumObjects, [in]
		// ID3D12Pageable * const *ppObjects );
		[PreserveSig]
		new HRESULT Evict(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects);

		/// <summary>Creates a fence object.</summary>
		/// <param name="InitialValue">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>The initial value for the fence.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_FENCE_FLAGS</c></b></para>
		/// <para>
		/// A combination of <c>D3D12_FENCE_FLAGS</c>-typed values that are combined by using a bitwise OR operation. The resulting value
		/// specifies options for the fence.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the fence interface ( <c>ID3D12Fence</c>). The <b>REFIID</b>, or <b>GUID</b>,
		/// of the interface to the fence can be obtained by using the __uuidof() macro. For example, __uuidof(ID3D12Fence) will get the
		/// <b>GUID</b> of the interface to a fence.
		/// </para>
		/// </param>
		/// <param name="ppFence">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12Fence</c> interface that is used to access the fence.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createfence HRESULT CreateFence( UINT64
		// InitialValue, D3D12_FENCE_FLAGS Flags, REFIID riid, [out] void **ppFence );
		[PreserveSig]
		new HRESULT CreateFence(ulong InitialValue, D3D12_FENCE_FLAGS Flags, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppFence);

		/// <summary>
		/// Gets the reason that the device was removed, or <b>S_OK</b> if the device isn't removed. To be called back when a device is
		/// removed, consider using <c>ID3D12Fence::SetEventOnCompletion</c> with a value of <b>UINT64_MAX</b>. That's because device
		/// removal causes all fences to be signaled to that value (which also implies completing all events waited on, because they'll all
		/// be less than <b>UINT64_MAX</b>).
		/// </summary>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns the reason that the device was removed.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getdeviceremovedreason HRESULT GetDeviceRemovedReason();
		[PreserveSig]
		new HRESULT GetDeviceRemovedReason();

		/// <summary>
		/// Gets a resource layout that can be copied. Helps the app fill-in <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> when suballocating space in upload heaps.
		/// </summary>
		/// <param name="pResourceDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A description of the resource, as a pointer to a <c>D3D12_RESOURCE_DESC</c> structure.</para>
		/// </param>
		/// <param name="FirstSubresource">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Index of the first subresource in the resource. The range of valid values is 0 to D3D12_REQ_SUBRESOURCES.</para>
		/// </param>
		/// <param name="NumSubresources">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of subresources in the resource. The range of valid values is 0 to (D3D12_REQ_SUBRESOURCES - <i>FirstSubresource</i>).</para>
		/// </param>
		/// <param name="BaseOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset, in bytes, to the resource.</para>
		/// </param>
		/// <param name="pLayouts">
		/// <para>Type: <b><c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c>*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> structures, to be filled
		/// with the description and placement of each subresource.
		/// </para>
		/// </param>
		/// <param name="pNumRows">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, to be filled with the number of rows for each subresource.
		/// </para>
		/// </param>
		/// <param name="pRowSizeInBytes">
		/// <para>Type: <b>UINT64*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, each entry to be filled with the unpadded size in
		/// bytes of a row, of each subresource.
		/// </para>
		/// <para>For example, if a Texture2D resource has a width of 32 and bytes per pixel of 4,</para>
		/// <para>then <i>pRowSizeInBytes</i> returns 128.</para>
		/// <para>
		/// <i>pRowSizeInBytes</i> should not be confused with <b>row pitch</b>, as examining <i>pLayouts</i> and getting the row pitch from
		/// that will give you 256 as it is aligned to D3D12_TEXTURE_DATA_PITCH_ALIGNMENT.
		/// </para>
		/// </param>
		/// <param name="pTotalBytes">
		/// <para>Type: <b>UINT64*</b></para>
		/// <para>A pointer to an integer variable, to be filled with the total size, in bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// This routine assists the application in filling out <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> structures, when suballocating space in upload heaps. The resulting structures are GPU
		/// adapter-agnostic, meaning that the values will not vary from one GPU adapter to the next. <b>GetCopyableFootprints</b> uses
		/// specified details about resource formats, texture layouts, and alignment requirements (from the <c>D3D12_RESOURCE_DESC</c>
		/// structure) to fill out the subresource structures. Applications have access to all these details, so this method, or a variation
		/// of it, could be written as part of the app. Examples The <c>D3D12Multithreading</c> sample uses
		/// <b>ID3D12Device::GetCopyableFootprints</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Returns required size of a buffer to be used for data upload inline UINT64 GetRequiredIntermediateSize( _In_
		/// ID3D12Resource* pDestinationResource, _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		/// _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources) { D3D12_RESOURCE_DESC Desc =
		/// pDestinationResource-&gt;GetDesc(); UINT64 RequiredSize = 0; ID3D12Device* pDevice;
		/// pDestinationResource-&gt;GetDevice(__uuidof(*pDevice), reinterpret_cast&lt;void**&gt;(&amp;pDevice));
		/// pDevice-&gt;GetCopyableFootprints(&amp;Desc, FirstSubresource, NumSubresources, 0, nullptr, nullptr, nullptr,
		/// &amp;RequiredSize); pDevice-&gt;Release(); return RequiredSize; }</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcopyablefootprints void GetCopyableFootprints(
		// [in] const D3D12_RESOURCE_DESC *pResourceDesc, [in] UINT FirstSubresource, [in] UINT NumSubresources, UINT64 BaseOffset, [out,
		// optional] D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts, [out, optional] UINT *pNumRows, [out, optional] UINT64 *pRowSizeInBytes,
		// [out, optional] UINT64 *pTotalBytes );
		[PreserveSig]
		new void GetCopyableFootprints(in D3D12_RESOURCE_DESC pResourceDesc, uint FirstSubresource, int NumSubresources, ulong BaseOffset,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_PLACED_SUBRESOURCE_FOOTPRINT[]? pLayouts,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[]? pNumRows,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[]? pRowSizeInBytes,
			out ulong pTotalBytes);

		/// <summary>Creates a query heap. A query heap contains an array of queries.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_QUERY_HEAP_DESC</c>*</b></para>
		/// <para>Specifies the query heap in a <c>D3D12_QUERY_HEAP_DESC</c> structure.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>Specifies a REFIID that uniquely identifies the heap.</para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// Specifies a pointer to the heap, that will be returned on successful completion of the method. <i>ppvHeap</i> can be NULL, to
		/// enable capability testing. When <i>ppvHeap</i> is NULL, no object will be created and S_FALSE will be returned when <i>pDesc</i>
		/// is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Refer to <c>Queries</c> for more information. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12Device::CreateQueryHeap</b> as follows:
		/// </para>
		/// <para>Create a query heap and a query result buffer.</para>
		/// <para>
		/// <c>// Pipeline objects. D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
		/// ComPtr&lt;ID3D12Device&gt; m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
		/// ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocators[FrameCount]; ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
		/// ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature; ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_cbvHeap; ComPtr&lt;ID3D12DescriptorHeap&gt; m_dsvHeap; ComPtr&lt;ID3D12QueryHeap&gt;
		/// m_queryHeap; UINT m_rtvDescriptorSize; UINT m_cbvSrvDescriptorSize; UINT m_frameIndex; // Synchronization objects.
		/// ComPtr&lt;ID3D12Fence&gt; m_fence; UINT64 m_fenceValues[FrameCount]; HANDLE m_fenceEvent; // Asset objects.
		/// ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState; ComPtr&lt;ID3D12PipelineState&gt; m_queryState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; ComPtr&lt;ID3D12Resource&gt; m_vertexBuffer; ComPtr&lt;ID3D12Resource&gt;
		/// m_constantBuffer; ComPtr&lt;ID3D12Resource&gt; m_depthStencil; ComPtr&lt;ID3D12Resource&gt; m_queryResult;
		/// D3D12_VERTEX_BUFFER_VIEW m_vertexBufferView;</c>
		/// </para>
		/// <para>
		/// <c>// Describe and create a heap for occlusion queries. D3D12_QUERY_HEAP_DESC queryHeapDesc = {}; queryHeapDesc.Count = 1;
		/// queryHeapDesc.Type = D3D12_QUERY_HEAP_TYPE_OCCLUSION; ThrowIfFailed(m_device-&gt;CreateQueryHeap(&amp;queryHeapDesc, IID_PPV_ARGS(&amp;m_queryHeap)));</c>
		/// </para>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createqueryheap HRESULT CreateQueryHeap( [in]
		// const D3D12_QUERY_HEAP_DESC *pDesc, REFIID riid, [out, optional] void **ppvHeap );
		[PreserveSig]
		new HRESULT CreateQueryHeap(in D3D12_QUERY_HEAP_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>A development-time aid for certain types of profiling and experimental prototyping.</summary>
		/// <param name="Enable">
		/// <para>Type: <b>BOOL</b></para>
		/// <para>Specifies a BOOL that turns the stable power state on or off.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method is only useful during the development of applications. It enables developers to profile GPU usage of multiple
		/// algorithms without experiencing artifacts from <c>dynamic frequency scaling</c>.
		/// </para>
		/// <para>
		/// Do not call this method in normal execution for a shipped application. This method only works while the machine is in
		/// <c>developer mode</c>. If developer mode is not enabled, then device removal will occur. Instead, call this method in response
		/// to an off-by-default, developer-facing switch. Calling it in response to command line parameters, config files, registry keys,
		/// and developer console commands are reasonable usage scenarios.
		/// </para>
		/// <para>
		/// A stable power state typically fixes GPU clock rates at a slower setting that is significantly lower than that experienced by
		/// users under normal application load. This reduction in clock rate affects the entire system. Slow clock rates are required to
		/// ensure processors dont exhaust power, current, and thermal limits. Normal usage scenarios commonly leverage a processors
		/// ability to dynamically over-clock. Any conclusions made by comparing two designs under a stable power state should be
		/// double-checked with supporting results from real usage scenarios.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-setstablepowerstate HRESULT SetStablePowerState(
		// BOOL Enable );
		[PreserveSig]
		new HRESULT SetStablePowerState(bool Enable);

		/// <summary>This method creates a command signature.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_COMMAND_SIGNATURE_DESC</c>*</b></para>
		/// <para>Describes the command signature to be created with the <c>D3D12_COMMAND_SIGNATURE_DESC</c> structure.</para>
		/// </param>
		/// <param name="pRootSignature">
		/// <para>Type: <b><c>ID3D12RootSignature</c>*</b></para>
		/// <para>Specifies the <c>ID3D12RootSignature</c> that the command signature applies to.</para>
		/// <para>
		/// The root signature is required if any of the commands in the signature will update bindings on the pipeline. If the only command
		/// present is a draw or dispatch, the root signature parameter can be set to NULL.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier ( <b>GUID</b>) for the command signature interface ( <c>ID3D12CommandSignature</c>). The
		/// <b>REFIID</b>, or <b>GUID</b>, of the interface to the command signature can be obtained by using the __uuidof() macro. For
		/// example, __uuidof( <b>ID3D12CommandSignature</b>) will get the <b>GUID</b> of the interface to a command signature.
		/// </para>
		/// </param>
		/// <param name="ppvCommandSignature">
		/// <para>Type: <b>void**</b></para>
		/// <para>Specifies a pointer, that on successful completion of the method will point to the created command signature ( <c>ID3D12CommandSignature</c>).</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommandsignature HRESULT
		// CreateCommandSignature( [in] const D3D12_COMMAND_SIGNATURE_DESC *pDesc, [in, optional] ID3D12RootSignature *pRootSignature,
		// REFIID riid, [out, optional] void **ppvCommandSignature );
		[PreserveSig]
		new HRESULT CreateCommandSignature(in D3D12_COMMAND_SIGNATURE_DESC pDesc, [In, Optional] ID3D12RootSignature? pRootSignature,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppvCommandSignature);

		/// <summary>Gets info about how a tiled resource is broken into tiles.</summary>
		/// <param name="pTiledResource">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies a tiled <c>ID3D12Resource</c> to get info about.</para>
		/// </param>
		/// <param name="pNumTilesForEntireResource">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>A pointer to a variable that receives the number of tiles needed to store the entire tiled resource.</para>
		/// </param>
		/// <param name="pPackedMipDesc">
		/// <para>Type: <b><c>D3D12_PACKED_MIP_INFO</c>*</b></para>
		/// <para>
		/// A pointer to a <c>D3D12_PACKED_MIP_INFO</c> structure that <b>GetResourceTiling</b> fills with info about how the tiled
		/// resource's mipmaps are packed.
		/// </para>
		/// </param>
		/// <param name="pStandardTileShapeForNonPackedMips">
		/// <para>Type: <b><c>D3D12_TILE_SHAPE</c>*</b></para>
		/// <para>
		/// Specifies a <c>D3D12_TILE_SHAPE</c> structure that <b>GetResourceTiling</b> fills with info about the tile shape. This is info
		/// about how pixels fit in the tiles, independent of tiled resource's dimensions, not including packed mipmaps. If the entire tiled
		/// resource is packed, this parameter is meaningless because the tiled resource has no defined layout for packed mipmaps. In this
		/// situation, <b>GetResourceTiling</b> sets the members of D3D12_TILE_SHAPE to zeros.
		/// </para>
		/// </param>
		/// <param name="pNumSubresourceTilings">
		/// <para>Type: <b>UINT*</b></para>
		/// <para>
		/// A pointer to a variable that contains the number of tiles in the subresource. On input, this is the number of subresources to
		/// query tilings for; on output, this is the number that was actually retrieved at <i>pSubresourceTilingsForNonPackedMips</i>
		/// (clamped to what's available).
		/// </para>
		/// </param>
		/// <param name="FirstSubresourceTilingToGet">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// The number of the first subresource tile to get. <b>GetResourceTiling</b> ignores this parameter if the number that
		/// <i>pNumSubresourceTilings</i> points to is 0.
		/// </para>
		/// </param>
		/// <param name="pSubresourceTilingsForNonPackedMips">
		/// <para>Type: <b><c>D3D12_SUBRESOURCE_TILING</c>*</b></para>
		/// <para>
		/// Specifies a <c>D3D12_SUBRESOURCE_TILING</c> structure that <b>GetResourceTiling</b> fills with info about subresource tiles. If
		/// subresource tiles are part of packed mipmaps, <b>GetResourceTiling</b> sets the members of D3D12_SUBRESOURCE_TILING to zeros,
		/// except the <i>StartTileIndexInOverallResource</i> member, which <b>GetResourceTiling</b> sets to D3D12_PACKED_TILE (0xffffffff).
		/// The D3D12_PACKED_TILE constant indicates that the whole <b>D3D12_SUBRESOURCE_TILING</b> structure is meaningless for this
		/// situation, and the info that the <i>pPackedMipDesc</i> parameter points to applies.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// To estimate the total resource size of textures needed when calculating heap sizes and calling <c>CreatePlacedResource</c>, use
		/// <c>GetResourceAllocationInfo</c> instead of <b>GetResourceTiling</b>. <b>GetResourceTiling</b> cannot be used for this.
		/// </para>
		/// <para>For more information on tiled resources, refer to <c>Volume Tiled Resources</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getresourcetiling void GetResourceTiling( [in]
		// ID3D12Resource *pTiledResource, [out, optional] UINT *pNumTilesForEntireResource, [out, optional] D3D12_PACKED_MIP_INFO
		// *pPackedMipDesc, [out, optional] D3D12_TILE_SHAPE *pStandardTileShapeForNonPackedMips, [in, out, optional] UINT
		// *pNumSubresourceTilings, [in] UINT FirstSubresourceTilingToGet, [out] D3D12_SUBRESOURCE_TILING
		// *pSubresourceTilingsForNonPackedMips );
		[PreserveSig]
		new void GetResourceTiling([In] ID3D12Resource pTiledResource, [Out, Optional] StructPointer<uint> pNumTilesForEntireResource,
			[Out, Optional] StructPointer<D3D12_PACKED_MIP_INFO> pPackedMipDesc, [Out, Optional] StructPointer<D3D12_TILE_SHAPE> pStandardTileShapeForNonPackedMips,
			[In, Out, Optional] StructPointer<uint> pNumSubresourceTilings, uint FirstSubresourceTilingToGet,
			[Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] D3D12_SUBRESOURCE_TILING[] pSubresourceTilingsForNonPackedMips);

		/// <summary>Gets a locally unique identifier for the current device (adapter).</summary>
		/// <returns>
		/// <para>Type: <b><c>LUID</c></b></para>
		/// <para>The locally unique identifier for the adapter.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this
		/// identifier to define robust mappings across various APIs (Direct3D 12, DXGI).
		/// </para>
		/// <para>
		/// A locally unique identifier (LUID) is a 64-bit value that is guaranteed to be unique only on the system on which it was
		/// generated. The uniqueness of a locally unique identifier (LUID) is guaranteed only until the system is restarted.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-getadapterluid LUID GetAdapterLuid();
		[PreserveSig]
		new LUID GetAdapterLuid();

		/// <summary>
		/// <para>
		/// Creates a cached pipeline library. For pipeline state objects (PSOs) that are expected to share data together, grouping them
		/// into a library before serializing them means that there's less overhead due to metadata, as well as the opportunity to avoid
		/// redundant or duplicated data being written to disk.
		/// </para>
		/// <para>
		/// You can query for <b>ID3D12PipelineLibrary</b> support with <b><c>ID3D12Device::CheckFeatureSupport</c></b>, with
		/// <b><c>D3D12_FEATURE_SHADER_CACHE</c></b> and <b><c>D3D12_FEATURE_DATA_SHADER_CACHE</c></b>. If the Flags member of
		/// <b><c>D3D12_FEATURE_DATA_SHADER_CACHE</c></b> contains the flag <b><c>D3D12_SHADER_CACHE_SUPPORT_LIBRARY</c></b>, the
		/// <b>ID3D12PipelineLibrary</b> interface is supported. If not, then <b>DXGI_ERROR_NOT_SUPPORTED</b> will always be returned when
		/// this function is called.
		/// </para>
		/// </summary>
		/// <param name="pLibraryBlob">
		/// <para>Type: [in] <b>const void*</b></para>
		/// <para>
		/// If the input library blob is empty, then the initial content of the library is empty. If the input library blob is not empty,
		/// then it is validated for integrity, parsed, and the pointer is stored. The pointer provided as input to this method must remain
		/// valid for the lifetime of the object returned. For efficiency reasons, the data is not copied.
		/// </para>
		/// </param>
		/// <param name="BlobLength">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>Specifies the length of pLibraryBlob in bytes.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// Specifies a unique REFIID for the <c>ID3D12PipelineLibrary</c> object. Typically set this and the following parameter with the
		/// macro <c>IID_PPV_ARGS(&amp;Library)</c>, where <b>Library</b> is the name of the object.
		/// </para>
		/// </param>
		/// <param name="ppPipelineLibrary">
		/// <para>Type: [out] <b>void**</b></para>
		/// <para>Returns a pointer to the created library.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>, including
		/// <b>E_INVALIDARG</b> if the blob is corrupted or unrecognized, <b>D3D12_ERROR_DRIVER_VERSION_MISMATCH</b> if the provided data
		/// came from an old driver or runtime, and <b>D3D12_ERROR_ADAPTER_NOT_FOUND</b> if the data came from different hardware.
		/// </para>
		/// <para>
		/// If you pass <c>nullptr</c> for pPipelineLibrary then the runtime still performs the validation of the blob but avoid creating
		/// the actual library and returns S_FALSE if the library would have been created.
		/// </para>
		/// <para>Also, the feature requires an updated driver, and attempting to use it on old drivers will return DXGI_ERROR_UNSUPPORTED.</para>
		/// </returns>
		/// <remarks>
		/// <para>A pipeline library enables the following operations.</para>
		/// <list type="bullet">
		/// <item>
		/// <description>Adding pipeline state objects (PSOs) to an existing library object (refer to <c>StorePipeline</c>).</description>
		/// </item>
		/// <item>
		/// <description>Serializing a PSO library into a contiguous block of memory for disk storage (refer to <c>Serialize</c>).</description>
		/// </item>
		/// <item>
		/// <description>De-serializing a PSO library from persistent storage (this is handled by <b>CreatePipelineLibrary</b>).</description>
		/// </item>
		/// <item>
		/// <description>Retrieving individual PSOs from the library (refer to <c>LoadComputePipeline</c> and <c>LoadGraphicsPipeline</c>).</description>
		/// </item>
		/// </list>
		/// <para>At no point in the lifecycle of a pipeline library is there duplication between PSOs with identical sub-components.</para>
		/// <para>
		/// A recommended solution for managing the lifetime of the provided pointer while only having to ref-count the returned interface
		/// is to leverage <c>ID3D12Object::SetPrivateDataInterface</c>, and use an object which implements <b>IUnknown</b>, and frees the
		/// memory when the ref-count reaches 0.
		/// </para>
		/// <para>Thread Safety</para>
		/// <para>
		/// The pipeline library is thread-safe to use, and will internally synchronize as necessary, with one exception: multiple threads
		/// loading the same PSO (via <c><b>LoadComputePipeline</b></c>, <c><b>LoadGraphicsPipeline</b></c>, or <c><b>LoadPipeline</b></c>)
		/// should synchronize themselves, as this act may modify the state of that pipeline within the library in a non-thread-safe manner.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-createpipelinelibrary HRESULT
		// CreatePipelineLibrary( const void *pLibraryBlob, SIZE_T BlobLength, REFIID riid, void **ppPipelineLibrary );
		[PreserveSig]
		new HRESULT CreatePipelineLibrary([In] IntPtr pLibraryBlob, [In] SizeT BlobLength, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppPipelineLibrary);

		/// <summary>Specifies an event that should be fired when one or more of a collection of fences reach specific values.</summary>
		/// <param name="ppFences">
		/// <para>Type: <b>ID3D12Fence*</b></para>
		/// <para>An array of length <i>NumFences</i> that specifies the <c>ID3D12Fence</c> objects.</para>
		/// </param>
		/// <param name="pFenceValues">
		/// <para>Type: <b>const UINT64*</b></para>
		/// <para>An array of length <i>NumFences</i> that specifies the fence values required for the event is to be signaled.</para>
		/// </param>
		/// <param name="NumFences">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of fences to be included.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_MULTIPLE_FENCE_WAIT_FLAGS</c></b></para>
		/// <para>Specifies one of the <c>D3D12_MULTIPLE_FENCE_WAIT_FLAGS</c> that determines how to proceed.</para>
		/// </param>
		/// <param name="hEvent">
		/// <para>Type: <b>HANDLE</b></para>
		/// <para>A handle to the event object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns an HRESULT success or error code.</para>
		/// </returns>
		/// <remarks>
		/// <para>To specify a single fence refer to the <c>SetEventOnCompletion</c> method.</para>
		/// <para>If hEvent is a null handle, then this API will not return until the specified fence value(s) have been reached.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-seteventonmultiplefencecompletion HRESULT
		// SetEventOnMultipleFenceCompletion( [in] ID3D12Fence * const *ppFences, [in] const UINT64 *pFenceValues, UINT NumFences,
		// D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags, HANDLE hEvent );
		[PreserveSig]
		new HRESULT SetEventOnMultipleFenceCompletion([In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 2)] ID3D12Fence[] ppFences,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[] pFenceValues, int NumFences, D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
			HEVENT hEvent);

		/// <summary>This method sets residency priorities of a specified list of objects.</summary>
		/// <param name="NumObjects">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of objects in the <i>ppObjects</i> and <i>pPriorities</i> arrays.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b>ID3D12Pageable*</b></para>
		/// <para>Specifies an array, of length <i>NumObjects</i>, containing references to <c>ID3D12Pageable</c> objects.</para>
		/// </param>
		/// <param name="pPriorities">
		/// <para>Type: <b>const <c>D3D12_RESIDENCY_PRIORITY</c>*</b></para>
		/// <para>Specifies an array, of length <i>NumObjects</i>, of <c>D3D12_RESIDENCY_PRIORITY</c> values for the list of objects.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns an HRESULT success or error code.</para>
		/// </returns>
		/// <remarks>For more information, refer to <c>Residency</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority HRESULT
		// SetResidencyPriority( UINT NumObjects, [in] ID3D12Pageable * const *ppObjects, [in] const D3D12_RESIDENCY_PRIORITY *pPriorities );
		[PreserveSig]
		new HRESULT SetResidencyPriority(int NumObjects, [In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 0)] ID3D12Pageable[] ppObjects,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_RESIDENCY_PRIORITY[] pPriorities);

		/// <summary>Creates a pipeline state object from a pipeline state stream description.</summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_PIPELINE_STATE_STREAM_DESC</c>*</b></para>
		/// <para>The address of a <c>D3D12_PIPELINE_STATE_STREAM_DESC</c> structure that describes the pipeline state.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the pipeline state interface ( <c>ID3D12PipelineState</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For
		/// example, __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.
		/// </para>
		/// </param>
		/// <param name="ppPipelineState">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12PipelineState</c> interface for the pipeline state object.
		/// </para>
		/// <para>The pipeline state object is an immutable state object. It contains no methods.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object. See <c>Direct3D 12
		/// Return Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// This function takes the pipeline description as a <c>D3D12_PIPELINE_STATE_STREAM_DESC</c> and combines the functionality of the
		/// <c>ID3D12Device::CreateGraphicsPipelineState</c> and <c>ID3D12Device::CreateComputePipelineState</c> functions, which take their
		/// pipeline description as the less-flexible <c>D3D12_GRAPHICS_PIPELINE_STATE_DESC</c> and <c>D3D12_COMPUTE_PIPELINE_STATE_DESC</c>
		/// structs, respectively.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device2-createpipelinestate HRESULT CreatePipelineState(
		// const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc, REFIID riid, [out] void **ppPipelineState );
		[PreserveSig]
		new HRESULT CreatePipelineState(in D3D12_PIPELINE_STATE_STREAM_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppPipelineState);

		/// <summary>
		/// Creates a special-purpose diagnostic heap in system memory from an address. The created heap can persist even in the event of a
		/// GPU-fault or device-removed scenario.
		/// </summary>
		/// <param name="pAddress">
		/// <para>Type: <b>const void*</b></para>
		/// <para>The address used to create the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the heap interface ( <c>ID3D12Heap</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the heap can be obtained by using the <b>__uuidof()</b> macro. For
		/// example, <b>__uuidof(ID3D12Heap)</b> will retrieve the <b>GUID</b> of the interface to a heap.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block. On success, the D3D12 runtime will write a pointer to the newly-opened heap into the memory block.
		/// The type of the pointer depends on the provided <b>riid</b> parameter.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to open the existing heap. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>The heap is created in system memory and permits CPU access. It wraps the entire VirtualAlloc region.</para>
		/// <para>
		/// Heaps can be used for placed and reserved resources, as orthogonally as other heaps. Restrictions may still exist based on the
		/// flags that cannot be app-chosen.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-openexistingheapfromaddress HRESULT
		// OpenExistingHeapFromAddress( [in] const void *pAddress, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT OpenExistingHeapFromAddress([In] IntPtr pAddress, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>
		/// Creates a special-purpose diagnostic heap in system memory from a file mapping object. The created heap can persist even in the
		/// event of a GPU-fault or device-removed scenario.
		/// </summary>
		/// <param name="hFileMapping">
		/// <para>Type: <b><c>HANDLE</c></b></para>
		/// <para>The handle to the file mapping object to use to create the heap.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the heap interface ( <c>ID3D12Heap</c>).</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the heap can be obtained by using the <b>__uuidof()</b> macro. For
		/// example, <b>__uuidof(ID3D12Heap)</b> will retrieve the <b>GUID</b> of the interface to a heap.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para><c>SAL</c>: <c>COM_Outptr</c></para>
		/// <para>
		/// A pointer to a memory block. On success, the D3D12 runtime will write a pointer to the newly-opened heap into the memory block.
		/// The type of the pointer depends on the provided <b>riid</b> parameter.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to open the existing heap. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>The heap is created in system memory, and it permits CPU access. It wraps the entire VirtualAlloc region.</para>
		/// <para>
		/// Heaps can be used for placed and reserved resources, as orthogonally as other heaps. Restrictions may still exist based on the
		/// flags that cannot be app-chosen.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-openexistingheapfromfilemapping HRESULT
		// OpenExistingHeapFromFileMapping( HANDLE hFileMapping, REFIID riid, [out] void **ppvHeap );
		[PreserveSig]
		new HRESULT OpenExistingHeapFromFileMapping([In] IntPtr hFileMapping, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvHeap);

		/// <summary>Asynchronously makes objects resident for the device.</summary>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_RESIDENCY_FLAGS</c></b></para>
		/// <para>Controls whether the objects should be made resident if the application is over its memory budget.</para>
		/// </param>
		/// <param name="NumObjects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of objects in the <i>ppObjects</i> array to make resident for the device.</para>
		/// </param>
		/// <param name="ppObjects">
		/// <para>Type: <b><c>ID3D12Pageable</c>*</b></para>
		/// <para>A pointer to a memory block; contains an array of <c>ID3D12Pageable</c> interface pointers for the objects.</para>
		/// <para>Even though most D3D12 objects inherit from <c>ID3D12Pageable</c>, residency changes are only supported on the following:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>descriptor heaps</description>
		/// </item>
		/// <item>
		/// <description>heaps</description>
		/// </item>
		/// <item>
		/// <description>committed resources</description>
		/// </item>
		/// <item>
		/// <description>query heaps</description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pFenceToSignal">
		/// <para>Type: <b><c>ID3D12Fence</c>*</b></para>
		/// <para>A pointer to the fence used to signal when the work is done.</para>
		/// </param>
		/// <param name="FenceValueToSignal">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>An unsigned 64-bit value signaled to the fence when the work is done.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>EnqueueMakeResident</b> performs the same actions as <c>MakeResident</c>, but does not wait for the resources to be made
		/// resident. Instead, <b>EnqueueMakeResident</b> signals a fence when the work is done.
		/// </para>
		/// <para>
		/// The system will not allow work that references the resources that are being made resident by using <b>EnqueueMakeResident</b>
		/// before its fence is signaled. Instead, calls to this API are guaranteed to signal their corresponding fence in order, so the
		/// same fence can be used from call to call.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device3-enqueuemakeresident HRESULT EnqueueMakeResident(
		// D3D12_RESIDENCY_FLAGS Flags, UINT NumObjects, [in] ID3D12Pageable * const *ppObjects, [in] ID3D12Fence *pFenceToSignal, UINT64
		// FenceValueToSignal );
		[PreserveSig]
		new HRESULT EnqueueMakeResident(D3D12_RESIDENCY_FLAGS Flags, int NumObjects,
			[MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 1)] ID3D12Pageable[] ppObjects,
			[In] ID3D12Fence pFenceToSignal, ulong FenceValueToSignal);

		/// <summary>Creates a command list in the closed state. Also see <c>ID3D12Device::CreateCommandList</c>.</summary>
		/// <param name="nodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set a bit to identify the node (the device's
		/// physical adapter) for which to create the command list. Each bit in the mask corresponds to a single node. Only one bit must be
		/// set. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>Specifies the type of command list to create.</para>
		/// </param>
		/// <param name="flags">
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_FLAGS</c></b></para>
		/// <para>Specifies creation flags.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the command list interface to return in ppCommandList.</para>
		/// </param>
		/// <param name="ppCommandList">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12CommandList</c> or <c>ID3D12GraphicsCommandList</c>
		/// interface for the command list.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the command list.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createcommandlist1 HRESULT CreateCommandList1(
		// [in] UINT nodeMask, [in] D3D12_COMMAND_LIST_TYPE type, D3D12_COMMAND_LIST_FLAGS flags, [in] REFIID riid, [out] void
		// **ppCommandList );
		[PreserveSig]
		new HRESULT CreateCommandList1(uint nodeMask, D3D12_COMMAND_LIST_TYPE type, D3D12_COMMAND_LIST_FLAGS flags, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 3)] out object? ppCommandList);

		/// <summary>
		/// <para>
		/// Creates an object that represents a session for content protection. You can then provide that session when you're creating
		/// resource or heap objects, to indicate that they should be protected.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>Memory contents can't be transferred from a protected resource to an unprotected resource.</para>
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_PROTECTED_RESOURCE_SESSION_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_PROTECTED_RESOURCE_SESSION_DESC</b> structure, describing the session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the <c>ID3D12ProtectedResourceSession</c> interface.</para>
		/// </param>
		/// <param name="ppSession">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives an <c>ID3D12ProtectedResourceSession</c> interface pointer to the created session object.
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createprotectedresourcesession HRESULT
		// CreateProtectedResourceSession( [in] const D3D12_PROTECTED_RESOURCE_SESSION_DESC *pDesc, [in] REFIID riid, [out] void **ppSession );
		[PreserveSig]
		new HRESULT CreateProtectedResourceSession(in D3D12_PROTECTED_RESOURCE_SESSION_DESC pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppSession);

		/// <summary>
		/// Creates both a resource and an implicit heap (optionally for a protected session), such that the heap is big enough to contain
		/// the entire resource, and the resource is mapped to the heap. Also see <c>ID3D12Device::CreateCommittedResource</c> for a code example.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createcommittedresource1 HRESULT
		// CreateCommittedResource1( [in] const D3D12_HEAP_PROPERTIES *pHeapProperties, [in] D3D12_HEAP_FLAGS HeapFlags, [in] const
		// D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialResourceState, [in, optional] const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riidResource, [out,
		// optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource1(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 6)] out object? ppvResource);

		/// <summary>
		/// Creates a heap (optionally for a protected session) that can be used with placed resources and reserved resources. Also see <c>ID3D12Device::CreateHeap</c>.
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_HEAP_DESC</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_HEAP_DESC</b> structure that describes the heap.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// heap should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// <para>A heap with a protected session can't be created with the <c>D3D12_HEAP_FLAG_SHARED_CROSS_ADAPTER</c> flag.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the heap interface to return in ppvHeap.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Heap</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvHeap">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created heap object.</para>
		/// <para>
		/// <paramref name="ppvHeap"/> can be <c>nullptr</c>, to enable capability testing. When ppvHeap is <c>nullptr</c>, no object is
		/// created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the heap.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para><b>CreateHeap1</b> creates a heap that can be used with placed resources and reserved resources.</para>
		/// <para>
		/// Before releasing the final reference on the heap, your application must ensure that the GPU will no longer read or write to this heap.
		/// </para>
		/// <para>
		/// A placed resource object holds a reference on the heap it is created on; but a reserved resource doesn't hold a reference for
		/// each mapping made to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createheap1 HRESULT CreateHeap1( [in] const
		// D3D12_HEAP_DESC *pDesc, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riid, [out, optional] void
		// **ppvHeap );
		[PreserveSig]
		new HRESULT CreateHeap1(in D3D12_HEAP_DESC pDesc, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppvHeap);

		/// <summary>
		/// <para>
		/// Creates a resource (optionally for a protected session) that is reserved, and not yet mapped to any pages in a heap. Also see <c>ID3D12Device::CreateReservedResource</c>.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>Only tiles from heaps created with the same protected resource session can be mapped into a protected reserved resource.</para>
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/>&gt; specifies a value for which clear operations are most optimal. When the created
		/// resource is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or
		/// <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b> flags, you should choose the value with which the clear operation will most
		/// commonly be called. You can call the clear operation with other values, but those operations won't be as efficient as when the
		/// value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>CreateReservedResource</b> is equivalent to <c>D3D11_RESOURCE_MISC_TILED</c> in Direct3D 11. It creates a resource with
		/// virtual memory only, no backing store.
		/// </para>
		/// <para>You need to map the resource to physical memory (that is, to a heap) using <c>CopyTileMappings</c> and <c>UpdateTileMappings</c>.</para>
		/// <para>
		/// These resource types can only be created when the adapter supports tiled resource tier 1 or greater. The tiled resource tier
		/// defines the behavior of accessing a resource that is not mapped to a heap.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-createreservedresource1 HRESULT
		// CreateReservedResource1( [in] const D3D12_RESOURCE_DESC *pDesc, [in] D3D12_RESOURCE_STATES InitialState, [in, optional] const
		// D3D12_CLEAR_VALUE *pOptimizedClearValue, [in, optional] ID3D12ProtectedResourceSession *pProtectedSession, [in] REFIID riid,
		// [out, optional] void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource1(in D3D12_RESOURCE_DESC pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Gets rich info about the size and alignment of memory required for a collection of resources on this adapter. Also see <c>ID3D12Device::GetResourceAllocationInfo</c>.
		/// </para>
		/// <para>
		/// In addition to the <c>D3D12_RESOURCE_ALLOCATION_INFO</c> returned from the method, this version also returns an array of
		/// <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, which provide additional details for each resource description passed as
		/// input. See the pResourceAllocationInfo1 parameter.
		/// </para>
		/// </summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array. This is also the size (the number of elements in) pResourceAllocationInfo1.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <param name="pResourceAllocationInfo1">
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO1</c>*</b></para>
		/// <para>
		/// An array of <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, containing additional details for each resource description
		/// passed as input. This makes it simpler for your application to allocate a heap for multiple resources, and without manually
		/// computing offsets for where each resource should be placed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When you're using <c>CreatePlacedResource</c>, your application must use <b>GetResourceAllocationInfo</b> in order to understand
		/// the size and alignment characteristics of texture resources. The results of this method vary depending on the particular
		/// adapter, and must be treated as unique to this adapter and driver version.
		/// </para>
		/// <para>
		/// Your application can't use the output of <b>GetResourceAllocationInfo</b> to understand packed mip properties of textures. To
		/// understand packed mip properties of textures, your application must use <c>GetResourceTiling</c>.
		/// </para>
		/// <para>
		/// Texture resource sizes significantly differ from the information returned by <b>GetResourceTiling</b>, because some adapter
		/// architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios. This even
		/// includes textures that have constraints on their texture layouts, or have standardized texture layouts. That extra memory can't
		/// be sparsely mapped nor remapped by an application using <c>CreateReservedResource</c> and <c>UpdateTileMappings</c>, so it isn't
		/// reported by <b>GetResourceTiling</b>.
		/// </para>
		/// <para>
		/// Your application can forgo using <b>GetResourceAllocationInfo</b> for buffer resources (
		/// <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>). Buffers have the same size on all adapters, which is merely the smallest multiple of
		/// 64KB that's greater or equal to <c>D3D12_RESOURCE_DESC::Width</c>.
		/// </para>
		/// <para>
		/// When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used.
		/// For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource, reports differing sizes
		/// based on the order of the array. If the 4MB aligned resource is in the middle, then the resulting <b>Size</b> is 12MB.
		/// Otherwise, the resulting <b>Size</b> is 8MB. The <b>Alignment</b> returned would always be 4MB, because it's the superset of all
		/// alignments in the resource array.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device4-getresourceallocationinfo1(uint_uint_constd3d12_resource_desc_d3d12_resource_allocation_info1)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo1( [in] UINT visibleMask, [in] UINT numResourceDescs, [in] const
		// D3D12_RESOURCE_DESC *pResourceDescs, [out] D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1 );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo1(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC[] pResourceDescs,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[]? pResourceAllocationInfo1);

		/// <summary>
		/// Creates a lifetime tracker associated with an application-defined callback; the callback receives notifications when the
		/// lifetime of a tracked object is changed.
		/// </summary>
		/// <param name="pOwner">
		/// <para>Type: <b><c>ID3D12LifetimeOwner</c>*</b></para>
		/// <para>A pointer to an <b>ID3D12LifetimeOwner</b> interface representing the application-defined callback.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the interface identifier (IID) of the interface to return in ppvTracker.</para>
		/// </param>
		/// <param name="ppvTracker">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives the requested interface pointer to the created object.</para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createlifetimetracker HRESULT
		// CreateLifetimeTracker( [in] ID3D12LifetimeOwner *pOwner, [in] REFIID riid, [out] void **ppvTracker );
		[PreserveSig]
		new HRESULT CreateLifetimeTracker([In] ID3D12LifetimeOwner pOwner, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvTracker);

		/// <summary>
		/// You can call <b>RemoveDevice</b> to indicate to the Direct3D 12 runtime that the GPU device encountered a problem, and can no
		/// longer be used. Doing so will cause all devices' monitored fences to be signaled. Your application typically doesn't need to
		/// explicitly call <b>RemoveDevice</b>.
		/// </summary>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Because device removal triggers all fences to be signaled to <c>UINT64_MAX</c>, you can create a callback for device removal
		/// using an event.
		/// </para>
		/// <para>
		/// <c>HANDLE deviceRemovedEvent = CreateEventW(NULL, FALSE, FALSE, NULL); assert(deviceRemovedEvent != NULL);
		/// _deviceFence-&gt;SetEventOnCompletion(UINT64_MAX, deviceRemoved); HANDLE waitHandle; RegisterWaitForSingleObject(
		/// &amp;waitHandle, deviceRemovedEvent, OnDeviceRemoved, _device.Get(), // Pass the device as our context INFINITE, // No timeout 0
		/// // No flags ); void OnDeviceRemoved(PVOID context, BOOLEAN) { ID3D12Device* removedDevice = (ID3D12Device*)context; HRESULT
		/// removedReason = removedDevice-&gt;GetDeviceRemovedReason(); // Perform app-specific device removed operation, such as logging or
		/// inspecting DRED output }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-removedevice void RemoveDevice();
		[PreserveSig]
		new void RemoveDevice();

		/// <summary>Queries reflection metadata about available meta commands.</summary>
		/// <param name="pNumMetaCommands">
		/// <para>Type: [in, out] <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a <c>UINT</c> containing the number of meta commands to query for. This field determines the size of the
		/// <i>pDescs</i> array, unless <i>pDescs</i> is <b>nullptr</b>.
		/// </para>
		/// </param>
		/// <param name="pDescs">
		/// <para>Type: [out, optional] <b><c>D3D12_META_COMMAND_DESC</c>*</b></para>
		/// <para>
		/// An optional pointer to an array of <c>D3D12_META_COMMAND_DESC</c> containing the descriptions of the available meta commands.
		/// Pass <c>nullptr</c> to have the number of available meta commands returned in <i>pNumMetaCommands</i>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-enumeratemetacommands HRESULT
		// EnumerateMetaCommands( UINT *pNumMetaCommands, D3D12_META_COMMAND_DESC *pDescs );
		[PreserveSig]
		new HRESULT EnumerateMetaCommands(ref int pNumMetaCommands, [Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_META_COMMAND_DESC[]? pDescs);

		/// <summary>Queries reflection metadata about the parameters of the specified meta command.</summary>
		/// <param name="CommandId">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier (GUID) of the meta command whose parameters you wish to be returned in <i>pParameterDescs</i>.</para>
		/// </param>
		/// <param name="Stage">
		/// <para>Type: <b>D3D12_META_COMMAND_PARAMETER_STAGE</b></para>
		/// <para>
		/// A <c>D3D12_META_COMMAND_PARAMETER_STAGE</c> specifying the stage of the parameters that you wish to be included in the query.
		/// </para>
		/// </param>
		/// <param name="pTotalStructureSizeInBytes">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// An optional pointer to a <c>UINT</c> containing the size of the structure containing the parameter values, which you pass when
		/// creating/initializing/executing the meta command, as appropriate.
		/// </para>
		/// </param>
		/// <param name="pParameterCount">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a <c>UINT</c> containing the number of parameters to query for. This field determines the size of the
		/// <i>pParameterDescs</i> array, unless <i>pParameterDescs</i> is <b>nullptr</b>.
		/// </para>
		/// </param>
		/// <param name="pParameterDescs">
		/// <para>Type: <b>D3D12_META_COMMAND_PARAMETER_DESC*</b></para>
		/// <para>
		/// An optional pointer to an array of <c>D3D12_META_COMMAND_PARAMETER_DESC</c> containing the descriptions of the parameters. Pass
		/// <b>nullptr</b> to have the parameter count returned in <i>pParameterCount</i>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HRESULT</b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-enumeratemetacommandparameters HRESULT
		// EnumerateMetaCommandParameters( [in] REFGUID CommandId, [in] D3D12_META_COMMAND_PARAMETER_STAGE Stage, [out, optional] UINT
		// *pTotalStructureSizeInBytes, [in, out] UINT *pParameterCount, [out, optional] D3D12_META_COMMAND_PARAMETER_DESC *pParameterDescs );
		[PreserveSig]
		new HRESULT EnumerateMetaCommandParameters(in Guid CommandId, D3D12_META_COMMAND_PARAMETER_STAGE Stage, out uint pTotalStructureSizeInBytes,
			ref int pParameterCount, [Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] D3D12_META_COMMAND_PARAMETER_DESC[]? pParameterDescs);

		/// <summary>Creates an instance of the specified meta command.</summary>
		/// <param name="CommandId">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier (GUID) of the meta command that you wish to instantiate.</para>
		/// </param>
		/// <param name="NodeMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-adapter operation, set this to zero. If there are multiple adapter nodes, set a bit to identify the node (one of the
		/// device's physical adapters) to which the meta command applies. Each bit in the mask corresponds to a single node. Only one bit
		/// must be set. See <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="pCreationParametersData">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>An optional pointer to a constant structure containing the values of the parameters for creating the meta command.</para>
		/// </param>
		/// <param name="CreationParametersDataSizeInBytes">
		/// <para>Type: <b><c>SIZE_T</c></b></para>
		/// <para>A <c>SIZE_T</c> containing the size of the structure pointed to by <i>pCreationParametersData</i>, if set, otherwise 0.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// A reference to the globally unique identifier (GUID) of the interface that you wish to be returned in <i>ppMetaCommand</i>. This
		/// is expected to be the GUID of <c>ID3D12MetaCommand</c>.
		/// </para>
		/// </param>
		/// <param name="ppMetaCommand">
		/// <para>Type: <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the meta command. This is the address of a pointer to an
		/// <c>ID3D12MetaCommand</c>, representing the meta command created.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b>HRESULT</b></para>
		/// <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>DXGI_ERROR_UNSUPPORTED</description>
		/// <description>The current hardware does not support the algorithm being requested</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createmetacommand HRESULT CreateMetaCommand(
		// [in] REFGUID CommandId, [in] UINT NodeMask, [in, optional] const void *pCreationParametersData, [in] SIZE_T
		// CreationParametersDataSizeInBytes, REFIID riid, [out] void **ppMetaCommand );
		[PreserveSig]
		new HRESULT CreateMetaCommand(in Guid CommandId, uint NodeMask, [In, Optional] IntPtr pCreationParametersData, [In] SizeT CreationParametersDataSizeInBytes,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppMetaCommand);

		/// <summary>Creates an <c>ID3D12StateObject</c>.</summary>
		/// <param name="pDesc">The description of the state object to create.</param>
		/// <param name="riid">The GUID of the interface to create. Use <i>__uuidof(ID3D12StateObject)</i>.</param>
		/// <param name="ppStateObject">The returned state object.</param>
		/// <returns>
		/// <para>Returns S_OK if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>E_INVALIDARG if one of the input parameters is invalid.</description>
		/// </item>
		/// <item>
		/// <description>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</description>
		/// </item>
		/// <item>
		/// <description>Possibly other error codes that are described in the <c>Direct3D 12 Return Codes</c> topic.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-createstateobject HRESULT CreateStateObject(
		// [in] const D3D12_STATE_OBJECT_DESC *pDesc, REFIID riid, [out] void **ppStateObject );
		[PreserveSig]
		new HRESULT CreateStateObject(in D3D12_STATE_OBJECT_DESC pDesc, in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppStateObject);

		/// <summary>Query the driver for resource requirements to build an acceleration structure.</summary>
		/// <param name="pDesc">
		/// <para>
		/// Description of the acceleration structure build. This structure is shared with <c>BuildRaytracingAccelerationStructure</c>. For
		/// more information, see <c>D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS</c>.
		/// </para>
		/// <para>
		/// The implementation is allowed to look at all the CPU parameters in this struct and nested structs. It may not
		/// inspect/dereference any GPU virtual addresses, other than to check to see if a pointer is NULL or not, such as the optional
		/// transform in <c>D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC</c>, without dereferencing it. In other words, the calculation of
		/// resource requirements for the acceleration structure does not depend on the actual geometry data (such as vertex positions),
		/// rather it can only depend on overall properties, such as the number of triangles, number of instances etc.
		/// </para>
		/// </param>
		/// <param name="pInfo">The result of the query (in a <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO</c> structure).</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The input acceleration structure description is the same as what goes into <c>BuildRaytracingAccelerationStructure</c>. The
		/// result of this function lets the application provide the correct amount of output storage and scratch storage to
		/// <b>BuildRaytracingAccelerationStructure</b> given the same geometry.
		/// </para>
		/// <para>
		/// Builds can also be done with the same configuration passed to <b>GetAccelerationStructurePrebuildInfo</b> overall except equal
		/// or smaller counts for the number of geometries/instances or the number of vertices/indices/AABBs in any given geometry. In this
		/// case the storage requirements reported with the original sizes passed to <b>GetRaytracingAccelerationStructurePrebuildInfo</b>
		/// will be valid  the build may actually consume less space but not more. This is handy for app scenarios where having
		/// conservatively large storage allocated for acceleration structures is fine.
		/// </para>
		/// <para>
		/// This method is on the device interface as opposed to command list on the assumption that drivers must be able to calculate
		/// resource requirements for an acceleration structure build from only looking at the CPU-visible portions of the call, without
		/// having to dereference any pointers to GPU memory containing actual vertex data, index data, etc.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-getraytracingaccelerationstructureprebuildinfo
		// void GetRaytracingAccelerationStructurePrebuildInfo( [in] const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS *pDesc,
		// [out] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO *pInfo );
		[PreserveSig]
		new void GetRaytracingAccelerationStructurePrebuildInfo(in D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS pDesc, out D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO pInfo);

		/// <summary>
		/// Reports the compatibility of serialized data, such as a serialized raytracing acceleration structure resulting from a call to
		/// <c>CopyRaytracingAccelerationStructure</c> with mode <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_SERIALIZE</c>, with
		/// the current device/driver.
		/// </summary>
		/// <param name="SerializedDataType">The type of the serialized data. For more information, see <c>D3D12_SERIALIZED_DATA_TYPE</c>.</param>
		/// <param name="pIdentifierToCheck">
		/// Identifier from the header of the serialized data to check with the driver. For more information, see <c>D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER</c>.
		/// </param>
		/// <returns>The returned compatibility status. For more information, see <c>D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS</c>.</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device5-checkdrivermatchingidentifier
		// D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS CheckDriverMatchingIdentifier( [in] D3D12_SERIALIZED_DATA_TYPE SerializedDataType, [in]
		// const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER *pIdentifierToCheck );
		[PreserveSig]
		new D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS CheckDriverMatchingIdentifier(D3D12_SERIALIZED_DATA_TYPE SerializedDataType,
			in D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER pIdentifierToCheck);

		/// <summary>Sets the mode for driver background processing optimizations.</summary>
		/// <param name="Mode">
		/// <para>Type: <b><c>D3D12_BACKGROUND_PROCESSING_MODE</c></b></para>
		/// <para>The level of dynamic optimization to apply to GPU work that's subsequently submitted.</para>
		/// </param>
		/// <param name="MeasurementsAction">
		/// <para>Type: <b><c>D3D12_MEASUREMENTS_ACTION</c></b></para>
		/// <para>The action to take with the results of earlier workload instrumentation.</para>
		/// </param>
		/// <param name="hEventToSignalUponCompletion">
		/// <para>Type: <b><c>HANDLE</c></b></para>
		/// <para>
		/// An optional handle to signal when the function is complete. For example, if MeasurementsAction is set to
		/// <c>D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS</c>, then hEventToSignalUponCompletion is signaled when all resulting compilations
		/// have finished.
		/// </para>
		/// </param>
		/// <param name="pbFurtherMeasurementsDesired">
		/// <para>Type: <b><c>BOOL</c>*</b></para>
		/// <para>
		/// An optional pointer to a Boolean value. The function sets the value to <c>true</c> to indicate that you should continue
		/// profiling, otherwise, <c>false</c>.
		/// </para>
		/// </param>
		/// <remarks>
		/// <para>
		/// A graphics driver can use idle-priority background CPU threads to dynamically recompile shader programs. That can improve GPU
		/// performance by specializing shader code to better match details of the hardware that it's running on, and/or the context in
		/// which it's being used.
		/// </para>
		/// <para>
		/// As a developer, you don't have to do anything to benefit from this feature (over time, as drivers adopt background processing
		/// optimizations, existing shaders will automatically be tuned more efficiently). But, when you're profiling your code, you'll
		/// probably want to call <b>SetBackgroundProcessingMode</b> to make sure that any driver background processing optimizations have
		/// taken place before you take timing measurements. Here's an example.
		/// </para>
		/// <para>
		/// <c>SetBackgroundProcessingMode( D3D12_BACKGROUND_PROCESSING_MODE_ALLOW_INTRUSIVE_MEASUREMENTS, D3D_MEASUREMENTS_ACTION_KEEP_ALL,
		/// nullptr, nullptr); // Here, prime the system by rendering some typical content. // For example, a level flythrough.
		/// SetBackgroundProcessingMode( D3D12_BACKGROUND_PROCESSING_MODE_ALLOWED, D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS, nullptr,
		/// nullptr); // Here, continue rendering. This time with dynamic optimizations applied. // And then take your measurements.</c>
		/// </para>
		/// <para>
		/// <c>PIX</c> automatically uses <b>SetBackgroundProcessingMode</b>first to prime the system,and then to prevent any further
		/// changes from taking place in the middle of its analysis. PIX waits on an event (to make sure all background shader recompiles
		/// have finished) before it starts taking measurements.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device6-setbackgroundprocessingmode HRESULT
		// SetBackgroundProcessingMode( [in] D3D12_BACKGROUND_PROCESSING_MODE Mode, [in] D3D12_MEASUREMENTS_ACTION MeasurementsAction, [in]
		// HANDLE hEventToSignalUponCompletion, [out] BOOL *pbFurtherMeasurementsDesired );
		[PreserveSig]
		new HRESULT SetBackgroundProcessingMode(D3D12_BACKGROUND_PROCESSING_MODE Mode, D3D12_MEASUREMENTS_ACTION MeasurementsAction,
			[In] HEVENT hEventToSignalUponCompletion, out bool pbFurtherMeasurementsDesired);

		/// <summary>
		/// Incrementally add to an existing state object. This incurs lower CPU overhead than creating a state object from scratch that is
		/// a superset of an existing one (for example, adding a few more shaders).
		/// </summary>
		/// <param name="pAddition">
		/// <para>Type: _In_ <b>const <c>D3D12_STATE_OBJECT_DESC</c>*</b></para>
		/// <para>
		/// Description of state object contents to add to existing state object. To help generate this see the
		/// <b>CD3D12_STATE_OBJECT_DESC</b> helper in class in <c>d3dx12.h</c>.
		/// </para>
		/// </param>
		/// <param name="pStateObjectToGrowFrom">
		/// <para>Type: _In_ <b><c>ID3D12StateObject</c>*</b></para>
		/// <para>Existing state object, which can be in use (for example, active raytracing) during this operation.</para>
		/// <para>The existing state object must not be of type <b>Collection</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: _In_ <b>REFIID</b></para>
		/// <para>Must be the IID of the <c>ID3D12StateObject</c> interface.</para>
		/// </param>
		/// <param name="ppNewStateObject">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>Returned state object.</para>
		/// <para>
		/// Behavior is undefined if shader identifiers are retrieved for new shaders from this call and they are accessed via shader tables
		/// by any already existing or in-flight command list that references some older state object. Use of the new shaders added to the
		/// state object can occur only from commands (such as <b>DispatchRays</b> or <b>ExecuteIndirect</b> calls) recorded in a command
		/// list after the call to <b>AddToStateObject</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <b>S_OK</b> for success. <b>E_INVALIDARG</b>, <b>E_OUTOFMEMORY</b> on failure. The debug layer provides detailed status information.
		/// </returns>
		/// <remarks>For more info, see <c>AddToStateObject</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device7-addtostateobject HRESULT AddToStateObject( const
		// D3D12_STATE_OBJECT_DESC *pAddition, ID3D12StateObject *pStateObjectToGrowFrom, REFIID riid, void **ppNewStateObject );
		[PreserveSig]
		new HRESULT AddToStateObject(in D3D12_STATE_OBJECT_DESC pAddition, [In] ID3D12StateObject pStateObjectToGrowFrom, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppNewStateObject);

		/// <summary>
		/// <para>
		/// <b>CreateProtectedResourceSession1</b> revises the <c><b>ID3D12Device4::CreateProtectedResourceSession</b></c> method with
		/// provision (in the structure passed via the pDesc parameter) for a globally unique identifier ( <b>GUID</b>) that indicates the
		/// type of protected resource session.
		/// </para>
		/// <para>
		/// Calling <b>ID3D12Device4::CreateProtectedResourceSession</b> is equivalent to calling
		/// <b>ID3D12Device7::CreateProtectedResourceSession1</b> with the <b>D3D12_PROTECTED_RESOURCES_SESSION_HARDWARE_PROTECTED</b> GUID.
		/// </para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_PROTECTED_RESOURCE_SESSION_DESC1</c>*</b></para>
		/// <para>A pointer to a constant <b>D3D12_PROTECTED_RESOURCE_SESSION_DESC1</b> structure, describing the session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: _In_ <b>REFIID</b></para>
		/// <para>
		/// The GUID of the interface to a protected session. Most commonly, <c>ID3D12ProtectedResourceSession1</c>, although it may be any
		/// <b>GUID</b> for any interface. If the protected session object doesn't support the interface for this <b>GUID</b>, the getter
		/// will return <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppSession">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the session for the given protected session (the specific interface type
		/// returned depends on riid).
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device7-createprotectedresourcesession1 HRESULT
		// CreateProtectedResourceSession1( const D3D12_PROTECTED_RESOURCE_SESSION_DESC1 *pDesc, REFIID riid, void **ppSession );
		[PreserveSig]
		new HRESULT CreateProtectedResourceSession1(in D3D12_PROTECTED_RESOURCE_SESSION_DESC1 pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppSession);

		/// <summary>
		/// <para>
		/// Gets rich info about the size and alignment of memory required for a collection of resources on this adapter. Also see <c>ID3D12Device4::GetResourceAllocationInfo1</c>.
		/// </para>
		/// <para>This version also returns an array of <c>D3D12_RESOURCE_DESC1</c> structures.</para>
		/// </summary>
		/// <param name="visibleMask">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's
		/// physical adapters). Each bit in the mask corresponds to a single node. Also see <c>Multi-adapter systems</c>.
		/// </para>
		/// </param>
		/// <param name="numResourceDescs">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of resource descriptors in the pResourceDescs array. This is also the size (the number of elements in) pResourceAllocationInfo1.</para>
		/// </param>
		/// <param name="pResourceDescs">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>An array of <b>D3D12_RESOURCE_DESC1</b> structures that described the resources to get info about.</para>
		/// </param>
		/// <param name="pResourceAllocationInfo1">
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO1</c>*</b></para>
		/// <para>
		/// An array of <c>D3D12_RESOURCE_ALLOCATION_INFO1</c> structures, containing additional details for each resource description
		/// passed as input. This makes it simpler for your application to allocate a heap for multiple resources, and without manually
		/// computing offsets for where each resource should be placed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>D3D12_RESOURCE_ALLOCATION_INFO</c></b></para>
		/// <para>
		/// A <c>D3D12_RESOURCE_ALLOCATION_INFO</c> structure that provides info about video memory allocated for the specified array of resources.
		/// </para>
		/// </returns>
		/// <remarks>For remarks, see <c>ID3D12Device4::GetResourceAllocationInfo1</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-getresourceallocationinfo2(uint_uint_constd3d12_resource_desc1_d3d12_resource_allocation_info1)
		// D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo2( UINT visibleMask, UINT numResourceDescs, const D3D12_RESOURCE_DESC1
		// *pResourceDescs, D3D12_RESOURCE_ALLOCATION_INFO1 *pResourceAllocationInfo1 );
		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo2(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC1[] pResourceDescs,
			[Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[] pResourceAllocationInfo1);

		/// <summary>
		/// Creates both a resource and an implicit heap (optionally for a protected session), such that the heap is big enough to contain
		/// the entire resource, and the resource is mapped to the heap. Also see <c>ID3D12Device::CreateCommittedResource</c> for a code example.
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: _In_ <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialResourceState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>When you create a resource together with a <c>D3D12_HEAP_TYPE_UPLOAD</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_GENERIC_READ</c>.</para>
		/// <para>
		/// When you create a resource together with a <c>D3D12_HEAP_TYPE_READBACK</c> heap, you must set InitialResourceState to <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the
		/// resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the
		/// application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read
		/// nor write to this resource.
		/// </para>
		/// <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <c>Residency</c>.</para>
		/// <para>The resource GPU VA mapping can't be changed. See <c>ID3D12CommandQueue::UpdateTileMappings</c> and <c>Volume tiled resources</c>.</para>
		/// <para>This method may be called by multiple threads concurrently.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createcommittedresource2 HRESULT
		// CreateCommittedResource2( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC1
		// *pDesc, D3D12_RESOURCE_STATES InitialResourceState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, ID3D12ProtectedResourceSession
		// *pProtectedSession, REFIID riidResource, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource2(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC1 pDesc,
			D3D12_RESOURCE_STATES InitialResourceState, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 6)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC1</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialState">
		/// <para>Type: <b><c>D3D12_RESOURCE_STATES</c></b></para>
		/// <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
		/// <para>
		/// When a resource is created together with a <b>D3D12_HEAP_TYPE_UPLOAD</b> heap, InitialState must be
		/// <b>D3D12_RESOURCE_STATE_GENERIC_READ</b>. When a resource is created together with a <b>D3D12_HEAP_TYPE_READBACK</b> heap,
		/// InitialState must be <b>D3D12_RESOURCE_STATE_COPY_DEST</b>.
		/// </para>
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>See <c>ID3D12Device::CreatePlacedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createplacedresource1 HRESULT
		// CreatePlacedResource1( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC1 *pDesc, D3D12_RESOURCE_STATES
		// InitialState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource1([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC1 pDesc, D3D12_RESOURCE_STATES InitialState,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 5)] out object? ppvResource);

		/// <summary>For purposes of sampler feedback, creates a descriptor suitable for binding.</summary>
		/// <param name="pTargetedResource">
		/// <para>Type: _In_opt_ <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The targeted resource, such as a texture, to create a descriptor for.</para>
		/// </param>
		/// <param name="pFeedbackResource">
		/// <para>Type: _In_opt_ <b><c>ID3D12Resource</c>*</b></para>
		/// <para>The feedback resource, such as a texture, to create a descriptor for.</para>
		/// </param>
		/// <param name="DestDescriptor">
		/// <para>Type: _In_ <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>The CPU descriptor handle.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-createsamplerfeedbackunorderedaccessview void
		// CreateSamplerFeedbackUnorderedAccessView( ID3D12Resource *pTargetedResource, ID3D12Resource *pFeedbackResource,
		// D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor );
		[PreserveSig]
		new void CreateSamplerFeedbackUnorderedAccessView([In, Optional] ID3D12Resource? pTargetedResource, [In, Optional] ID3D12Resource? pFeedbackResource,
			D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		/// <summary>
		/// Gets a resource layout that can be copied. Helps your app fill in <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> and
		/// <c>D3D12_SUBRESOURCE_FOOTPRINT</c> when suballocating space in upload heaps.
		/// </summary>
		/// <param name="pResourceDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A description of the resource, as a pointer to a <b>D3D12_RESOURCE_DESC1</b> structure.</para>
		/// </param>
		/// <param name="FirstSubresource">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>Index of the first subresource in the resource. The range of valid values is 0 to D3D12_REQ_SUBRESOURCES.</para>
		/// </param>
		/// <param name="NumSubresources">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The number of subresources in the resource. The range of valid values is 0 to (D3D12_REQ_SUBRESOURCES - <i>FirstSubresource</i>).</para>
		/// </param>
		/// <param name="BaseOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset, in bytes, to the resource.</para>
		/// </param>
		/// <param name="pLayouts">
		/// <para>Type: [out, optional] <b><c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c>*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of <c>D3D12_PLACED_SUBRESOURCE_FOOTPRINT</c> structures, to be filled
		/// with the description and placement of each subresource.
		/// </para>
		/// </param>
		/// <param name="pNumRows">
		/// <para>Type: [out, optional] <b>UINT*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, to be filled with the number of rows for each subresource.
		/// </para>
		/// </param>
		/// <param name="pRowSizeInBytes">
		/// <para>Type: [out, optional] <b>UINT64*</b></para>
		/// <para>
		/// A pointer to an array (of length <i>NumSubresources</i>) of integer variables, each entry to be filled with the unpadded size in
		/// bytes of a row, of each subresource.
		/// </para>
		/// <para>For example, if a Texture2D resource has a width of 32 and bytes per pixel of 4, then <i>pRowSizeInBytes</i> returns 128.</para>
		/// <para>
		/// <i>pRowSizeInBytes</i> should not be confused with <b>row pitch</b>, as examining <i>pLayouts</i> and getting the row pitch from
		/// that will give you 256 as it is aligned to D3D12_TEXTURE_DATA_PITCH_ALIGNMENT.
		/// </para>
		/// </param>
		/// <param name="pTotalBytes">
		/// <para>Type: [out, optional] <b>UINT64*</b></para>
		/// <para>A pointer to an integer variable, to be filled with the total size, in bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>For remarks and examples, see <c>ID3D12Device::GetCopyableFootprints</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device8-getcopyablefootprints1 void
		// GetCopyableFootprints1( const D3D12_RESOURCE_DESC1 *pResourceDesc, UINT FirstSubresource, UINT NumSubresources, UINT64
		// BaseOffset, D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts, UINT *pNumRows, UINT64 *pRowSizeInBytes, UINT64 *pTotalBytes );
		[PreserveSig]
		new void GetCopyableFootprints1(in D3D12_RESOURCE_DESC1 pResourceDesc, uint FirstSubresource, int NumSubresources, ulong BaseOffset,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] D3D12_PLACED_SUBRESOURCE_FOOTPRINT[]? pLayouts,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[]? pNumRows,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] ulong[]? pRowSizeInBytes, out ulong pTotalBytes);

		/// <summary>
		/// Creates an object that grants access to a shader cache, potentially opening an existing cache or creating a new one.
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_SHADER_CACHE_SESSION_DESC</c>*</b></para>
		/// <para>A <b>D3D12_SHADER_CACHE_SESSION_DESC</b> structure describing the shader cache session to create.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>The globally unique identifier (GUID) for the shader cache session interface.</para>
		/// </param>
		/// <param name="ppvSession">
		/// <para>Type: _COM_Outptr_opt_ <b>void**</b></para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the <c>ID3D12ShaderCacheSession</c> interface for the shader cache session.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>DXGI_ERROR_ALREADY_EXISTS</description>
		/// <description>You tried to create a cache with an existing identifier. See <c>D3D12_SHADER_CACHE_SESSION_DESC::Identifier</c>.</description>
		/// </item>
		/// </list>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-createshadercachesession HRESULT
		// CreateShaderCacheSession( const D3D12_SHADER_CACHE_SESSION_DESC *pDesc, REFIID riid, void **ppvSession );
		[PreserveSig]
		new HRESULT CreateShaderCacheSession(in D3D12_SHADER_CACHE_SESSION_DESC pDesc, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 1)] out object? ppvSession);

		/// <summary>
		/// Modifies the behavior of caches used internally by Direct3D or by the driver. <b>ShaderCacheControl</b> may be used only in
		/// developer mode.
		/// </summary>
		/// <param name="Kinds">
		/// <para>Type: <b><c>D3D12_SHADER_CACHE_KIND_FLAGS</c></b></para>
		/// <para>The caches to modify. Any one of these caches may or may not exist.</para>
		/// </param>
		/// <param name="Control">
		/// <para>Type: <b><c>D3D12_SHADER_CACHE_CONTROL_FLAGS</c></b></para>
		/// <para>
		/// The way in which to modify the caches. You can't pass both <b>DISABLE</b> and <b>ENABLE</b> at the same time; and you must pass
		/// at least one flag.
		/// </para>
		/// </param>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-shadercachecontrol HRESULT ShaderCacheControl(
		// D3D12_SHADER_CACHE_KIND_FLAGS Kinds, D3D12_SHADER_CACHE_CONTROL_FLAGS Control );
		[PreserveSig]
		new HRESULT ShaderCacheControl(D3D12_SHADER_CACHE_KIND_FLAGS Kinds, D3D12_SHADER_CACHE_CONTROL_FLAGS Control);

		/// <summary>
		/// <para>Creates a command queue with a creator ID.</para>
		/// <para>Also see <c>ID3D12Device::CreateCommandQueue</c>.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: _In_ <b>const <c>D3D12_COMMAND_QUEUE_DESC</c>*</b></para>
		/// <para>Specifies a <b>D3D12_COMMAND_QUEUE_DESC</b> that describes the command queue.</para>
		/// </param>
		/// <param name="CreatorID">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>A creator ID. See <b>Remarks</b>.</para>
		/// </param>
		/// <param name="riid">
		/// <para>Type: <b><c>REFIID</c></b></para>
		/// <para>The globally unique identifier (GUID) for the command queue interface.</para>
		/// </param>
		/// <param name="ppCommandQueue">
		/// <para>Type: _COM_Outptr_ <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12CommandQueue</c> interface for the command queue.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// Returns <b>E_OUTOFMEMORY</b> if there's insufficient memory to create the command queue; otherwise <b>S_OK</b>. See <c>Direct3D
		/// 12 return codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// When multiple components in the same process are sharing a single Direct3D 12 device, often they will end up with separate
		/// workloads on independent command queues. In some hardware implementations, independent queues can run in parallel only with
		/// specific other command queues.
		/// </para>
		/// <para>
		/// Direct3D 12 applies a first-come, first-serve grouping for queues, which might not work well for all application or component
		/// designs. To help inform Direct3D 12's grouping of queues, you can specify a creator ID (which is unique per component) that
		/// restricts the grouping to other queues with the same ID. When possible, a component should choose the same unique ID for all of
		/// its queues. Microsoft has reserved a few well-known creator IDs for use by Microsoft-developed implementations of APIs on top of
		/// Direct3D 12.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device9-createcommandqueue1 HRESULT CreateCommandQueue1(
		// const D3D12_COMMAND_QUEUE_DESC *pDesc, REFIID CreatorID, REFIID riid, void **ppCommandQueue );
		[PreserveSig]
		new HRESULT CreateCommandQueue1(in D3D12_COMMAND_QUEUE_DESC pDesc, in Guid CreatorID, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppCommandQueue);

		/// <summary>
		/// <para>Creates a committed resource with an initial layout rather than an initial state.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pHeapProperties">
		/// <para>Type: _In_ <b>const <c>D3D12_HEAP_PROPERTIES</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
		/// </param>
		/// <param name="HeapFlags">
		/// <para>Type: <b><c>D3D12_HEAP_FLAGS</c></b></para>
		/// <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC1</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC1</b> structure that describes the resource, including a mip region.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riidResource">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createcommittedresource3 HRESULT
		// CreateCommittedResource3( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC1
		// *pDesc, D3D12_BARRIER_LAYOUT InitialLayout, const D3D12_CLEAR_VALUE *pOptimizedClearValue, ID3D12ProtectedResourceSession
		// *pProtectedSession, UINT32 NumCastableFormats, const DXGI_FORMAT *pCastableFormats, REFIID riidResource, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateCommittedResource3(in D3D12_HEAP_PROPERTIES pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, in D3D12_RESOURCE_DESC1 pDesc,
			D3D12_BARRIER_LAYOUT InitialLayout, [In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue,
			[In, Optional] ID3D12ProtectedResourceSession? pProtectedSession, int NumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 6)] DXGI_FORMAT[]? pCastableFormats, in Guid riidResource,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 8)] out object? ppvResource);

		/// <summary>
		/// <para>
		/// Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and
		/// are the fastest to create and destroy.
		/// </para>
		/// <para>
		/// Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The
		/// simple memory re-use model (described in <c>Remarks</c>) exists to clarify which overlapping resource is valid at any given
		/// time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and
		/// sub-resource invalidation isn't supported. Onlyfull overlapping resource invalidation occurs.
		/// </para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pHeap">
		/// <para>Type: [in] <b><c>ID3D12Heap</c></b>*</para>
		/// <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
		/// </param>
		/// <param name="HeapOffset">
		/// <para>Type: <b><c>UINT64</c></b></para>
		/// <para>
		/// The offset, in bytes, to the resource. The HeapOffset must be a multiple of the resource's alignment, and HeapOffset plus the
		/// resource size must be smaller than or equal to the heap size. <c><b>GetResourceAllocationInfo</b></c> must be used to understand
		/// the sizes of texture resources.
		/// </para>
		/// </param>
		/// <param name="pDesc">
		/// <para>Type: [in] <b>const <c>D3D12_RESOURCE_DESC</c></b>*</para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: [in, optional] <b>const <c>D3D12_CLEAR_VALUE</c></b>*</para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, your application should choose the value that the clear operation will most commonly be called with.
		/// </para>
		/// <para>
		/// Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the
		/// one passed into resource creation.
		/// </para>
		/// <para><paramref name="pOptimizedClearValue"/> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>The globally unique identifier ( <b>GUID</b>) for the resource interface. This is an input parameter.</para>
		/// <para>
		/// The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <c>__uuidof</c> macro. For
		/// example, <c>__uuidof(ID3D12Resource)</c> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most
		/// commonly, the GUID for <c><b>ID3D12Resource</b></c>, it may be any <b>GUID</b> for any interface. If the resource object doesn't
		/// support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: [out, optional] <b>void</b>**</para>
		/// <para>
		/// A pointer to a memory block that receives a pointer to the resource. ppvResource can be NULL, to enable capability testing. When
		/// ppvResource is NULL, no object will be created and S_FALSE will be returned when pResourceDesc and other parameters are valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>
		/// This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <c>Direct3D 12 Return
		/// Codes</c> for other possible return values.
		/// </para>
		/// </returns>
		/// <remarks>See <b>Remarks</b> for <c>ID3D12Device::CreatePlacedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createplacedresource2 HRESULT
		// CreatePlacedResource2( ID3D12Heap *pHeap, UINT64 HeapOffset, const D3D12_RESOURCE_DESC1 *pDesc, D3D12_BARRIER_LAYOUT
		// InitialLayout, const D3D12_CLEAR_VALUE *pOptimizedClearValue, UINT32 NumCastableFormats, const DXGI_FORMAT *pCastableFormats,
		// REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreatePlacedResource2([In] ID3D12Heap pHeap, ulong HeapOffset, in D3D12_RESOURCE_DESC1 pDesc, D3D12_BARRIER_LAYOUT InitialLayout,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, int NumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 5)] DXGI_FORMAT[] pCastableFormats, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 7)] out object? ppvResource);

		/// <summary>
		/// <para>Creates a resource that is reserved, and not yet mapped to any pages in a heap.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.7 or later.</para>
		/// </summary>
		/// <param name="pDesc">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_DESC</c>*</b></para>
		/// <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
		/// </param>
		/// <param name="InitialLayout">
		/// The initial layout of the texture resource; <b>D3D12_BARRIER_LAYOUT::D3D12_BARRIER_LAYOUT_UNDEFINED</b> for buffers.
		/// </param>
		/// <param name="pOptimizedClearValue">
		/// <para>Type: <b>const <c>D3D12_CLEAR_VALUE</c>*</b></para>
		/// <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
		/// <para>
		/// <paramref name="pOptimizedClearValue"/> specifies a value for which clear operations are most optimal. When the created resource
		/// is a texture with either the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b>
		/// flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation
		/// with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.
		/// </para>
		/// <para>When you use <c>D3D12_RESOURCE_DIMENSION_BUFFER</c>, you must set pOptimizedClearValue to <c>nullptr</c>.</para>
		/// </param>
		/// <param name="pProtectedSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an object that represents a session for content protection. If provided, this session indicates that the
		/// resource should be protected. You can obtain an <b>ID3D12ProtectedResourceSession</b> by calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <param name="NumCastableFormats">The number of elements in pCastableFormats.</param>
		/// <param name="pCastableFormats">A contiguous array of <c>DXGI_FORMAT</c> structures that this resource can be cast to.</param>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>A reference to the globally unique identifier ( <b>GUID</b>) of the resource interface to return in ppvResource. See <b>Remarks</b>.</para>
		/// <para>
		/// While riidResource is most commonly the <b>GUID</b> of <c>ID3D12Resource</c>, it may be the <b>GUID</b> of any interface. If the
		/// resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.
		/// </para>
		/// </param>
		/// <param name="ppvResource">
		/// <para>Type: <b>void**</b></para>
		/// <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
		/// <para>
		/// <paramref name="ppvResource"/> can be <c>nullptr</c>, to enable capability testing. When ppvResource is <c>nullptr</c>, no
		/// object is created, and <b>S_FALSE</b> is returned when pDesc is valid.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <c><b>HRESULT</b></c><c>error code</c>.</para>
		/// <list type="table">
		/// <listheader>
		/// <description>Return value</description>
		/// <description>Description</description>
		/// </listheader>
		/// <item>
		/// <description>E_OUTOFMEMORY</description>
		/// <description>There is insufficient memory to create the resource.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 return codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>See <b>Remarks</b> for <c>ID3D12Device.CreateReservedResource</c>.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device10-createreservedresource2 HRESULT
		// CreateReservedResource2( const D3D12_RESOURCE_DESC *pDesc, D3D12_BARRIER_LAYOUT InitialLayout, const D3D12_CLEAR_VALUE
		// *pOptimizedClearValue, ID3D12ProtectedResourceSession *pProtectedSession, UINT32 NumCastableFormats, const DXGI_FORMAT
		// *pCastableFormats, [in] REFIID riid, void **ppvResource );
		[PreserveSig]
		new HRESULT CreateReservedResource2(in D3D12_RESOURCE_DESC pDesc, D3D12_BARRIER_LAYOUT InitialLayout,
			[In, Optional] StructPointer<D3D12_CLEAR_VALUE> pOptimizedClearValue, [In, Optional] ID3D12ProtectedResourceSession? pProtectedSession,
			int NumCastableFormats, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] DXGI_FORMAT[]? pCastableFormats,
			in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 7)] out object? ppvResource);

		[PreserveSig]
		new void CreateSampler2(in D3D12_SAMPLER_DESC pDesc, [In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor);

		[PreserveSig]
		new D3D12_RESOURCE_ALLOCATION_INFO GetResourceAllocationInfo3(uint visibleMask, int numResourceDescs,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_DESC1[] pResourceDescs,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] uint[]? pNumCastableFormats,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] DXGI_FORMAT[]? ppCastableFormats,
			[Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RESOURCE_ALLOCATION_INFO1[]? pResourceAllocationInfo1);

		[PreserveSig]
		new HRESULT OpenExistingHeapFromAddress1([In] IntPtr pAddress, SizeT size, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 2)] out object? ppvHeap);

		[PreserveSig]
		HRESULT CreateRootSignatureFromSubobjectInLibrary(uint nodeMask, [In] IntPtr pLibraryBlob, SizeT blobLengthInBytes,
			[Optional, MarshalAs(UnmanagedType.LPWStr)] string? subobjectName, in Guid riid,
			[MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 4)] out object? ppvRootSignature);
	}

	[ComImport]
	[Guid("61552388-01ab-4008-a436-83db189566ea")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ID3D12DeviceRemovedExtendedDataSettings2 : ID3D12DeviceRemovedExtendedDataSettings1, ID3D12DeviceRemovedExtendedDataSettings
	{
		/// <summary>Configures the enablement settings for Device Removed Extended Data (DRED) auto-breadcrumbs.</summary>
		/// <param name="Enablement">A <c>D3D12_DRED_ENABLEMENT</c> value. The default is <b>D3D12_DRED_ENABLEMENT_SYSTEM_CONTROLLED</b>.</param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12deviceremovedextendeddatasettings-setautobreadcrumbsenablement
		// void SetAutoBreadcrumbsEnablement( D3D12_DRED_ENABLEMENT Enablement );
		[PreserveSig]
		new void SetAutoBreadcrumbsEnablement(D3D12_DRED_ENABLEMENT Enablement);

		/// <summary>Configures the enablement settings for Device Removed Extended Data (DRED) page fault reporting.</summary>
		/// <param name="Enablement">A <c>D3D12_DRED_ENABLEMENT</c> value. The default is <b>D3D12_DRED_ENABLEMENT_SYSTEM_CONTROLLED</b>.</param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12deviceremovedextendeddatasettings-setpagefaultenablement
		// void SetPageFaultEnablement( D3D12_DRED_ENABLEMENT Enablement );
		[PreserveSig]
		new void SetPageFaultEnablement(D3D12_DRED_ENABLEMENT Enablement);

		/// <summary>
		/// Configures the enablement settings for Device Removed Extended Data (DRED) dump creation for <c>Windows Error Reporting
		/// (WER)</c>, also known as Watson.
		/// </summary>
		/// <param name="Enablement">A <c>D3D12_DRED_ENABLEMENT</c> value. The default is <b>D3D12_DRED_ENABLEMENT_SYSTEM_CONTROLLED</b>.</param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12deviceremovedextendeddatasettings-setwatsondumpenablement
		// void SetWatsonDumpEnablement( D3D12_DRED_ENABLEMENT Enablement );
		[PreserveSig]
		new void SetWatsonDumpEnablement(D3D12_DRED_ENABLEMENT Enablement);

		/// <summary/>
		/// <param name="Enablement"/>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12deviceremovedextendeddatasettings1-setbreadcrumbcontextenablement
		// void SetBreadcrumbContextEnablement( D3D12_DRED_ENABLEMENT Enablement );
		[PreserveSig]
		new void SetBreadcrumbContextEnablement(D3D12_DRED_ENABLEMENT Enablement);

		[PreserveSig]
		void UseMarkersOnlyAutoBreadcrumbs(bool MarkersOnly);
	}

	[ComImport]
	[Guid("7013c015-d161-4b63-a08c-238552dd8acc")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ID3D12GraphicsCommandList10 : ID3D12GraphicsCommandList9, ID3D12GraphicsCommandList8, ID3D12GraphicsCommandList7, ID3D12GraphicsCommandList6, ID3D12GraphicsCommandList5, ID3D12GraphicsCommandList4, ID3D12GraphicsCommandList3, ID3D12GraphicsCommandList2, ID3D12GraphicsCommandList1, ID3D12GraphicsCommandList, ID3D12CommandList, ID3D12DeviceChild, ID3D12Object
	{
		/// <summary>Gets application-defined data from a device object.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> that is associated with the data.</para>
		/// </param>
		/// <param name="pDataSize">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a variable that on input contains the size, in bytes, of the buffer that <i>pData</i> points to, and on output
		/// contains the size, in bytes, of the amount of data that <b>GetPrivateData</b> retrieved.
		/// </para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a memory block that receives the data from the device object if <i>pDataSize</i> points to a value that specifies a
		/// buffer large enough to hold the data.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// If the data returned is a pointer to an <c>IUnknown</c>, or one of its derivative classes, which was previously set by
		/// SetPrivateDataInterface, that interface will have its reference count incremented before the private data is returned.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-getprivatedata HRESULT GetPrivateData( [in]
		// REFGUID guid, [in, out] UINT *pDataSize, [out, optional] void *pData );
		[PreserveSig]
		new HRESULT GetPrivateData(in Guid guid, ref uint pDataSize, [Out, Optional] IntPtr pData);

		/// <summary>Sets application-defined data to a device object and associates that data with an application-defined <b>GUID</b>.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the data.</para>
		/// </param>
		/// <param name="DataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size in bytes of the data.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>
		/// A pointer to a memory block that contains the data to be stored with this device object. If <i>pData</i> is <b>NULL</b>,
		/// <i>DataSize</i> must also be 0, and any data that was previously associated with the <b>GUID</b> specified in <i>guid</i> will
		/// be destroyed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// Rather than using the Direct3D 11 debug object naming scheme of calling <b>ID3D12Object::SetPrivateData</b> using
		/// <b>WKPDID_D3DDebugObjectName</b> with an ASCII name, call <c>ID3D12Object::SetName</c> with a UNICODE name.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedata HRESULT SetPrivateData( [in]
		// REFGUID guid, [in] UINT DataSize, [in, optional] const void *pData );
		[PreserveSig]
		new HRESULT SetPrivateData(in Guid guid, uint DataSize, [In, Optional] IntPtr pData);

		/// <summary>
		/// Associates an <c>IUnknown</c>-derived interface with the device object, and associates that interface with an
		/// application-defined <b>GUID</b>.
		/// </summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the interface.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const <c>IUnknown</c>*</b></para>
		/// <para>
		/// A pointer to the <c>IUnknown</c>-derived interface to be associated with the device object. Its reference count is incremented
		/// when set, and its reference count is decremented when either the <c>ID3D12Object</c> is destroyed, or when the data is
		/// overwritten by calling <c>SetPrivateData</c> or <b>SetPrivateDataInterface</b> with the same <b>GUID</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 return codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedatainterface HRESULT
		// SetPrivateDataInterface( [in] REFGUID guid, [in, optional] const IUnknown *pData );
		[PreserveSig]
		new HRESULT SetPrivateDataInterface(in Guid guid, [In, Optional, MarshalAs(UnmanagedType.Interface)] object? pData);

		/// <summary>Associates a name with the device object. This name is for use in debug diagnostics and tools.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the device object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>This method takes UNICODE names.</para>
		/// <para>
		/// Note that this is simply a convenience wrapper around <c>ID3D12Object::SetPrivateData</c> with
		/// <b>WKPDID_D3DDebugObjectNameW</b>. Therefore names which are set with <c>SetName</c> can be retrieved with
		/// <c>ID3D12Object::GetPrivateData</c> with the same GUID. Additionally, D3D12 supports narrow strings for names, using the
		/// <b>WKPDID_D3DDebugObjectName</b> GUID directly instead.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setname HRESULT SetName( [in] LPCWSTR Name );
		[PreserveSig]
		new HRESULT SetName([MarshalAs(UnmanagedType.LPWStr)] string Name);

		/// <summary>Gets a pointer to the device that created this interface.</summary>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier (<b>GUID</b>) for the device interface. The <b>REFIID</b>, or <b>GUID</b>, of the interface to
		/// the device can be obtained by using the __uuidof() macro. For example, __uuidof(<c>ID3D12Device</c>) will get the <b>GUID</b>
		/// of the interface to a device.
		/// </para>
		/// </param>
		/// <param name="ppvDevice">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12Device</c> interface for the device.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Any returned interfaces have their reference count incremented by one, so be sure to call ::release() on the returned pointers
		/// before they are freed or else you will have a memory leak.
		///  Examples The <c>D3D12Multithreading</c> sample uses <b>ID3D12DeviceChild::GetDevice</b> as follows:</para>
		/// <code language="cpp">
		///<![CDATA[// Returns required size of a buffer to be used for data upload
		///inline UINT64 GetRequiredIntermediateSize(
		///   _In_ ID3D12Resource* pDestinationResource,
		///   _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		///   _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources)
		///{
		///   D3D12_RESOURCE_DESC Desc = pDestinationResource->GetDesc();
		///   UINT64 RequiredSize = 0;
		///
		///   ID3D12Device* pDevice;
		///   pDestinationResource->GetDevice(__uuidof(*pDevice), reinterpret_cast<void**>(&pDevice));
		///   pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, 0, nullptr, nullptr, nullptr, &RequiredSize);
		///   pDevice->Release();
		///
		///   return RequiredSize;
		///}]]>
		/// </code>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12devicechild-getdevice HRESULT GetDevice( REFIID riid,
		// [out, optional] void **ppvDevice );
		[PreserveSig]
		new HRESULT GetDevice(in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 0)] out object? ppvDevice);

		/// <summary>Gets the type of the command list, such as direct, bundle, compute, or copy.</summary>
		/// <returns>
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>
		/// This method returns the type of the command list, as a <c>D3D12_COMMAND_LIST_TYPE</c> enumeration constant, such as direct,
		/// bundle, compute, or copy.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12commandlist-gettype D3D12_COMMAND_LIST_TYPE GetType();
		[PreserveSig]
		new D3D12_COMMAND_LIST_TYPE GetType();

		/// <summary>Indicates that recording to the command list has finished.</summary>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// <b>E_FAIL</b> if the command list has already been closed, or an invalid API was called during command list recording.
		/// </description>
		/// </item>
		/// <item>
		/// <description><b>E_OUTOFMEMORY</b> if the operating system ran out of memory during recording.</description>
		/// </item>
		/// <item>
		/// <description><b>E_INVALIDARG</b> if an invalid argument was passed to the command list API during recording.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 Return Codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The runtime will validate that the command list has not previously been closed. If an error was encountered during recording,
		/// the error code is returned here. The runtime won't call the close device driver interface (DDI) in this case. Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::Close</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::LoadAssets() { // Create an empty root signature. { CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
		/// rootSignatureDesc.Init(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);
		/// ComPtr&lt;ID3DBlob&gt; signature; ComPtr&lt;ID3DBlob&gt; error;
		/// ThrowIfFailed(D3D12SerializeRootSignature(&amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &amp;signature, &amp;error));
		/// ThrowIfFailed(m_device-&gt;CreateRootSignature(0, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(),
		/// IID_PPV_ARGS(&amp;m_rootSignature))); } // Create the pipeline state, which includes compiling and loading shaders. {
		/// ComPtr&lt;ID3DBlob&gt; vertexShader; ComPtr&lt;ID3DBlob&gt; pixelShader; #if defined(_DEBUG) // Enable better shader debugging
		/// with the graphics debugging tools. UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION; #else UINT compileFlags
		/// = 0; #endif ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L"shaders.hlsl").c_str(), nullptr, nullptr, "VSMain", "vs_5_0",
		/// compileFlags, 0, &amp;vertexShader, nullptr)); ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L"shaders.hlsl").c_str(),
		/// nullptr, nullptr, "PSMain", "ps_5_0", compileFlags, 0, &amp;pixelShader, nullptr)); // Define the vertex input layout.
		/// D3D12_INPUT_ELEMENT_DESC inputElementDescs[] = { { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,
		/// D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, { "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12,
		/// D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 } }; // Describe and create the graphics pipeline state object (PSO).
		/// D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = {}; psoDesc.InputLayout = { inputElementDescs, _countof(inputElementDescs) };
		/// psoDesc.pRootSignature = m_rootSignature.Get(); psoDesc.VS = {
		/// reinterpret_cast&lt;UINT8*&gt;(vertexShader-&gt;GetBufferPointer()), vertexShader-&gt;GetBufferSize() }; psoDesc.PS = {
		/// reinterpret_cast&lt;UINT8*&gt;(pixelShader-&gt;GetBufferPointer()), pixelShader-&gt;GetBufferSize() }; psoDesc.RasterizerState =
		/// CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT); psoDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
		/// psoDesc.DepthStencilState.DepthEnable = FALSE; psoDesc.DepthStencilState.StencilEnable = FALSE; psoDesc.SampleMask = UINT_MAX;
		/// psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE; psoDesc.NumRenderTargets = 1; psoDesc.RTVFormats[0] =
		/// DXGI_FORMAT_R8G8B8A8_UNORM; psoDesc.SampleDesc.Count = 1; ThrowIfFailed(m_device-&gt;CreateGraphicsPipelineState(&amp;psoDesc,
		/// IID_PPV_ARGS(&amp;m_pipelineState))); } // Create the command list. ThrowIfFailed(m_device-&gt;CreateCommandList(0,
		/// D3D12_COMMAND_LIST_TYPE_DIRECT, m_commandAllocator.Get(), m_pipelineState.Get(), IID_PPV_ARGS(&amp;m_commandList))); // Command
		/// lists are created in the recording state, but there is nothing // to record yet. The main loop expects it to be closed, so close
		/// it now. ThrowIfFailed(m_commandList-&gt;Close()); // Create the vertex buffer. { // Define the geometry for a triangle. Vertex
		/// triangleVertices[] = { { { 0.0f, 0.25f * m_aspectRatio, 0.0f }, { 1.0f, 0.0f, 0.0f, 1.0f } }, { { 0.25f, -0.25f * m_aspectRatio,
		/// 0.0f }, { 0.0f, 1.0f, 0.0f, 1.0f } }, { { -0.25f, -0.25f * m_aspectRatio, 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f } } }; const UINT
		/// vertexBufferSize = sizeof(triangleVertices); // Note: using upload heaps to transfer static data like vert buffers is not //
		/// recommended. Every time the GPU needs it, the upload heap will be marshalled // over. Please read up on Default Heap usage. An
		/// upload heap is used here for // code simplicity and because there are very few verts to actually transfer.
		/// ThrowIfFailed(m_device-&gt;CreateCommittedResource( &amp;CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD), D3D12_HEAP_FLAG_NONE,
		/// &amp;D3D12_RESOURCE_DESC::Buffer(vertexBufferSize), D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		/// IID_PPV_ARGS(&amp;m_vertexBuffer))); // Copy the triangle data to the vertex buffer. UINT8* pVertexDataBegin; CD3DX12_RANGE
		/// readRange(0, 0); // We do not intend to read from this resource on the CPU. ThrowIfFailed(m_vertexBuffer-&gt;Map(0,
		/// &amp;readRange, reinterpret_cast&lt;void**&gt;(&amp;pVertexDataBegin))); memcpy(pVertexDataBegin, triangleVertices,
		/// sizeof(triangleVertices)); m_vertexBuffer-&gt;Unmap(0, nullptr); // Initialize the vertex buffer view.
		/// m_vertexBufferView.BufferLocation = m_vertexBuffer-&gt;GetGPUVirtualAddress(); m_vertexBufferView.StrideInBytes =
		/// sizeof(Vertex); m_vertexBufferView.SizeInBytes = vertexBufferSize; } // Create synchronization objects and wait until assets
		/// have been uploaded to the GPU. { ThrowIfFailed(m_device-&gt;CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&amp;m_fence)));
		/// m_fenceValue = 1; // Create an event handle to use for frame synchronization. m_fenceEvent = CreateEvent(nullptr, FALSE, FALSE,
		/// nullptr); if (m_fenceEvent == nullptr) { ThrowIfFailed(HRESULT_FROM_WIN32(GetLastError())); } // Wait for the command list to
		/// execute; we are reusing the same command // list in our main loop but for now, we just want to wait for setup to // complete
		/// before continuing. WaitForPreviousFrame(); } }</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-close HRESULT Close();
		[PreserveSig]
		new HRESULT Close();

		/// <summary>Resets a command list back to its initial state as if a new command list was just created.</summary>
		/// <param name="pAllocator">
		/// <para>Type: <b>ID3D12CommandAllocator*</b></para>
		/// <para>A pointer to the <c>ID3D12CommandAllocator</c> object that the device creates command lists from.</para>
		/// </param>
		/// <param name="pInitialState">
		/// <para>Type: <b>ID3D12PipelineState*</b></para>
		/// <para>
		/// A pointer to the <c>ID3D12PipelineState</c> object that contains the initial pipeline state for the command list. This is
		/// optional and can be NULL. If NULL, the runtime sets a dummy initial pipeline state so that drivers don't have to deal with
		/// undefined state. The overhead for this is low, particularly for a command list, for which the overall cost of recording the
		/// command list likely dwarfs the cost of one initial state setting. So there is little cost in not setting the initial pipeline
		/// state parameter if it isn't convenient.
		/// </para>
		/// <para>
		/// For bundles on the other hand, it might make more sense to try to set the initial state parameter since bundles are likely
		/// smaller overall and can be reused frequently.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// <b>E_FAIL</b> if the command list was not in the "closed" state when the <b>Reset</b> call was made, or the per-device limit
		/// would have been exceeded.
		/// </description>
		/// </item>
		/// <item>
		/// <description><b>E_OUTOFMEMORY</b> if the operating system ran out of memory.</description>
		/// </item>
		/// <item>
		/// <description>
		/// <b>E_INVALIDARG</b> if the allocator is currently being used with another command list in the "recording" state or if the
		/// specified allocator was created with the wrong type.
		/// </description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 Return Codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// By using <b>Reset</b>, you can re-use command list tracking structures without any allocations. Unlike
		/// <c>ID3D12CommandAllocator::Reset</c>, you can call <b>Reset</b> while the command list is still being executed.
		/// </para>
		/// <para>You can use <b>Reset</b> for both direct command lists and bundles.</para>
		/// <para>
		/// The command allocator passed to <b>Reset</b> cannot be associated with any other currently-recording command list. The allocator
		/// type, direct command list or bundle, must match the type of command list that is being created.
		/// </para>
		/// <para>
		/// If a bundle doesn't specify a resource heap, it can't make changes to which descriptor tables are bound. Either way, bundles
		/// can't change the resource heap within the bundle. If a heap is specified for a bundle, the heap must match the calling 'parent'
		/// command lists heap.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>
		/// Before an app calls <b>Reset</b>, the command list must be in the "closed" state. <b>Reset</b> will fail if the command list
		/// isn't in the "closed" state.
		/// </para>
		/// <para>
		/// <b>Note</b>If a call to <c>ID3D12GraphicsCommandList::Close</c> fails, the command list can never be reset. Calling
		/// <b>Reset</b> will result in the same error being returned that <b>ID3D12GraphicsCommandList::Close</b> returned.
		/// </para>
		/// <para></para>
		/// <para>
		/// After <b>Reset</b> succeeds, the command list is left in the "recording" state. <b>Reset</b> will fail if it would cause the
		/// maximum concurrently recording command list limit, which is specified at device creation, to be exceeded.
		/// </para>
		/// <para>
		/// Apps must specify a command list allocator. The runtime will ensure that an allocator is never associated with more than one
		/// recording command list at the same time.
		/// </para>
		/// <para><b>Reset</b> fails for bundles that are referenced by a not yet submitted command list.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>
		/// The debug layer will also track graphics processing unit (GPU) progress and issue an error if it can't prove that there are no
		/// outstanding executions of the command list. Examples The <c>D3D12HelloTriangle</c> sample uses
		/// <b>ID3D12GraphicsCommandList::Reset</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset HRESULT Reset( [in]
		// ID3D12CommandAllocator *pAllocator, [in, optional] ID3D12PipelineState *pInitialState );
		[PreserveSig]
		new HRESULT Reset([In] ID3D12CommandAllocator pAllocator, [In, Optional] ID3D12PipelineState? pInitialState);

		/// <summary>Resets the state of a direct command list back to the state it was in when the command list was created.</summary>
		/// <param name="pPipelineState">
		/// <para>Type: <b><c>ID3D12PipelineState</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12PipelineState</c> object that contains the initial pipeline state for the command list.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// It is invalid to call <b>ClearState</b> on a bundle. If an app calls <b>ClearState</b> on a bundle, the call to <c>Close</c>
		/// will return <b>E_FAIL</b>.
		/// </para>
		/// <para>
		/// When <b>ClearState</b> is called, all currently bound resources are unbound. The primitive topology is set to
		/// <c>D3D_PRIMITIVE_TOPOLOGY_UNDEFINED</c>. Viewports, scissor rectangles, stencil reference value, and the blend factor are set to
		/// empty values (all zeros). Predication is disabled.
		/// </para>
		/// <para>The app-provided pipeline state object becomes bound as the currently set pipeline state object.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearstate void ClearState( [in,
		// optional] ID3D12PipelineState *pPipelineState );
		[PreserveSig]
		new void ClearState([In, Optional] ID3D12PipelineState? pPipelineState);

		/// <summary>Draws non-indexed, instanced primitives.</summary>
		/// <param name="VertexCountPerInstance">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of vertices to draw.</para>
		/// </param>
		/// <param name="InstanceCount">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of instances to draw.</para>
		/// </param>
		/// <param name="StartVertexLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Index of the first vertex.</para>
		/// </param>
		/// <param name="StartInstanceLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>A value added to each index before reading per-instance data from a vertex buffer.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>A draw API submits work to the rendering pipeline.</para>
		/// <para>
		/// Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing
		/// could be to draw the same object with different positions and colors.
		/// </para>
		/// <para>
		/// The vertex data for an instanced draw call typically comes from a vertex buffer that is bound to the pipeline. But, you could
		/// also provide the vertex data from a shader that has instanced data identified with a system-value semantic (SV_InstanceID).
		/// Examples The <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::DrawInstanced</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-drawinstanced void DrawInstanced(
		// [in] UINT VertexCountPerInstance, [in] UINT InstanceCount, [in] UINT StartVertexLocation, [in] UINT StartInstanceLocation );
		[PreserveSig]
		new void DrawInstanced(uint VertexCountPerInstance, uint InstanceCount, uint StartVertexLocation, uint StartInstanceLocation);

		/// <summary>Draws indexed, instanced primitives.</summary>
		/// <param name="IndexCountPerInstance">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of indices read from the index buffer for each instance.</para>
		/// </param>
		/// <param name="InstanceCount">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of instances to draw.</para>
		/// </param>
		/// <param name="StartIndexLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The location of the first index read by the GPU from the index buffer.</para>
		/// </param>
		/// <param name="BaseVertexLocation">
		/// <para>Type: <b><c>INT</c></b></para>
		/// <para>A value added to each index before reading a vertex from the vertex buffer.</para>
		/// </param>
		/// <param name="StartInstanceLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>A value added to each index before reading per-instance data from a vertex buffer.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>A draw API submits work to the rendering pipeline.</para>
		/// <para>
		/// Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing
		/// could be to draw the same object with different positions and colors. Instancing requires multiple vertex buffers: at least one
		/// for per-vertex data and a second buffer for per-instance data. Examples The <c>D3D12Bundles</c> sample uses
		/// <b>ID3D12GraphicsCommandList::DrawIndexedInstanced</b> as follows:
		/// </para>
		/// <para>
		/// <c>void FrameResource::PopulateCommandList(ID3D12GraphicsCommandList* pCommandList, ID3D12PipelineState* pPso1,
		/// ID3D12PipelineState* pPso2, UINT frameResourceIndex, UINT numIndices, D3D12_INDEX_BUFFER_VIEW* pIndexBufferViewDesc,
		/// D3D12_VERTEX_BUFFER_VIEW* pVertexBufferViewDesc, ID3D12DescriptorHeap* pCbvSrvDescriptorHeap, UINT cbvSrvDescriptorSize,
		/// ID3D12DescriptorHeap* pSamplerDescriptorHeap, ID3D12RootSignature* pRootSignature) { // If the root signature matches the root
		/// signature of the caller, then // bindings are inherited, otherwise the bind space is reset.
		/// pCommandList-&gt;SetGraphicsRootSignature(pRootSignature); ID3D12DescriptorHeap* ppHeaps[] = { pCbvSrvDescriptorHeap,
		/// pSamplerDescriptorHeap }; pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// pCommandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		/// pCommandList-&gt;IASetIndexBuffer(pIndexBufferViewDesc); pCommandList-&gt;IASetVertexBuffers(0, 1, pVertexBufferViewDesc);
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(0, pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(1, pSamplerDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart()); //
		/// Calculate the descriptor offset due to multiple frame resources. // 1 SRV + how many CBVs we have currently. UINT
		/// frameResourceDescriptorOffset = 1 + (frameResourceIndex * m_cityRowCount * m_cityColumnCount); CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvSrvHandle(pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart(), frameResourceDescriptorOffset,
		/// cbvSrvDescriptorSize); BOOL usePso1 = TRUE; for (UINT i = 0; i &lt; m_cityRowCount; i++) { for (UINT j = 0; j &lt;
		/// m_cityColumnCount; j++) { // Alternate which PSO to use; the pixel shader is different on // each just as a PSO setting
		/// demonstration. pCommandList-&gt;SetPipelineState(usePso1 ? pPso1 : pPso2); usePso1 = !usePso1; // Set this city's CBV table and
		/// move to the next descriptor. pCommandList-&gt;SetGraphicsRootDescriptorTable(2, cbvSrvHandle);
		/// cbvSrvHandle.Offset(cbvSrvDescriptorSize); pCommandList-&gt;DrawIndexedInstanced(numIndices, 1, 0, 0, 0); } } }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-drawindexedinstanced void
		// DrawIndexedInstanced( [in] UINT IndexCountPerInstance, [in] UINT InstanceCount, [in] UINT StartIndexLocation, [in] INT
		// BaseVertexLocation, [in] UINT StartInstanceLocation );
		[PreserveSig]
		new void DrawIndexedInstanced(uint IndexCountPerInstance, uint InstanceCount, uint StartIndexLocation, int BaseVertexLocation, uint StartInstanceLocation);

		/// <summary>Executes a command list from a thread group.</summary>
		/// <param name="ThreadGroupCountX">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// The number of groups dispatched in the x direction. <i>ThreadGroupCountX</i> must be less than or equal to
		/// D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).
		/// </para>
		/// </param>
		/// <param name="ThreadGroupCountY">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// The number of groups dispatched in the y direction. <i>ThreadGroupCountY</i> must be less than or equal to
		/// D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).
		/// </para>
		/// </param>
		/// <param name="ThreadGroupCountZ">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// The number of groups dispatched in the z direction. <i>ThreadGroupCountZ</i> must be less than or equal to
		/// D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535). In feature level 10 the value for <i>ThreadGroupCountZ</i> must be 1.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// You call the <b>Dispatch</b> method to execute commands in a compute shader. A compute shader can be run on many threads in
		/// parallel, within a thread group. Index a particular thread, within a thread group using a 3D vector given by (x,y,z). Examples
		/// The <c>D3D12nBodyGravity</c> sample uses <b>ID3D12GraphicsCommandList::Dispatch</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Run the particle simulation using the compute shader. void D3D12nBodyGravity::Simulate(UINT threadIndex) {
		/// ID3D12GraphicsCommandList* pCommandList = m_computeCommandList[threadIndex].Get(); UINT srvIndex; UINT uavIndex; ID3D12Resource
		/// *pUavResource; if (m_srvIndex[threadIndex] == 0) { srvIndex = SrvParticlePosVelo0; uavIndex = UavParticlePosVelo1; pUavResource
		/// = m_particleBuffer1[threadIndex].Get(); } else { srvIndex = SrvParticlePosVelo1; uavIndex = UavParticlePosVelo0; pUavResource =
		/// m_particleBuffer0[threadIndex].Get(); } pCommandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(pUavResource, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE,
		/// D3D12_RESOURCE_STATE_UNORDERED_ACCESS)); pCommandList-&gt;SetPipelineState(m_computeState.Get());
		/// pCommandList-&gt;SetComputeRootSignature(m_computeRootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_srvUavHeap.Get()
		/// }; pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// srvHandle(m_srvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart(), srvIndex + threadIndex, m_srvUavDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE uavHandle(m_srvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart(), uavIndex + threadIndex,
		/// m_srvUavDescriptorSize); pCommandList-&gt;SetComputeRootConstantBufferView(RootParameterCB,
		/// m_constantBufferCS-&gt;GetGPUVirtualAddress()); pCommandList-&gt;SetComputeRootDescriptorTable(RootParameterSRV, srvHandle);
		/// pCommandList-&gt;SetComputeRootDescriptorTable(RootParameterUAV, uavHandle);
		/// pCommandList-&gt;Dispatch(static_cast&lt;int&gt;(ceil(ParticleCount / 128.0f)), 1, 1); pCommandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(pUavResource, D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
		/// D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch void Dispatch( [in] UINT
		// ThreadGroupCountX, [in] UINT ThreadGroupCountY, [in] UINT ThreadGroupCountZ );
		[PreserveSig]
		new void Dispatch(uint ThreadGroupCountX, uint ThreadGroupCountY, uint ThreadGroupCountZ);

		/// <summary>Copies a region of a buffer from one resource to another.</summary>
		/// <param name="pDstBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies the destination <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="DstOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies a UINT64 offset (in bytes) into the destination resource.</para>
		/// </param>
		/// <param name="pSrcBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies the source <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="SrcOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies a UINT64 offset (in bytes) into the source resource, to start the copy from.</para>
		/// </param>
		/// <param name="NumBytes">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies the number of bytes to copy.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Consider using the <c>CopyResource</c> method when copying an entire resource, and use this method for copying regions of a resource.
		/// </para>
		/// <para>
		/// <b>CopyBufferRegion</b> may be used to initialize resources which alias the same heap memory. See <c>CreatePlacedResource</c>
		/// for more details. Examples The <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::CopyBufferRegion</b> as follows:
		/// </para>
		/// <para>
		/// <c>inline UINT64 UpdateSubresources( _In_ ID3D12GraphicsCommandList* pCmdList, _In_ ID3D12Resource* pDestinationResource, _In_
		/// ID3D12Resource* pIntermediate, _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		/// _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources, UINT64 RequiredSize, _In_reads_(NumSubresources)
		/// const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts, _In_reads_(NumSubresources) const UINT* pNumRows,
		/// _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes, _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData)
		/// { // Minor validation D3D12_RESOURCE_DESC IntermediateDesc = pIntermediate-&gt;GetDesc(); D3D12_RESOURCE_DESC DestinationDesc =
		/// pDestinationResource-&gt;GetDesc(); if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER || IntermediateDesc.Width
		/// &lt; RequiredSize + pLayouts[0].Offset || RequiredSize &gt; (SIZE_T)-1 || (DestinationDesc.Dimension ==
		/// D3D12_RESOURCE_DIMENSION_BUFFER &amp;&amp; (FirstSubresource != 0 || NumSubresources != 1))) { return 0; } BYTE* pData; HRESULT
		/// hr = pIntermediate-&gt;Map(0, NULL, reinterpret_cast&lt;void**&gt;(&amp;pData)); if (FAILED(hr)) { return 0; } for (UINT i = 0;
		/// i &lt; NumSubresources; ++i) { if (pRowSizesInBytes[i] &gt; (SIZE_T)-1) return 0; D3D12_MEMCPY_DEST DestData = { pData +
		/// pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, pLayouts[i].Footprint.RowPitch * pNumRows[i] };
		/// MemcpySubresource(&amp;DestData, &amp;pSrcData[i], (SIZE_T)pRowSizesInBytes[i], pNumRows[i], pLayouts[i].Footprint.Depth); }
		/// pIntermediate-&gt;Unmap(0, NULL); if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER) { CD3DX12_BOX SrcBox( UINT(
		/// pLayouts[0].Offset ), UINT( pLayouts[0].Offset + pLayouts[0].Footprint.Width ) ); pCmdList-&gt;CopyBufferRegion(
		/// pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width); } else { for (UINT i = 0; i &lt;
		/// NumSubresources; ++i) { CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
		/// CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]); pCmdList-&gt;CopyTextureRegion(&amp;Dst, 0, 0, 0, &amp;Src,
		/// nullptr); } } return RequiredSize; }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copybufferregion void
		// CopyBufferRegion( [in] ID3D12Resource *pDstBuffer, UINT64 DstOffset, [in] ID3D12Resource *pSrcBuffer, UINT64 SrcOffset, UINT64
		// NumBytes );
		[PreserveSig]
		new void CopyBufferRegion([In] ID3D12Resource pDstBuffer, ulong DstOffset, [In] ID3D12Resource pSrcBuffer, ulong SrcOffset, ulong NumBytes);

		/// <summary>
		/// This method uses the GPU to copy texture data between two locations. Both the source and the destination may reference texture
		/// data located within either a buffer resource or a texture resource.
		/// </summary>
		/// <param name="pDst">
		/// <para>Type: <b>const <c>D3D12_TEXTURE_COPY_LOCATION</c>*</b></para>
		/// <para>
		/// Specifies the destination <c>D3D12_TEXTURE_COPY_LOCATION</c>. The subresource referred to must be in the
		/// D3D12_RESOURCE_STATE_COPY_DEST state.
		/// </para>
		/// </param>
		/// <param name="DstX">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The x-coordinate of the upper left corner of the destination region.</para>
		/// </param>
		/// <param name="DstY">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The y-coordinate of the upper left corner of the destination region. For a 1D subresource, this must be zero.</para>
		/// </param>
		/// <param name="DstZ">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The z-coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero.</para>
		/// </param>
		/// <param name="pSrc">
		/// <para>Type: <b>const <c>D3D12_TEXTURE_COPY_LOCATION</c>*</b></para>
		/// <para>
		/// Specifies the source <c>D3D12_TEXTURE_COPY_LOCATION</c>. The subresource referred to must be in the
		/// D3D12_RESOURCE_STATE_COPY_SOURCE state.
		/// </para>
		/// </param>
		/// <param name="pSrcBox">
		/// <para>Type: <b>const <c>D3D12_BOX</c>*</b></para>
		/// <para>Specifies an optional D3D12_BOX that sets the size of the source texture to copy.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The source box must be within the size of the source resource. The destination offsets, (x, y, and z), allow the source box to
		/// be offset when writing into the destination resource; however, the dimensions of the source box and the offsets must be within
		/// the size of the resource. If you try and copy outside the destination resource or specify a source box that is larger than the
		/// source resource, the behavior of <b>CopyTextureRegion</b> is undefined. If you created a device that supports the <c>debug
		/// layer</c>, the debug output reports an error on this invalid <b>CopyTextureRegion</b> call. Invalid parameters to
		/// <b>CopyTextureRegion</b> cause undefined behavior and might result in incorrect rendering, clipping, no copy, or even the
		/// removal of the rendering device.
		/// </para>
		/// <para>If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels.</para>
		/// <para>
		/// <b>CopyTextureRegion</b> performs the copy on the GPU (similar to a <c>memcpy</c> by the CPU). As a consequence, the source and
		/// destination resources:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>Must be different subresources (although they can be from the same resource).</description>
		/// </item>
		/// <item>
		/// <description>
		/// Must have compatible <c>DXGI_FORMAT</c> s (identical or from the same type group). For example, a DXGI_FORMAT_R32G32B32_FLOAT
		/// texture can be copied to a DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the
		/// DXGI_FORMAT_R32G32B32_TYPELESS group. <b>CopyTextureRegion</b> can copy between a few format types. For more info, see <c>Format
		/// Conversion using Direct3D 10.1</c>.
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// <b>CopyTextureRegion</b> only supports copy; it does not support any stretch, color key, or blend. <b>CopyTextureRegion</b> can
		/// reinterpret the resource data between a few format types.
		/// </para>
		/// <para>Note that for a depth-stencil buffer, the depth and stencil planes are <c>separate subresources</c> within the buffer.</para>
		/// <para>To copy an entire resource, rather than just a region of a subresource, we recommend to use <c>CopyResource</c> instead.</para>
		/// <para>
		/// <b>Note</b>If you use <b>CopyTextureRegion</b> with a depth-stencil buffer or a multisampled resource, you must copy the
		/// entire subresource rectangle. In this situation, you must pass 0 to the <i>DstX</i>, <i>DstY</i>, and <i>DstZ</i> parameters and
		/// <b>NULL</b> to the <i>pSrcBox</i> parameter. In addition, source and destination resources, which are represented by the
		/// <i>pSrcResource</i> and <i>pDstResource</i> parameters, should have identical sample count values.
		/// </para>
		/// <para></para>
		/// <para>
		/// <b>CopyTextureRegion</b> may be used to initialize resources which alias the same heap memory. See <c>CreatePlacedResource</c>
		/// for more details.
		/// </para>
		/// <para><c></c><c></c><c></c> Example</para>
		/// <para>
		/// The following code snippet copies the box (located at (120,100),(200,220)) from a source texture into the region
		/// (10,20),(90,140) in a destination texture.
		/// </para>
		/// <para>
		/// <c>D3D12_BOX sourceRegion; sourceRegion.left = 120; sourceRegion.top = 100; sourceRegion.right = 200; sourceRegion.bottom = 220;
		/// sourceRegion.front = 0; sourceRegion.back = 1; pCmdList -&gt; CopyTextureRegion(pDestTexture, 10, 20, 0, pSourceTexture, &amp;sourceRegion);</c>
		/// </para>
		/// <para>
		/// Notice, that for a 2D texture, front and back are set to 0 and 1 respectively. Examples The <b>HelloTriangle</b> sample uses
		/// <b>ID3D12GraphicsCommandList::CopyTextureRegion</b> as follows:
		/// </para>
		/// <para>
		/// <c>inline UINT64 UpdateSubresources( _In_ ID3D12GraphicsCommandList* pCmdList, _In_ ID3D12Resource* pDestinationResource, _In_
		/// ID3D12Resource* pIntermediate, _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		/// _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources, UINT64 RequiredSize, _In_reads_(NumSubresources)
		/// const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts, _In_reads_(NumSubresources) const UINT* pNumRows,
		/// _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes, _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData)
		/// { // Minor validation D3D12_RESOURCE_DESC IntermediateDesc = pIntermediate-&gt;GetDesc(); D3D12_RESOURCE_DESC DestinationDesc =
		/// pDestinationResource-&gt;GetDesc(); if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER || IntermediateDesc.Width
		/// &lt; RequiredSize + pLayouts[0].Offset || RequiredSize &gt; (SIZE_T)-1 || (DestinationDesc.Dimension ==
		/// D3D12_RESOURCE_DIMENSION_BUFFER &amp;&amp; (FirstSubresource != 0 || NumSubresources != 1))) { return 0; } BYTE* pData; HRESULT
		/// hr = pIntermediate-&gt;Map(0, NULL, reinterpret_cast&lt;void**&gt;(&amp;pData)); if (FAILED(hr)) { return 0; } for (UINT i = 0;
		/// i &lt; NumSubresources; ++i) { if (pRowSizesInBytes[i] &gt; (SIZE_T)-1) return 0; D3D12_MEMCPY_DEST DestData = { pData +
		/// pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, pLayouts[i].Footprint.RowPitch * pNumRows[i] };
		/// MemcpySubresource(&amp;DestData, &amp;pSrcData[i], (SIZE_T)pRowSizesInBytes[i], pNumRows[i], pLayouts[i].Footprint.Depth); }
		/// pIntermediate-&gt;Unmap(0, NULL); if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER) { CD3DX12_BOX SrcBox( UINT(
		/// pLayouts[0].Offset ), UINT( pLayouts[0].Offset + pLayouts[0].Footprint.Width ) ); pCmdList-&gt;CopyBufferRegion(
		/// pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width); } else { for (UINT i = 0; i &lt;
		/// NumSubresources; ++i) { CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
		/// CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]); pCmdList-&gt;CopyTextureRegion(&amp;Dst, 0, 0, 0, &amp;Src,
		/// nullptr); } } return RequiredSize; }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion void
		// CopyTextureRegion( [in] const D3D12_TEXTURE_COPY_LOCATION *pDst, UINT DstX, UINT DstY, UINT DstZ, [in] const
		// D3D12_TEXTURE_COPY_LOCATION *pSrc, [in, optional] const D3D12_BOX *pSrcBox );
		[PreserveSig]
		new void CopyTextureRegion(in D3D12_TEXTURE_COPY_LOCATION pDst, uint DstX, uint DstY, uint DstZ, in D3D12_TEXTURE_COPY_LOCATION pSrc,
			[In, Optional] StructPointer<D3D12_BOX> pSrcBox);

		/// <summary>Copies the entire contents of the source resource to the destination resource.</summary>
		/// <param name="pDstResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the destination resource.</para>
		/// </param>
		/// <param name="pSrcResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the source resource.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>CopyResource</b> operations are performed on the GPU, and do not incur a significant CPU workload linearly dependent on the
		/// size of the data to copy.
		/// </para>
		/// <para>
		/// <b>CopyResource</b> can be used to initialize resources that alias the same heap memory. See <c>CreatePlacedResource</c> for
		/// more details.
		/// </para>
		/// <para>Debug layer</para>
		/// <para>The debug layer issues an error if the source subresource is not in the <c>D3D12_RESOURCE_STATE_COPY_SOURCE</c> state.</para>
		/// <para>
		/// The debug layer issues an error if the destination subresource is not in the <c>D3D12_RESOURCE_STATE_COPY_DEST</c> state.
		/// Restrictions This method has a few restrictions designed for improving performance. For instance, the source and destination resources:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>Must be different resources.</description>
		/// </item>
		/// <item>
		/// <description>Must be the same type.</description>
		/// </item>
		/// <item>
		/// <description>Must be the same total size (bytes).</description>
		/// </item>
		/// <item>
		/// <description>Must have identical dimensions (width, height, depth) or be a compatible <c>Reinterpret Copy</c>.</description>
		/// </item>
		/// <item>
		/// <description>
		/// Must have compatible <c>DXGI formats</c>, which means the formats must be identical or at least from the same type group. For
		/// example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to a DXGI_FORMAT_R32G32B32_UINT texture since both of these formats
		/// are in the DXGI_FORMAT_R32G32B32_TYPELESS group. <b>CopyResource</b> can copy between a few format types (see <c>Reinterpret copy</c>).
		/// </description>
		/// </item>
		/// <item>
		/// <description>Can't be currently mapped.</description>
		/// </item>
		/// </list>
		/// <para><b>CopyResource</b> only supports copy; it doesn't support any stretch, color key, or blend.</para>
		/// <para>
		/// <b>CopyResource</b> can reinterpret the resource data between a few format types, see <c>Reinterpret Copy</c> below for details.
		/// </para>
		/// <para>
		/// You can use a <c>depth-stencil</c> resource as either a source or a destination. Resources created with multi-sampling
		/// capability (see <c>DXGI_SAMPLE_DESC</c>) can be used as source and destination only if both source and destination have
		/// identical multi-sampled count and quality. If source and destination differ in multi-sampled count and quality or if one is
		/// multi-sampled and the other is not multi-sampled, the call to <b>CopyResource</b> fails. Use <c>ResolveSubresource</c> to
		/// resolve a multi-sampled resource to a resource that is not multi-sampled.
		/// </para>
		/// <para>
		/// The method is an asynchronous call, which may be added to the command-buffer queue. This attempts to remove pipeline stalls that
		/// may occur when copying data. For more info, see <c>performance considerations</c>.
		/// </para>
		/// <para>
		/// Consider using <c>CopyTextureRegion</c> or <c>CopyBufferRegion</c> if you only need to copy a portion of the data in a resource.
		/// </para>
		/// <para>Reinterpret copy</para>
		/// <para>
		/// The following table lists the allowable source and destination formats that you can use in the reinterpretation type of format
		/// conversion. The underlying data values are not converted or compressed/decompressed and must be encoded properly for the
		/// reinterpretation to work as expected. For more info, see <c>Format Conversion using Direct3D 10.1</c>.
		/// </para>
		/// <para>For DXGI_FORMAT_R9G9B9E5_SHAREDEXP the width and height must be equal (1 texel per block).</para>
		/// <para>
		/// Block-compressed resource width and height must be 4 times the uncompressed resource width and height (16 texels per block). For
		/// example, a uncompressed 256x256 DXGI_FORMAT_R32G32B32A32_UINT texture will map to a 1024x1024 DXGI_FORMAT_BC5_UNORM compressed texture.
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Bit width</description>
		/// <description>Uncompressed resource</description>
		/// <description>Block-compressed resource</description>
		/// <description>Width / height difference</description>
		/// </listheader>
		/// <item>
		/// <description>32</description>
		/// <description>DXGI_FORMAT_R32_UINT DXGI_FORMAT_R32_SINT</description>
		/// <description>DXGI_FORMAT_R9G9B9E5_SHAREDEXP</description>
		/// <description>1:1</description>
		/// </item>
		/// <item>
		/// <description>64</description>
		/// <description>DXGI_FORMAT_R16G16B16A16_UINT DXGI_FORMAT_R16G16B16A16_SINT DXGI_FORMAT_R32G32_UINT DXGI_FORMAT_R32G32_SINT</description>
		/// <description>DXGI_FORMAT_BC1_UNORM[_SRGB] DXGI_FORMAT_BC4_UNORM DXGI_FORMAT_BC4_SNORM</description>
		/// <description>1:4</description>
		/// </item>
		/// <item>
		/// <description>128</description>
		/// <description>DXGI_FORMAT_R32G32B32A32_UINT DXGI_FORMAT_R32G32B32A32_SINT</description>
		/// <description>DXGI_FORMAT_BC2_UNORM[_SRGB] DXGI_FORMAT_BC3_UNORM[_SRGB] DXGI_FORMAT_BC5_UNORM DXGI_FORMAT_BC5_SNORM</description>
		/// <description>1:4</description>
		/// </item>
		/// </list>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copyresource void CopyResource( [in]
		// ID3D12Resource *pDstResource, [in] ID3D12Resource *pSrcResource );
		[PreserveSig]
		new void CopyResource([In] ID3D12Resource pDstResource, [In] ID3D12Resource pSrcResource);

		/// <summary>Copies tiles from buffer to tiled resource or vice versa.</summary>
		/// <param name="pTiledResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to a tiled resource.</para>
		/// </param>
		/// <param name="pTileRegionStartCoordinate">
		/// <para>Type: <b>const <c>D3D12_TILED_RESOURCE_COORDINATE</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_TILED_RESOURCE_COORDINATE</c> structure that describes the starting coordinates of the tiled resource.</para>
		/// </param>
		/// <param name="pTileRegionSize">
		/// <para>Type: <b>const <c>D3D12_TILE_REGION_SIZE</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_TILE_REGION_SIZE</c> structure that describes the size of the tiled region.</para>
		/// </param>
		/// <param name="pBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to an <c>ID3D12Resource</c> that represents a default, dynamic, or staging buffer.</para>
		/// </param>
		/// <param name="BufferStartOffsetInBytes">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset in bytes into the buffer at <i>pBuffer</i> to start the operation.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_TILE_COPY_FLAGS</c></b></para>
		/// <para>
		/// A combination of <c>D3D12_TILE_COPY_FLAGS</c>-typed values that are combined by using a bitwise OR operation and that identifies
		/// how to copy tiles.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>CopyTiles</b> drops write operations to unmapped areas and handles read operations from unmapped areas (except on Tier_1
		/// tiled resources, where reading and writing unmapped areas is invalid - refer to <c>D3D12_TILED_RESOURCES_TIER</c>).
		/// </para>
		/// <para>
		/// If a copy operation involves writing to the same memory location multiple times because multiple locations in the destination
		/// resource are mapped to the same tile memory, the resulting write operations to multi-mapped tiles are non-deterministic and
		/// non-repeatable; that is, accesses to the tile memory happen in whatever order the hardware happens to execute the copy operation.
		/// </para>
		/// <para>
		/// The tiles involved in the copy operation can't include tiles that contain packed mipmaps or results of the copy operation are
		/// undefined. To transfer data to and from mipmaps that the hardware packs into the one-or-more tiles that constitute the packed
		/// mips, you must use the standard (that is, non-tile specific) copy APIs like <c>CopyTextureRegion</c>.
		/// </para>
		/// <para><b>CopyTiles</b> does copy data in a slightly different pattern than the standard copy methods.</para>
		/// <para>
		/// The memory layout of the tiles in the non-tiled buffer resource side of the copy operation is linear in memory within 64 KB
		/// tiles, which the hardware and driver swizzle and de-swizzle per tile as appropriate when they transfer to and from a tiled
		/// resource. For multisample antialiasing (MSAA) surfaces, the hardware and driver traverse each pixel's samples in sample-index
		/// order before they move to the next pixel. For tiles that are partially filled on the right side (for a surface that has a width
		/// not a multiple of tile width in pixels), the pitch and stride to move down a row is the full size in bytes of the number pixels
		/// that would fit across the tile if the tile was full. So, there can be a gap between each row of pixels in memory. Mipmaps that
		/// are smaller than a tile are not packed together in the linear layout, which might seem to be a waste of memory space, but as
		/// mentioned you can't use <b>CopyTiles</b> to copy to mipmaps that the hardware packs together. You can just use generic copy
		/// APIs, like <c>CopyTextureRegion</c>, to copy small mipmaps individually.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytiles void CopyTiles( [in]
		// ID3D12Resource *pTiledResource, [in] const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate, [in] const
		// D3D12_TILE_REGION_SIZE *pTileRegionSize, [in] ID3D12Resource *pBuffer, UINT64 BufferStartOffsetInBytes, D3D12_TILE_COPY_FLAGS
		// Flags );
		[PreserveSig]
		new void CopyTiles([In] ID3D12Resource pTiledResource, in D3D12_TILED_RESOURCE_COORDINATE pTileRegionStartCoordinate,
			in D3D12_TILE_REGION_SIZE pTileRegionSize, [In] ID3D12Resource pBuffer, ulong BufferStartOffsetInBytes, D3D12_TILE_COPY_FLAGS Flags);

		/// <summary>Copy a multi-sampled resource into a non-multi-sampled resource.</summary>
		/// <param name="pDstResource">
		/// <para>Type: [in] <b>ID3D12Resource*</b></para>
		/// <para>Destination resource. Must be a created on a <c>D3D12_HEAP_TYPE_DEFAULT</c> heap and be single-sampled. See <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="DstSubresource">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>
		/// A zero-based index, that identifies the destination subresource. Use <c>D3D12CalcSubresource</c> to calculate the subresource
		/// index if the parent resource is complex.
		/// </para>
		/// </param>
		/// <param name="pSrcResource">
		/// <para>Type: [in] <b>ID3D12Resource*</b></para>
		/// <para>Source resource. Must be multisampled.</para>
		/// </param>
		/// <param name="SrcSubresource">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The source subresource of the source resource.</para>
		/// </param>
		/// <param name="Format">
		/// <para>Type: [in] <b>DXGI_FORMAT</b></para>
		/// <para>A <c>DXGI_FORMAT</c> that indicates how the multisampled resource will be resolved to a single-sampled resource. See remarks.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>
		/// The debug layer will issue an error if the subresources referenced by the source view is not in the
		/// <c>D3D12_RESOURCE_STATE_RESOLVE_SOURCE</c> state.
		/// </para>
		/// <para>The debug layer will issue an error if the destination buffer is not in the <c>D3D12_RESOURCE_STATE_RESOLVE_DEST</c> state.</para>
		/// <para>
		/// The source and destination resources must be the same resource type and have the same dimensions. In addition, they must have
		/// compatible formats. There are three scenarios for this:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Scenario</description>
		/// <description>Requirements</description>
		/// </listheader>
		/// <item>
		/// <description>Source and destination are prestructured and typed</description>
		/// <description>
		/// Both the source and destination must have identical formats and that format must be specified in the Format parameter.
		/// </description>
		/// </item>
		/// <item>
		/// <description>One resource is prestructured and typed and the other is prestructured and typeless</description>
		/// <description>
		/// The typed resource must have a format that is compatible with the typeless resource (i.e. the typed resource is
		/// DXGI_FORMAT_R32_FLOAT and the typeless resource is DXGI_FORMAT_R32_TYPELESS). The format of the typed resource must be specified
		/// in the Format parameter.
		/// </description>
		/// </item>
		/// <item>
		/// <description>Source and destination are prestructured and typeless</description>
		/// <description>
		/// Both the source and destination must have the same typeless format (i.e. both must have DXGI_FORMAT_R32_TYPELESS), and the
		/// Format parameter must specify a format that is compatible with the source and destination (i.e. if both are
		/// DXGI_FORMAT_R32_TYPELESS then DXGI_FORMAT_R32_FLOAT could be specified in the Format parameter). For example, given the
		/// DXGI_FORMAT_R16G16B16A16_TYPELESS format:
		/// </description>
		/// </item>
		/// </list>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvesubresource void
		// ResolveSubresource( ID3D12Resource *pDstResource, UINT DstSubresource, ID3D12Resource *pSrcResource, UINT SrcSubresource,
		// DXGI_FORMAT Format );
		[PreserveSig]
		new void ResolveSubresource([In] ID3D12Resource pDstResource, uint DstSubresource, [In] ID3D12Resource pSrcResource, uint SrcSubresource,
			DXGI_FORMAT Format);

		/// <summary>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</summary>
		/// <param name="PrimitiveTopology">
		/// <para>Type: <b>D3D12_PRIMITIVE_TOPOLOGY</b></para>
		/// <para>The type of primitive and ordering of the primitive data (see <c>D3D_PRIMITIVE_TOPOLOGY</c>).</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-iasetprimitivetopology void
		// IASetPrimitiveTopology( [in] D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology );
		[PreserveSig]
		new void IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY PrimitiveTopology);

		/// <summary>Bind an array of viewports to the rasterizer stage of the pipeline.</summary>
		/// <param name="NumViewports">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Number of viewports to bind. The range of valid values is (0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE).</para>
		/// </param>
		/// <param name="pViewports">
		/// <para>Type: <b>const <c>D3D12_VIEWPORT</c>*</b></para>
		/// <para>An array of <c>D3D12_VIEWPORT</c> structures to bind to the device.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled.</para>
		/// <para>
		/// Which viewport to use is determined by the <c>SV_ViewportArrayIndex</c> semantic output by a geometry shader; if a geometry
		/// shader does not specify the semantic, Direct3D will use the first viewport in the array. Examples The <c>D3D12HelloTriangle</c>
		/// sample uses <b>ID3D12GraphicsCommandList::RSSetViewports</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-rssetviewports void RSSetViewports(
		// [in] UINT NumViewports, [in] const D3D12_VIEWPORT *pViewports );
		[PreserveSig]
		new void RSSetViewports(int NumViewports, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_VIEWPORT[] pViewports);

		/// <summary>Binds an array of scissor rectangles to the rasterizer stage.</summary>
		/// <param name="NumRects">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of scissor rectangles to bind.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: <b>const D3D12_RECT*</b></para>
		/// <para>An array of scissor rectangles.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>All scissor rectangles must be set atomically as one operation. Any scissor rectangles not defined by the call are disabled.</para>
		/// <para>
		/// Which scissor rectangle to use is determined by the <c>SV_ViewportArrayIndex</c> semantic output by a geometry shader (see
		/// shader semantic syntax). If a geometry shader does not make use of the <c>SV_ViewportArrayIndex</c> semantic then Direct3D will
		/// use the first scissor rectangle in the array.
		/// </para>
		/// <para>
		/// Each scissor rectangle in the array corresponds to a viewport in an array of viewports (see <c>RSSetViewports</c>). Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::RSSetScissorRects</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>// Command list allocators can only be reset when the associated // command lists have finished execution on the GPU; apps
		/// should use // fences to determine GPU execution progress. ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when
		/// ExecuteCommandList() is called on a particular command // list, that command list can then be reset at any time and must be
		/// before // re-recording. ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set
		/// necessary state. m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1,
		/// &amp;m_viewport); m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a
		/// render target. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT,
		/// D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close());</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-rssetscissorrects void
		// RSSetScissorRects( [in] UINT NumRects, [in] const D3D12_RECT *pRects );
		[PreserveSig]
		new void RSSetScissorRects(int NumRects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] RECT[] pRects);

		/// <summary>Sets the blend factor that modulate values for a pixel shader, render target, or both.</summary>
		/// <param name="BlendFactor">
		/// <para>Type: <b>const FLOAT[4]</b></para>
		/// <para>Array of blend factors, one for each RGBA component.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// If you created the blend-state object with <c>D3D12_BLEND_BLEND_FACTOR</c> or <b>D3D12_BLEND_INV_BLEND_FACTOR</b>, then the
		/// blending stage uses the non-NULL array of blend factors. Otherwise,the blending stage doesn't use the non-NULL array of blend
		/// factors; the runtime stores the blend factors.
		/// </para>
		/// <para>If you pass NULL, then the runtime uses or stores a blend factor equal to <c>{ 1, 1, 1, 1 }</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetblendfactor void
		// OMSetBlendFactor( [in, optional] const FLOAT [4] BlendFactor );
		[PreserveSig]
		new void OMSetBlendFactor([In, Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] float[]? BlendFactor);

		/// <summary>Sets the reference value for depth stencil tests.</summary>
		/// <param name="StencilRef">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Reference value to perform against when doing a depth-stencil test.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetstencilref void
		// OMSetStencilRef( [in] UINT StencilRef );
		[PreserveSig]
		new void OMSetStencilRef(uint StencilRef);

		/// <summary>Sets all shaders and programs most of the fixed-function state of the graphics processing unit (GPU) pipeline.</summary>
		/// <param name="pPipelineState">
		/// <para>Type: <b><c>ID3D12PipelineState</c>*</b></para>
		/// <para>Pointer to the <c>ID3D12PipelineState</c> containing the pipeline state data.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setpipelinestate void
		// SetPipelineState( [in] ID3D12PipelineState *pPipelineState );
		[PreserveSig]
		new void SetPipelineState([In] ID3D12PipelineState pPipelineState);

		/// <summary>Notifies the driver that it needs to synchronize multiple accesses to resources.</summary>
		/// <param name="NumBarriers">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of submitted barrier descriptions.</para>
		/// </param>
		/// <param name="pBarriers">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_BARRIER</c>*</b></para>
		/// <para>Pointer to an array of barrier descriptions.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <para>Note</para>
		/// <para>
		/// A resource to be used for the <c>D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE</c> state must be created in that state,
		/// and then never transitioned out of it. Nor may a resource that was created not in that state be transitioned into it. For more
		/// info, see <c>Acceleration structure memory restrictions</c> in the DirectX raytracing (DXR) functional specification on GitHub.
		/// </para>
		/// </para>
		/// <para>There are three types of barrier descriptions:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// <c>D3D12_RESOURCE_TRANSITION_BARRIER</c> - Transition barriers indicate that a set of subresources transition between different
		/// usages. The caller must specify the <i>before</i> and <i>after</i> usages of the subresources. The
		/// D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES flag is used to transition all subresources in a resource at the same time.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// <c>D3D12_RESOURCE_ALIASING_BARRIER</c> - Aliasing barriers indicate a transition between usages of two different resources which
		/// have mappings into the same heap. The application can specify both the before and the after resource. Note that one or both
		/// resources can be NULL (indicating that any tiled resource could cause aliasing).
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// <c>D3D12_RESOURCE_UAV_BARRIER</c> - Unordered access view barriers indicate all UAV accesses (read or writes) to a particular
		/// resource must complete before any future UAV accesses (read or write) can begin. The specified resource may be NULL. It is not
		/// necessary to insert a UAV barrier between two draw or dispatch calls which only read a UAV. Additionally, it is not necessary to
		/// insert a UAV barrier between two draw or dispatch calls which write to the same UAV if the application knows that it is safe to
		/// execute the UAV accesses in any order. The resource can be NULL (indicating that any UAV access could require the barrier).
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// When <b>ID3D12GraphicsCommandList::ResourceBarrier</b> is passed an array of resource barrier descriptions, the API behaves as
		/// if it was called N times (1 for each array element), in the specified order. Transitions should be batched together into a
		/// single API call when possible, as a performance optimization.
		/// </para>
		/// <para>
		/// For descriptions of the usage states a subresource can be in, see the <c>D3D12_RESOURCE_STATES</c> enumeration and the <c>Using
		/// Resource Barriers to Synchronize Resource States in Direct3D 12</c> section.
		/// </para>
		/// <para>
		/// All subresources in a resource must be in the RENDER_TARGET state, or DEPTH_WRITE state, for render targets/depth-stencil
		/// resources respectively, when <c>ID3D12GraphicsCommandList::DiscardResource</c> is called.
		/// </para>
		/// <para>
		/// When a back buffer is presented, it must be in the D3D12_RESOURCE_STATE_PRESENT state. If <c>IDXGISwapChain1::Present1</c> is
		/// called on a resource which is not in the PRESENT state, a debug layer warning will be emitted.
		/// </para>
		/// <para>The resource usage bits are group into two categories, read-only and read/write.</para>
		/// <para>The following usage bits are read-only:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_INDEX_BUFFER</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_COPY_SOURCE</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_DEPTH_READ</description>
		/// </item>
		/// </list>
		/// <para>The following usage bits are read/write:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_DEPTH_WRITE</description>
		/// </item>
		/// </list>
		/// <para>The following usage bits are write-only:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_COPY_DEST</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_RENDER_TARGET</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_STREAM_OUT</description>
		/// </item>
		/// </list>
		/// <para>
		/// At most one write bit can be set. If any write bit is set, then no read bit may be set. If no write bit is set, then any number
		/// of read bits may be set.
		/// </para>
		/// <para>
		/// At any given time, a subresource is in exactly one state (determined by a set of flags). The application must ensure that the
		/// states are matched when making a sequence of <b>ResourceBarrier</b> calls. In other words, the before and after states in
		/// consecutive calls to <b>ResourceBarrier</b> must agree.
		/// </para>
		/// <para>
		/// To transition all subresources within a resource, the application can set the subresource index to
		/// D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES, which implies that all subresources are changed.
		/// </para>
		/// <para>
		/// For improved performance, applications should use split barriers (refer to <c>Multi-engine synchronization</c>). Your
		/// application should also batch multiple transitions into a single call whenever possible.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>The runtime will validate that the barrier type values are valid members of the <c>D3D12_RESOURCE_BARRIER_TYPE</c> enumeration.</para>
		/// <para>In addition, the runtime checks the following:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>The resource pointer is non-NULL.</description>
		/// </item>
		/// <item>
		/// <description>The subresource index is valid</description>
		/// </item>
		/// <item>
		/// <description>
		/// The before and after states are supported by the <c>D3D12_RESOURCE_BINDING_TIER</c> and <c>D3D12_RESOURCE_FLAGS</c> flags of the resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description>Reserved bits in the state masks are not set.</description>
		/// </item>
		/// <item>
		/// <description>The before and after states are different.</description>
		/// </item>
		/// <item>
		/// <description>The set of bits in the before and after states are valid.</description>
		/// </item>
		/// <item>
		/// <description>
		/// If the D3D12_RESOURCE_STATE_RESOLVE_SOURCE bit is set, then the resource sample count must be greater than 1.
		/// </description>
		/// </item>
		/// <item>
		/// <description>If the D3D12_RESOURCE_STATE_RESOLVE_DEST bit is set, then the resource sample count must be equal to 1.</description>
		/// </item>
		/// </list>
		/// <para>For aliasing barriers the runtime will validate that, if either resource pointer is non-NULL, it refers to a tiled resource.</para>
		/// <para>
		/// For UAV barriers the runtime will validate that, if the resource is non-NULL, the resource has the
		/// D3D12_RESOURCE_STATE_UNORDERED_ACCESS bind flag set.
		/// </para>
		/// <para>Validation failure causes <c>ID3D12GraphicsCommandList::Close</c> to return E_INVALIDARG.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>The debug layer normally issues errors where runtime validation fails:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// If a subresource transition in a command list is inconsistent with previous transitions in the same command list.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// If a resource is used without first calling <b>ResourceBarrier</b> to put the resource into the correct state.
		/// </description>
		/// </item>
		/// <item>
		/// <description>If a resource is illegally bound for read and write at the same time.</description>
		/// </item>
		/// <item>
		/// <description>
		/// If the <i>before</i> states passed to the <b>ResourceBarrier</b> do not match the <i>after</i> states of previous calls to
		/// <b>ResourceBarrier</b>, including the aliasing case.
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// Whereas the debug layer attempts to validate the runtime rules, it operates conservatively so that debug layer errors are real
		/// errors, and in some cases real errors may not produce debug layer errors.
		/// </para>
		/// <para>The debug layer will issue warnings in the following cases:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>All of the cases where the D3D12 debug layer would issues warnings for <c>ID3D12GraphicsCommandList::ResourceBarrier</c>.</description>
		/// </item>
		/// <item>
		/// <description>
		/// If a depth buffer is used in a non-read-only mode while the resource has the D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE usage
		/// bit set.
		/// </description>
		/// </item>
		/// </list>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier void
		// ResourceBarrier( [in] UINT NumBarriers, [in] const D3D12_RESOURCE_BARRIER *pBarriers );
		[PreserveSig]
		new void ResourceBarrier(int NumBarriers, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_RESOURCE_BARRIER[] pBarriers);

		/// <summary>Executes a bundle.</summary>
		/// <param name="pCommandList">
		/// <para>Type: <b><c>ID3D12GraphicsCommandList</c>*</b></para>
		/// <para>Specifies the <c>ID3D12GraphicsCommandList</c> that determines the bundle to be executed.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Bundles inherit all state from the parent command list on which <b>ExecuteBundle</b> is called, except the pipeline state object
		/// and primitive topology. All of the state that is set in a bundle will affect the state of the parent command list. Note that
		/// <b>ExecuteBundle</b> is not a predicated operation.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>
		/// The runtime will validate that the "callee" is a bundle and that the "caller" is a direct command list. The runtime will also
		/// validate that the bundle has been closed. If the contract is violated, the runtime will silently drop the call. Validation
		/// failure will result in <c>Close</c> returning E_INVALIDARG.
		/// </para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>
		/// The debug layer will issue a warning in the same cases where the runtime will fail. The debug layer will issue a warning if a
		/// predicate is set when <c>ExecuteCommandList</c> is called. Also, the debug layer will issue an error if it detects that any
		/// resource reference by the command list has been destroyed.
		/// </para>
		/// <para>
		/// The debug layer will also validate that the command allocator associated with the bundle has not been reset since <c>Close</c>
		/// was called on the command list. This validation occurs at <b>ExecuteBundle</b> time, and when the parent command list is
		/// executed on a command queue. Examples The <c>D3D12Bundles</c> sample uses <b>ID3D12GraphicsCommandList::ExecuteBundle</b> as follows:
		/// </para>
		/// <para>
		/// <c>void D3D12Bundles::PopulateCommandList(FrameResource* pFrameResource) { // Command list allocators can only be reset when the
		/// associated // command lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a
		/// particular command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_pCurrentFrameResource-&gt;m_commandAllocator.Get(), m_pipelineState1.Get())); // Set
		/// necessary state. m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = {
		/// m_cbvSrvHeap.Get(), m_samplerHeap.Get() }; m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// m_commandList-&gt;RSSetViewports(1, &amp;m_viewport); m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate
		/// that the back buffer will be used as a render target. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT,
		/// D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;ClearDepthStencilView(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0,
		/// nullptr); if (UseBundles) { // Execute the prebuilt bundle. m_commandList-&gt;ExecuteBundle(pFrameResource-&gt;m_bundle.Get());
		/// } else { // Populate a new command list. pFrameResource-&gt;PopulateCommandList(m_commandList.Get(), m_pipelineState1.Get(),
		/// m_pipelineState2.Get(), m_currentFrameResourceIndex, m_numIndices, &amp;m_indexBufferView, &amp;m_vertexBufferView,
		/// m_cbvSrvHeap.Get(), m_cbvSrvDescriptorSize, m_samplerHeap.Get(), m_rootSignature.Get()); } // Indicate that the back buffer will
		/// now be used to present. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET,
		/// D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-executebundle void ExecuteBundle(
		// [in] ID3D12GraphicsCommandList *pCommandList );
		[PreserveSig]
		new void ExecuteBundle([In] ID3D12GraphicsCommandList pCommandList);

		/// <summary>Changes the currently bound descriptor heaps that are associated with a command list.</summary>
		/// <param name="NumDescriptorHeaps">
		/// <para>Type: [in] <b><c>UINT</c></b></para>
		/// <para>Number of descriptor heaps to bind.</para>
		/// </param>
		/// <param name="ppDescriptorHeaps">
		/// <para>Type: [in] <b><c>ID3D12DescriptorHeap</c>*</b></para>
		/// <para>A pointer to an array of <c>ID3D12DescriptorHeap</c> objects for the heaps to set on the command list.</para>
		/// <para>You can only bind descriptor heaps of type <c><b>D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV</b></c> and <c><b>D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER</b></c>.</para>
		/// <para>
		/// Only one descriptor heap of each type can be set at one time, which means a maximum of 2 heaps (one sampler, one CBV/SRV/UAV)
		/// can be set at one time.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>SetDescriptorHeaps</b> can be called on a bundle, but the bundle descriptor heaps must match the calling command list
		/// descriptor heap. For more information on bundle restrictions, refer to <c>Creating and Recording Command Lists and Bundles</c>.
		/// </para>
		/// <para>All previously set heaps are unset by the call. At most one heap of each shader-visible type can be set in the call.</para>
		/// <para>
		/// Changing descriptor heaps can incur a pipeline flush on some hardware. Because of this, it is recommended to use a single
		/// shader-visible heap of each type, and set it once per frame, rather than regularly changing the bound descriptor heaps. Instead,
		/// use <c><b>ID3D12Device::CopyDescriptors</b></c> and <c><b>ID3D12Device::CopyDescriptorsSimple</b></c> to copy the required
		/// descriptors from shader-opaque heaps to the single shader-visible heap as required during rendering.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps void
		// SetDescriptorHeaps( UINT NumDescriptorHeaps, ID3D12DescriptorHeap * const *ppDescriptorHeaps );
		[PreserveSig]
		new void SetDescriptorHeaps(int NumDescriptorHeaps, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12DescriptorHeap[] ppDescriptorHeaps);

		/// <summary>Sets the layout of the compute root signature.</summary>
		/// <param name="pRootSignature">
		/// <para>Type: <b><c>ID3D12RootSignature</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12RootSignature</c> object.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootsignature void
		// SetComputeRootSignature( [in, optional] ID3D12RootSignature *pRootSignature );
		[PreserveSig]
		new void SetComputeRootSignature([In, Optional] ID3D12RootSignature? pRootSignature);

		/// <summary>Sets the layout of the graphics root signature.</summary>
		/// <param name="pRootSignature">
		/// <para>Type: <b><c>ID3D12RootSignature</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12RootSignature</c> object.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootsignature void
		// SetGraphicsRootSignature( [in, optional] ID3D12RootSignature *pRootSignature );
		[PreserveSig]
		new void SetGraphicsRootSignature([In, Optional] ID3D12RootSignature? pRootSignature);

		/// <summary>Sets a descriptor table into the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BaseDescriptor">
		/// <para>Type: <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A GPU_descriptor_handle object for the base descriptor to set.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable void
		// SetComputeRootDescriptorTable( [in] UINT RootParameterIndex, [in] D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor );
		[PreserveSig]
		new void SetComputeRootDescriptorTable(uint RootParameterIndex, D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);

		/// <summary>Sets a descriptor table into the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BaseDescriptor">
		/// <para>Type: <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A GPU_descriptor_handle object for the base descriptor to set.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable void
		// SetGraphicsRootDescriptorTable( [in] UINT RootParameterIndex, [in] D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor );
		[PreserveSig]
		new void SetGraphicsRootDescriptorTable(uint RootParameterIndex, D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);

		/// <summary>Sets a constant in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="SrcData">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The source data for the constant to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The offset, in 32-bit values, to set the constant in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputeroot32bitconstant void
		// SetComputeRoot32BitConstant( [in] UINT RootParameterIndex, [in] UINT SrcData, [in] UINT DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetComputeRoot32BitConstant(uint RootParameterIndex, uint SrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a constant in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="SrcData">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The source data for the constant to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The offset, in 32-bit values, to set the constant in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsroot32bitconstant void
		// SetGraphicsRoot32BitConstant( [in] UINT RootParameterIndex, [in] UINT SrcData, [in] UINT DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetGraphicsRoot32BitConstant(uint RootParameterIndex, uint SrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a group of constants in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="Num32BitValuesToSet">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of constants to set in the root signature.</para>
		/// </param>
		/// <param name="pSrcData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>The source data for the group of constants to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The offset, in 32-bit values, to set the first constant of the group in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputeroot32bitconstants void
		// SetComputeRoot32BitConstants( [in] UINT RootParameterIndex, [in] UINT Num32BitValuesToSet, [in] const void *pSrcData, [in] UINT
		// DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetComputeRoot32BitConstants(uint RootParameterIndex, uint Num32BitValuesToSet,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] uint[] pSrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a group of constants in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="Num32BitValuesToSet">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of constants to set in the root signature.</para>
		/// </param>
		/// <param name="pSrcData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>The source data for the group of constants to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The offset, in 32-bit values, to set the first constant of the group in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsroot32bitconstants void
		// SetGraphicsRoot32BitConstants( [in] UINT RootParameterIndex, [in] UINT Num32BitValuesToSet, [in] const void *pSrcData, [in] UINT
		// DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetGraphicsRoot32BitConstants(uint RootParameterIndex, uint Num32BitValuesToSet,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] uint[] pSrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a CPU descriptor handle for the constant buffer in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>Specifies the D3D12_GPU_VIRTUAL_ADDRESS of the constant buffer.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootconstantbufferview
		// void SetComputeRootConstantBufferView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetComputeRootConstantBufferView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the constant buffer in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the constant buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootconstantbufferview
		// void SetGraphicsRootConstantBufferView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetGraphicsRootConstantBufferView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the shader resource in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootshaderresourceview
		// void SetComputeRootShaderResourceView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetComputeRootShaderResourceView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the shader resource in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the Buffer. Textures are not supported. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootshaderresourceview
		// void SetGraphicsRootShaderResourceView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetGraphicsRootShaderResourceView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the unordered-access-view resource in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootunorderedaccessview
		// void SetComputeRootUnorderedAccessView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetComputeRootUnorderedAccessView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the unordered-access-view resource in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootunorderedaccessview
		// void SetGraphicsRootUnorderedAccessView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetGraphicsRootUnorderedAccessView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets the view for the index buffer.</summary>
		/// <param name="pView">
		/// <para>Type: <b>const <c>D3D12_INDEX_BUFFER_VIEW</c>*</b></para>
		/// <para>
		/// The view specifies the index buffer's address, size, and <c>DXGI_FORMAT</c>, as a pointer to a <c>D3D12_INDEX_BUFFER_VIEW</c> structure.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Only one index buffer can be bound to the graphics pipeline at any one time. Examples The <c>D3D12Bundles</c> sample uses
		/// <b>ID3D12GraphicsCommandList::IASetIndexBuffer</b> as follows:
		/// </para>
		/// <para>
		/// <c>void FrameResource::PopulateCommandList(ID3D12GraphicsCommandList* pCommandList, ID3D12PipelineState* pPso1,
		/// ID3D12PipelineState* pPso2, UINT frameResourceIndex, UINT numIndices, D3D12_INDEX_BUFFER_VIEW* pIndexBufferViewDesc,
		/// D3D12_VERTEX_BUFFER_VIEW* pVertexBufferViewDesc, ID3D12DescriptorHeap* pCbvSrvDescriptorHeap, UINT cbvSrvDescriptorSize,
		/// ID3D12DescriptorHeap* pSamplerDescriptorHeap, ID3D12RootSignature* pRootSignature) { // If the root signature matches the root
		/// signature of the caller, then // bindings are inherited, otherwise the bind space is reset.
		/// pCommandList-&gt;SetGraphicsRootSignature(pRootSignature); ID3D12DescriptorHeap* ppHeaps[] = { pCbvSrvDescriptorHeap,
		/// pSamplerDescriptorHeap }; pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// pCommandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		/// pCommandList-&gt;IASetIndexBuffer(pIndexBufferViewDesc); pCommandList-&gt;IASetVertexBuffers(0, 1, pVertexBufferViewDesc);
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(0, pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(1, pSamplerDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart()); //
		/// Calculate the descriptor offset due to multiple frame resources. // 1 SRV + how many CBVs we have currently. UINT
		/// frameResourceDescriptorOffset = 1 + (frameResourceIndex * m_cityRowCount * m_cityColumnCount); CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvSrvHandle(pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart(), frameResourceDescriptorOffset,
		/// cbvSrvDescriptorSize); BOOL usePso1 = TRUE; for (UINT i = 0; i &lt; m_cityRowCount; i++) { for (UINT j = 0; j &lt;
		/// m_cityColumnCount; j++) { // Alternate which PSO to use; the pixel shader is different on // each just as a PSO setting
		/// demonstration. pCommandList-&gt;SetPipelineState(usePso1 ? pPso1 : pPso2); usePso1 = !usePso1; // Set this city's CBV table and
		/// move to the next descriptor. pCommandList-&gt;SetGraphicsRootDescriptorTable(2, cbvSrvHandle);
		/// cbvSrvHandle.Offset(cbvSrvDescriptorSize); pCommandList-&gt;DrawIndexedInstanced(numIndices, 1, 0, 0, 0); } } }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-iasetindexbuffer void
		// IASetIndexBuffer( [in, optional] const D3D12_INDEX_BUFFER_VIEW *pView );
		[PreserveSig]
		new void IASetIndexBuffer([In, Optional] StructPointer<D3D12_INDEX_BUFFER_VIEW> pView);

		/// <summary>Sets a CPU descriptor handle for the vertex buffers.</summary>
		/// <param name="StartSlot">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Index into the device's zero-based array to begin setting vertex buffers.</para>
		/// </param>
		/// <param name="NumViews">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of views in the <i>pViews</i> array.</para>
		/// </param>
		/// <param name="pViews">
		/// <para>Type: <b>const <c>D3D12_VERTEX_BUFFER_VIEW</c>*</b></para>
		/// <para>Specifies the vertex buffer views in an array of <c>D3D12_VERTEX_BUFFER_VIEW</c> structures.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-iasetvertexbuffers void
		// IASetVertexBuffers( [in] UINT StartSlot, [in] UINT NumViews, [in, optional] const D3D12_VERTEX_BUFFER_VIEW *pViews );
		[PreserveSig]
		new void IASetVertexBuffers(uint StartSlot, int NumViews, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_VERTEX_BUFFER_VIEW[] pViews);

		/// <summary>Sets the stream output buffer views.</summary>
		/// <param name="StartSlot">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Index into the device's zero-based array to begin setting stream output buffers.</para>
		/// </param>
		/// <param name="NumViews">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of entries in the <i>pViews</i> array.</para>
		/// </param>
		/// <param name="pViews">
		/// <para>Type: <b>const <c>D3D12_STREAM_OUTPUT_BUFFER_VIEW</c>*</b></para>
		/// <para>Specifies an array of <c>D3D12_STREAM_OUTPUT_BUFFER_VIEW</c> structures.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-sosettargets void SOSetTargets( [in]
		// UINT StartSlot, [in] UINT NumViews, [in, optional] const D3D12_STREAM_OUTPUT_BUFFER_VIEW *pViews );
		[PreserveSig]
		new void SOSetTargets(uint StartSlot, int NumViews, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_STREAM_OUTPUT_BUFFER_VIEW[] pViews);

		/// <summary>Sets CPU descriptor handles for the render targets and depth stencil.</summary>
		/// <param name="NumRenderTargetDescriptors">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// The number of entries in the <i>pRenderTargetDescriptors</i> array (ranges between 0 and
		/// <b>D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT</b>). If this parameter is nonzero, the number of entries in the array to which
		/// pRenderTargetDescriptors points must equal the number in this parameter.
		/// </para>
		/// </param>
		/// <param name="pRenderTargetDescriptors">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>
		/// Specifies an array of <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> structures that describe the CPU descriptor handles that represents the
		/// start of the heap of render target descriptors. If this parameter is NULL and NumRenderTargetDescriptors is 0, no render targets
		/// are bound.
		/// </para>
		/// </param>
		/// <param name="RTsSingleHandleToDescriptorRange">
		/// <para>Type: <b>BOOL</b></para>
		/// <para>
		/// <b>True</b> means the handle passed in is the pointer to a contiguous range of <i>NumRenderTargetDescriptors</i> descriptors.
		/// This case is useful if the set of descriptors to bind already happens to be contiguous in memory (so all thats needed is a
		/// handle to the first one). For example, if <i>NumRenderTargetDescriptors</i> is 3 then the memory layout is taken as follows:
		/// </para>
		/// <para>In this case the driver dereferences the handle and then increments the memory being pointed to.</para>
		/// <para>
		/// <b>False</b> means that the handle is the first of an array of <i>NumRenderTargetDescriptors</i> handles. The false case allows
		/// an application to bind a set of descriptors from different locations at once. Again assuming that
		/// <i>NumRenderTargetDescriptors</i> is 3, the memory layout is taken as follows:
		/// </para>
		/// <para>In this case the driver dereferences three handles that are expected to be adjacent to each other in memory.</para>
		/// </param>
		/// <param name="pDepthStencilDescriptor">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>
		/// A pointer to a <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> structure that describes the CPU descriptor handle that represents the start
		/// of the heap that holds the depth stencil descriptor. If this parameter is NULL, no depth stencil descriptor is bound.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets void
		// OMSetRenderTargets( [in] UINT NumRenderTargetDescriptors, [in, optional] const D3D12_CPU_DESCRIPTOR_HANDLE
		// *pRenderTargetDescriptors, [in] BOOL RTsSingleHandleToDescriptorRange, [in, optional] const D3D12_CPU_DESCRIPTOR_HANDLE
		// *pDepthStencilDescriptor );
		[PreserveSig]
		new void OMSetRenderTargets(uint NumRenderTargetDescriptors,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_CPU_DESCRIPTOR_HANDLE[]? pRenderTargetDescriptors,
			bool RTsSingleHandleToDescriptorRange, [In, Optional] StructPointer<D3D12_CPU_DESCRIPTOR_HANDLE> pDepthStencilDescriptor);

		/// <summary>Clears the depth-stencil resource.</summary>
		/// <param name="DepthStencilView">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap for the depth stencil to be cleared.</para>
		/// </param>
		/// <param name="ClearFlags">
		/// <para>Type: <b><c>D3D12_CLEAR_FLAGS</c></b></para>
		/// <para>
		/// A combination of <c>D3D12_CLEAR_FLAGS</c> values that are combined by using a bitwise OR operation. The resulting value
		/// identifies the type of data to clear (depth buffer, stencil buffer, or both).
		/// </para>
		/// </param>
		/// <param name="Depth">
		/// <para>Type: <b><c>FLOAT</c></b></para>
		/// <para>A value to clear the depth buffer with. This value will be clamped between 0 and 1.</para>
		/// </param>
		/// <param name="Stencil">
		/// <para>Type: <b>UINT8</b></para>
		/// <para>A value to clear the stencil buffer with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of rectangles in the array that the <i>pRects</i> parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: <b>const <b>D3D12_RECT</b>*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearDepthStencilView</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>Only direct and bundle command lists support this operation.</para>
		/// <para>
		/// <b>ClearDepthStencilView</b> may be used to initialize resources which alias the same heap memory. See
		/// <c>CreatePlacedResource</c> for more details.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>For floating-point inputs, the runtime will set denormalized values to 0 (while preserving NANs).</para>
		/// <para>Validation failure will result in the call to <c>Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>The debug layer will issue errors if the input colors are denormalized.</para>
		/// <para>
		/// The debug layer will issue an error if the subresources referenced by the view are not in the appropriate state. For
		/// <b>ClearDepthStencilView</b>, the state must be in the state <c>D3D12_RESOURCE_STATE_DEPTH_WRITE</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-cleardepthstencilview void
		// ClearDepthStencilView( [in] D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView, [in] D3D12_CLEAR_FLAGS ClearFlags, [in] FLOAT Depth,
		// [in] UINT8 Stencil, [in] UINT NumRects, [in] const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearDepthStencilView([In] D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView, D3D12_CLEAR_FLAGS ClearFlags, float Depth, byte Stencil,
			[Optional] int NumRects, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] RECT[]? pRects);

		/// <summary>Sets all the elements in a render target to one value.</summary>
		/// <param name="RenderTargetView">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// Specifies a D3D12_CPU_DESCRIPTOR_HANDLE structure that describes the CPU descriptor handle that represents the start of the heap
		/// for the render target to be cleared.
		/// </para>
		/// </param>
		/// <param name="ColorRGBA">
		/// <para>Type: <b>const FLOAT[4]</b></para>
		/// <para>A 4-component array that represents the color to fill the render target with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of rectangles in the array that the <i>pRects</i> parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: <b>const D3D12_RECT*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearRenderTargetView</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>ClearRenderTargetView</b> may be used to initialize resources which alias the same heap memory. See
		/// <c>CreatePlacedResource</c> for more details.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>For floating-point inputs, the runtime will set denormalized values to 0 (while preserving NANs).</para>
		/// <para>Validation failure will result in the call to <c>Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>The debug layer will issue errors if the input colors are denormalized.</para>
		/// <para>
		/// The debug layer will issue an error if the subresources referenced by the view are not in the appropriate state. For
		/// <b>ClearRenderTargetView</b>, the state must be <c>D3D12_RESOURCE_STATE_RENDER_TARGET</c>. Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::ClearRenderTargetView</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>The <c>D3D12Multithreading</c> sample uses <b>ID3D12GraphicsCommandList::ClearRenderTargetView</b> as follows:</para>
		/// <para><c>// Frame resources. FrameResource* m_frameResources[FrameCount]; FrameResource* m_pCurrentFrameResource; int m_currentFrameResourceIndex;</c></para>
		/// <para>
		/// <c>// Assemble the CommandListPre command list. void D3D12Multithreading::BeginFrame() { m_pCurrentFrameResource-&gt;Init(); //
		/// Indicate that the back buffer will be used as a render target.
		/// m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT,
		/// D3D12_RESOURCE_STATE_RENDER_TARGET)); // Clear the render target and depth stencil. const float clearColor[] = { 0.0f, 0.0f,
		/// 0.0f, 1.0f }; CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex,
		/// m_rtvDescriptorSize); m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ClearRenderTargetView(rtvHandle,
		/// clearColor, 0, nullptr);
		/// m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ClearDepthStencilView(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(),
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
		/// ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;Close()); } // Assemble the CommandListMid command
		/// list. void D3D12Multithreading::MidFrame() { // Transition our shadow map from the shadow pass to readable in the scene pass.
		/// m_pCurrentFrameResource-&gt;SwapBarriers();
		/// ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandLists[CommandListMid]-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearrendertargetview void
		// ClearRenderTargetView( [in] D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView, [in] const FLOAT [4] ColorRGBA, [in] UINT NumRects,
		// [in] const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearRenderTargetView([In] D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] float[] ColorRGBA,
			[Optional] int NumRects, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] RECT[]? pRects);

		/// <summary>
		/// <para>Sets all the elements in a unordered-access view (UAV) to the specified integer values.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This behaves like a compute operation in that it isn't ordered with respect to surrounding work such as <b>Dispatch</b> calls.
		/// To ensure ordering, barrier calls must be issued before and/or after the <b>ClearUnorderedAccessViewXxx</b> call as needed. It
		/// might appear on some drivers that such barriers aren't necessary. But implicit barriers are not a spec guarantee; so they can't
		/// be relied upon. This is in contrast to <b>ClearDepthStencilView</b> and <b>ClearRenderTargetView</b> which (like <b>DrawXxx</b>
		/// commands), respect command list ordering.
		/// </para>
		/// </para>
		/// </summary>
		/// <param name="ViewGPUHandleInCurrentHeap">
		/// <para>Type: [in] <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_GPU_DESCRIPTOR_HANDLE</c> that references an initialized descriptor for the unordered-access view (UAV) that is to be
		/// cleared. This descriptor must be in a shader-visible descriptor heap, which must be set on the command list via <c>SetDescriptorHeaps</c>.
		/// </para>
		/// </param>
		/// <param name="ViewCPUHandle">
		/// <para>Type: [in] <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> in a non-shader visible descriptor heap that references an initialized descriptor for the
		/// unordered-access view (UAV) that is to be cleared.
		/// </para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This descriptor must not be in a shader-visible descriptor heap. This is to allow drivers that implement the clear as a
		/// fixed-function hardware operation (rather than as a dispatch) to efficiently read from the descriptor, as shader-visible heaps
		/// may be created in <b>WRITE_BACK</b> memory (similar to <b>D3D12_HEAP_TYPE_UPLOAD</b> heap types), and CPU reads from this type
		/// of memory are prohibitively slow.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="pResource">
		/// <para>Type: [in] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the unordered-access-view (UAV) resource to clear.</para>
		/// </param>
		/// <param name="Values">
		/// <para>Type: [in] <b>const UINT[4]</b></para>
		/// <para>A 4-component array that containing the values to fill the unordered-access-view resource with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The number of rectangles in the array that the pRects parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: [in] <b>const <c>D3D12_RECT</c>*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearUnorderedAccessViewUint</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>Runtime validation</para>
		/// <para>Validation failure results in the call to <c>ID3D12GraphicsCommandList::Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para>Debug layer</para>
		/// <para>The debug layer issues errors if the input values are outside of a normalized range.</para>
		/// <para>
		/// The debug layer issues an error if the subresources referenced by the view aren't in the appropriate state. For
		/// <b>ClearUnorderedAccessViewUint</b>, the state must be <c>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewuint void
		// ClearUnorderedAccessViewUint( D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
		// ID3D12Resource *pResource, const UINT [4] Values, UINT NumRects, const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearUnorderedAccessViewUint([In] D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, [In] D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
			[In] ID3D12Resource pResource, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] uint[] Values, int NumRects,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] RECT[] pRects);

		/// <summary>
		/// <para>Sets all of the elements in an unordered-access view (UAV) to the specified float values.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This behaves like a compute operation in that it isn't ordered with respect to surrounding work such as <b>Dispatch</b> calls.
		/// To ensure ordering, barrier calls must be issued before and/or after the <b>ClearUnorderedAccessViewXxx</b> call as needed. It
		/// might appear on some drivers that such barriers aren't necessary. But implicit barriers are not a spec guarantee; so they can't
		/// be relied upon. This is in contrast to <b>ClearDepthStencilView</b> and <b>ClearRenderTargetView</b> which (like <b>DrawXxx</b>
		/// commands), respect command list ordering.
		/// </para>
		/// </para>
		/// </summary>
		/// <param name="ViewGPUHandleInCurrentHeap">
		/// <para>Type: [in] <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_GPU_DESCRIPTOR_HANDLE</c> that references an initialized descriptor for the unordered-access view (UAV) that is to be
		/// cleared. This descriptor must be in a shader-visible descriptor heap, which must be set on the command list via <c>SetDescriptorHeaps</c>.
		/// </para>
		/// </param>
		/// <param name="ViewCPUHandle">
		/// <para>Type: [in] <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> in a non-shader visible descriptor heap that references an initialized descriptor for the
		/// unordered-access view (UAV) that is to be cleared.
		/// </para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This descriptor must not be in a shader-visible descriptor heap. This is to allow drivers that implement the clear as a
		/// fixed-function hardware operation (rather than as a dispatch) to efficiently read from the descriptor, as shader-visible heaps
		/// may be created in <b>WRITE_BACK</b> memory (similar to <b>D3D12_HEAP_TYPE_UPLOAD</b> heap types), and CPU reads from this type
		/// of memory are prohibitively slow.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="pResource">
		/// <para>Type: [in] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the unordered-access-view (UAV) resource to clear.</para>
		/// </param>
		/// <param name="Values">
		/// <para>Type: [in] <b>const FLOAT[4]</b></para>
		/// <para>A 4-component array that containing the values to fill the unordered-access-view resource with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The number of rectangles in the array that the pRects parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: [in] <b>const <c>D3D12_RECT</c>*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearUnorderedAccessViewFloat</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>Runtime validation</para>
		/// <para>For floating-point inputs, the runtime sets denormalized values to 0 (while preserving NANs).</para>
		/// <para>If you want to clear the UAV to a specific bit pattern, consider using <c>ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint</c>.</para>
		/// <para>Validation failure results in the call to <c>ID3D12GraphicsCommandList::Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para>Debug layer</para>
		/// <para>The debug layer issues errors if the input values are outside of a normalized range.</para>
		/// <para>
		/// The debug layer issues an error if the subresources referenced by the view aren't in the appropriate state. For
		/// <b>ClearUnorderedAccessViewFloat</b>, the state must be <c>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewfloat void
		// ClearUnorderedAccessViewFloat( D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
		// ID3D12Resource *pResource, const FLOAT [4] Values, UINT NumRects, const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearUnorderedAccessViewFloat([In] D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, [In] D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
			[In] ID3D12Resource pResource, [In, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] float[] Values, int NumRects,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] RECT[] pRects);

		/// <summary>
		/// Indicates that the contents of a resource don't need to be preserved. The function may re-initialize resource metadata in some cases.
		/// </summary>
		/// <param name="pResource">
		/// <para>Type: [in] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface for the resource to discard.</para>
		/// </param>
		/// <param name="pRegion">
		/// <para>Type: [in, optional] <b>const <c>D3D12_DISCARD_REGION</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DISCARD_REGION</c> structure that describes details for the discard-resource operation.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>The semantics of <b>DiscardResource</b> change based on the command list type.</para>
		/// <para>For <c>D3D12_COMMAND_LIST_TYPE_DIRECT</c>, the following two rules apply:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// When a resource has the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> flag, <b>DiscardResource</b> must be called when the
		/// discarded subresource regions are in the <c>D3D12_RESOURCE_STATE_RENDER_TARGET</c> resource barrier state.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// When a resource has the <c>D3D12_RESOURCE_FLAG _ALLOW_DEPTH_STENCIL</c> flag, <b>DiscardResource</b> must be called when the
		/// discarded subresource regions are in the <c>D3D12_RESOURCE_STATE_DEPTH_WRITE</c>.
		/// </description>
		/// </item>
		/// </list>
		/// <para>For <c>D3D12_COMMAND_LIST_TYPE_COMPUTE</c>, the following rule applies:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// The resource must have the <c>D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS</c> flag, and <b>DiscardResource</b> must be called
		/// when the discarded subresource regions are in the <c>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</c> resource barrier state.
		/// </description>
		/// </item>
		/// </list>
		/// <para><b>DiscardResource</b> is not supported on command lists with either <c>D3D12_COMMAND_LIST_TYPE_BUNDLE</c> nor <b>D3D12_COMMAND_LIST_TYPE_COPY</b>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-discardresource void
		// DiscardResource( ID3D12Resource *pResource, const D3D12_DISCARD_REGION *pRegion );
		[PreserveSig]
		new void DiscardResource([In] ID3D12Resource pResource, [In, Optional] StructPointer<D3D12_DISCARD_REGION> pRegion);

		/// <summary>Starts a query running.</summary>
		/// <param name="pQueryHeap">
		/// <para>Type: <b><c>ID3D12QueryHeap</c>*</b></para>
		/// <para>Specifies the <c>ID3D12QueryHeap</c> containing the query.</para>
		/// </param>
		/// <param name="Type">
		/// <para>Type: <b><c>D3D12_QUERY_TYPE</c></b></para>
		/// <para>Specifies one member of <c>D3D12_QUERY_TYPE</c>.</para>
		/// </param>
		/// <param name="Index">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the index of the query within the query heap.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// See <c>Queries</c> for more information about D3D12 queries. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12GraphicsCommandList::BeginQuery</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void
		/// D3D12PredicationQueries::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); // Draw the quads and perform the occlusion query. { CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); // Draw the far quad conditionally based on the result of the occlusion query // from the previous
		/// frame. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad); m_commandList-&gt;SetPredication(m_queryResult.Get(), 0,
		/// D3D12_PREDICATION_OP_EQUAL_ZERO); m_commandList-&gt;DrawInstanced(4, 1, 0, 0); // Disable predication and always draw the near
		/// quad. m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
		/// m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad); m_commandList-&gt;DrawInstanced(4, 1, 4, 0); // Run the
		/// occlusion query with the bounding box quad. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
		/// m_commandList-&gt;SetPipelineState(m_queryState.Get()); m_commandList-&gt;BeginQuery(m_queryHeap.Get(),
		/// D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
		/// m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); // Resolve the occlusion query and store
		/// the results in the query result buffer // to be used on the subsequent frame. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION,
		/// D3D12_RESOURCE_STATE_COPY_DEST)); m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1,
		/// m_queryResult.Get(), 0); m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(),
		/// D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION)); } // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-beginquery void BeginQuery( [in]
		// ID3D12QueryHeap *pQueryHeap, [in] D3D12_QUERY_TYPE Type, [in] UINT Index );
		[PreserveSig]
		new void BeginQuery([In] ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);

		/// <summary>Ends a running query.</summary>
		/// <param name="pQueryHeap">
		/// <para>Type: <b><c>ID3D12QueryHeap</c>*</b></para>
		/// <para>Specifies the <c>ID3D12QueryHeap</c> containing the query.</para>
		/// </param>
		/// <param name="Type">
		/// <para>Type: <b><c>D3D12_QUERY_TYPE</c></b></para>
		/// <para>Specifies one member of <c>D3D12_QUERY_TYPE</c>.</para>
		/// </param>
		/// <param name="Index">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the index of the query in the query heap.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// See <c>Queries</c> for more information about D3D12 queries. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12GraphicsCommandList::EndQuery</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void
		/// D3D12PredicationQueries::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); // Draw the quads and perform the occlusion query. { CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); // Draw the far quad conditionally based on the result of the occlusion query // from the previous
		/// frame. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad); m_commandList-&gt;SetPredication(m_queryResult.Get(), 0,
		/// D3D12_PREDICATION_OP_EQUAL_ZERO); m_commandList-&gt;DrawInstanced(4, 1, 0, 0); // Disable predication and always draw the near
		/// quad. m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
		/// m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad); m_commandList-&gt;DrawInstanced(4, 1, 4, 0); // Run the
		/// occlusion query with the bounding box quad. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
		/// m_commandList-&gt;SetPipelineState(m_queryState.Get()); m_commandList-&gt;BeginQuery(m_queryHeap.Get(),
		/// D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
		/// m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); // Resolve the occlusion query and store
		/// the results in the query result buffer // to be used on the subsequent frame. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION,
		/// D3D12_RESOURCE_STATE_COPY_DEST)); m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1,
		/// m_queryResult.Get(), 0); m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(),
		/// D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION)); } // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-endquery void EndQuery( [in]
		// ID3D12QueryHeap *pQueryHeap, [in] D3D12_QUERY_TYPE Type, [in] UINT Index );
		[PreserveSig]
		new void EndQuery([In] ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);

		/// <summary>Extracts data from a query. <b>ResolveQueryData</b> works with all heap types (default, upload, and readback).</summary>
		/// <param name="pQueryHeap">
		/// <para>Type: <b><c>ID3D12QueryHeap</c>*</b></para>
		/// <para>Specifies the <c>ID3D12QueryHeap</c> containing the queries to resolve.</para>
		/// </param>
		/// <param name="Type">
		/// <para>Type: <b><c>D3D12_QUERY_TYPE</c></b></para>
		/// <para>Specifies the type of query, one member of <c>D3D12_QUERY_TYPE</c>.</para>
		/// </param>
		/// <param name="StartIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies an index of the first query to resolve.</para>
		/// </param>
		/// <param name="NumQueries">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of queries to resolve.</para>
		/// </param>
		/// <param name="pDestinationBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies an <c>ID3D12Resource</c> destination buffer, which must be in the state <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.</para>
		/// </param>
		/// <param name="AlignedDestinationBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies an alignment offset into the destination buffer. Must be a multiple of 8 bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>ResolveQueryData</b> performs a batched operation that writes query data into a destination buffer. Query data is written
		/// contiguously to the destination buffer, and the parameter.
		/// </para>
		/// <para>
		/// <b>ResolveQueryData</b> turns application-opaque query data in an application-opaque query heap into adapter-agnostic values
		/// usable by your application. Resolving queries within a heap that have not been completed (so have had
		/// <c><b>ID3D12GraphicsCommandList::BeginQuery</b></c> called for them, but not <c><b>ID3D12GraphicsCommandList::EndQuery</b></c>),
		/// or that have been uninitialized, results in undefined behavior and might cause device hangs or removal. The debug layer will
		/// emit an error if it detects an application has resolved incomplete or uninitialized queries.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>
		/// Resolving incomplete or uninitialized queries is undefined behavior because the driver might internally store GPUVAs or other
		/// data within unresolved queries. And so attempting to resolve these queries on uninitialized data could cause a page fault or
		/// device hang. Older versions of the debug layer didn't validate this behavior.
		/// </para>
		/// </para>
		/// <para>
		/// Binary occlusion queries write 64-bits per query. The least significant bit is either 0 (the object was entirely occluded) or 1
		/// (at least 1 sample of the object would have been drawn). The rest of the bits are 0. Occlusion queries write 64-bits per query.
		/// The value is the number of samples that passed testing. Timestamp queries write 64-bits per query, which is a tick value that
		/// must be compared to the respective command queue frequency (see <c>Timing</c>).
		/// </para>
		/// <para>
		/// Pipeline statistics queries write a <c><b>D3D12_QUERY_DATA_PIPELINE_STATISTICS</b></c> structure per query. All stream-out
		/// statistics queries write a <c><b>D3D12_QUERY_DATA_SO_STATISTICS</b></c> structure per query.
		/// </para>
		/// <para>The core runtime will validate the following.</para>
		/// <list type="bullet">
		/// <item>
		/// <description><i>StartIndex</i> and <i>NumQueries</i> are within range.</description>
		/// </item>
		/// <item>
		/// <description><i>AlignedDestinationBufferOffset</i> is a multiple of 8 bytes.</description>
		/// </item>
		/// <item>
		/// <description><i>DestinationBuffer</i> is a buffer.</description>
		/// </item>
		/// <item>
		/// <description>The written data will not overflow the output buffer.</description>
		/// </item>
		/// <item>
		/// <description>The query type must be supported by the command list type.</description>
		/// </item>
		/// <item>
		/// <description>The query type must be supported by the query heap.</description>
		/// </item>
		/// </list>
		/// <para>
		/// The debug layer will issue a warning if the destination buffer is not in the D3D12_RESOURCE_STATE_COPY_DEST state, or if any
		/// queries being resolved have not had <c><b>ID3D12GraphicsCommandList::EndQuery</b></c> called on them.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvequerydata void
		// ResolveQueryData( [in] ID3D12QueryHeap *pQueryHeap, [in] D3D12_QUERY_TYPE Type, [in] UINT StartIndex, [in] UINT NumQueries, [in]
		// ID3D12Resource *pDestinationBuffer, [in] UINT64 AlignedDestinationBufferOffset );
		[PreserveSig]
		new void ResolveQueryData([In] ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint StartIndex, uint NumQueries,
			[In] ID3D12Resource pDestinationBuffer, ulong AlignedDestinationBufferOffset);

		/// <summary>Sets a rendering predicate.</summary>
		/// <param name="pBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>
		/// The buffer, as an <c>ID3D12Resource</c>, which must be in the <c><b>D3D12_RESOURCE_STATE_PREDICATION</b></c> or
		/// <c><b>D3D21_RESOURCE_STATE_INDIRECT_ARGUMENT</b></c> state (both values are identical, and provided as aliases for clarity), or
		/// <b>NULL</b> to disable predication.
		/// </para>
		/// </param>
		/// <param name="AlignedBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The aligned buffer offset, as a UINT64.</para>
		/// </param>
		/// <param name="Operation">
		/// <para>Type: <b><c>D3D12_PREDICATION_OP</c></b></para>
		/// <para>Specifies a <c>D3D12_PREDICATION_OP</c>, such as D3D12_PREDICATION_OP_EQUAL_ZERO or D3D12_PREDICATION_OP_NOT_EQUAL_ZERO.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Use this method to denote that subsequent rendering and resource manipulation commands are not actually performed if the
		/// resulting predicate data of the predicate is equal to the operation specified.
		/// </para>
		/// <para>
		/// Unlike Direct3D 11, in Direct3D 12 predication state is not inherited by direct command lists, and predication is always
		/// respected (there are no predication hints). All direct command lists begin with predication disabled. Bundles do inherit
		/// predication state. It is legal for the same predicate to be bound multiple times.
		/// </para>
		/// <para>
		/// Illegal API calls will result in <c>Close</c> returning an error, or <c>ID3D12CommandQueue::ExecuteCommandLists</c> dropping the
		/// command list and removing the device.
		/// </para>
		/// <para>The debug layer will issue errors whenever the runtime validation fails.</para>
		/// <para>
		/// Refer to <c>Predication</c> for more information. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12GraphicsCommandList::SetPredication</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void
		/// D3D12PredicationQueries::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); // Draw the quads and perform the occlusion query. { CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); // Draw the far quad conditionally based on the result of the occlusion query // from the previous
		/// frame. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad); m_commandList-&gt;SetPredication(m_queryResult.Get(), 0,
		/// D3D12_PREDICATION_OP_EQUAL_ZERO); m_commandList-&gt;DrawInstanced(4, 1, 0, 0); // Disable predication and always draw the near
		/// quad. m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
		/// m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad); m_commandList-&gt;DrawInstanced(4, 1, 4, 0); // Run the
		/// occlusion query with the bounding box quad. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
		/// m_commandList-&gt;SetPipelineState(m_queryState.Get()); m_commandList-&gt;BeginQuery(m_queryHeap.Get(),
		/// D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
		/// m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); // Resolve the occlusion query and store
		/// the results in the query result buffer // to be used on the subsequent frame. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION,
		/// D3D12_RESOURCE_STATE_COPY_DEST)); m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1,
		/// m_queryResult.Get(), 0); m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(),
		/// D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION)); } // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setpredication void SetPredication(
		// [in, optional] ID3D12Resource *pBuffer, [in] UINT64 AlignedBufferOffset, [in] D3D12_PREDICATION_OP Operation );
		[PreserveSig]
		new void SetPredication([In, Optional] ID3D12Resource? pBuffer, ulong AlignedBufferOffset, D3D12_PREDICATION_OP Operation);

		/// <summary>Not intended to be called directly. Use the <c>PIX event runtime</c> to insert events into a command list.</summary>
		/// <param name="Metadata">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="Size">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This is a support method used internally by the PIX event runtime. It is not intended to be called directly.</para>
		/// <para>
		/// To insert instrumentation markers at the current location within a D3D12 command list, use the <b>PIXSetMarker</b> function.
		/// This is provided by the <c>WinPixEventRuntime</c> NuGet package.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setmarker void SetMarker( UINT
		// Metadata, [in, optional] const void *pData, UINT Size );
		[PreserveSig]
		new void SetMarker(uint Metadata, [In, Optional] IntPtr pData, uint Size);

		/// <summary>Not intended to be called directly. Use the <c>PIX event runtime</c> to insert events into a command list.</summary>
		/// <param name="Metadata">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="Size">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This is a support method used internally by the PIX event runtime. It is not intended to be called directly.</para>
		/// <para>
		/// To mark the start of an instrumentation region at the current location within a D3D12 command list, use the <b>PIXBeginEvent</b>
		/// function or <b>PIXScopedEvent</b> macro. These are provided by the <c>WinPixEventRuntime</c> NuGet package.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-beginevent void BeginEvent( UINT
		// Metadata, [in, optional] const void *pData, UINT Size );
		[PreserveSig]
		new void BeginEvent(uint Metadata, [In, Optional] IntPtr pData, uint Size);

		/// <summary>Not intended to be called directly. Use the <c>PIX event runtime</c> to insert events into a command list.</summary>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This is a support method used internally by the PIX event runtime. It is not intended to be called directly.</para>
		/// <para>
		/// To mark the end of an instrumentation region at the current location within a D3D12 command list, use the <b>PIXEndEvent</b>
		/// function or <b>PIXScopedEvent</b> macro. These are provided by the <c>WinPixEventRuntime</c> NuGet package.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-endevent void EndEvent();
		[PreserveSig]
		new void EndEvent();

		/// <summary>Apps perform indirect draws/dispatches using the <b>ExecuteIndirect</b> method.</summary>
		/// <param name="pCommandSignature">
		/// <para>Type: <b><c>ID3D12CommandSignature</c>*</b></para>
		/// <para>
		/// Specifies a <c>ID3D12CommandSignature</c>. The data referenced by <i>pArgumentBuffer</i> will be interpreted depending on the
		/// contents of the command signature. Refer to <c>Indirect Drawing</c> for the APIs that are used to create a command signature.
		/// </para>
		/// </param>
		/// <param name="MaxCommandCount">
		/// <para>Type: <b>UINT</b></para>
		/// <para>There are two ways that command counts can be specified:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// If <i>pCountBuffer</i> is not NULL, then <i>MaxCommandCount</i> specifies the maximum number of operations which will be
		/// performed. The actual number of operations to be performed are defined by the minimum of this value, and a 32-bit unsigned
		/// integer contained in <i>pCountBuffer</i> (at the byte offset specified by <i>CountBufferOffset</i>).
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// If <i>pCountBuffer</i> is NULL, the <i>MaxCommandCount</i> specifies the exact number of operations which will be performed.
		/// </description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pArgumentBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies one or more <c>ID3D12Resource</c> objects, containing the command arguments.</para>
		/// </param>
		/// <param name="ArgumentBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies an offset into <i>pArgumentBuffer</i> to identify the first command argument.</para>
		/// </param>
		/// <param name="pCountBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies a pointer to a <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="CountBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies a UINT64 that is the offset into <i>pCountBuffer</i>, identifying the argument count.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>The semantics of this API are defined with the following pseudo-code:</para>
		/// <para>Non-NULL pCountBuffer:</para>
		/// <para>
		/// <c>// Read draw count out of count buffer UINT CommandCount = pCountBuffer-&gt;ReadUINT32(CountBufferOffset); CommandCount =
		/// min(CommandCount, MaxCommandCount) // Get pointer to first Commanding argument BYTE* Arguments = pArgumentBuffer-&gt;GetBase() +
		/// ArgumentBufferOffset; for(UINT CommandIndex = 0; CommandIndex &lt; CommandCount; CommandIndex++) { // Interpret the data
		/// contained in *Arguments // according to the command signature pCommandSignature-&gt;Interpret(Arguments); Arguments +=
		/// pCommandSignature-&gt;GetByteStride(); }</c>
		/// </para>
		/// <para>NULL pCountBuffer:</para>
		/// <para>
		/// <c>// Get pointer to first Commanding argument BYTE* Arguments = pArgumentBuffer-&gt;GetBase() + ArgumentBufferOffset; for(UINT
		/// CommandIndex = 0; CommandIndex &lt; MaxCommandCount; CommandIndex++) { // Interpret the data contained in *Arguments //
		/// according to the command signature pCommandSignature-&gt;Interpret(Arguments); Arguments +=
		/// pCommandSignature-&gt;GetByteStride(); }</c>
		/// </para>
		/// <para>
		/// The debug layer will issue an error if either the count buffer or the argument buffer are not in the
		/// D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT state. The core runtime will validate:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description><i>CountBufferOffset</i> and <i>ArgumentBufferOffset</i> are 4-byte aligned</description>
		/// </item>
		/// <item>
		/// <description><i>pCountBuffer</i> and <i>pArgumentBuffer</i> are buffer resources (any heap type)</description>
		/// </item>
		/// <item>
		/// <description>
		/// The offset implied by <i>MaxCommandCount</i>, <i>ArgumentBufferOffset</i>, and the drawing program stride do not exceed the
		/// bounds of <i>pArgumentBuffer</i> (similarly for count buffer)
		/// </description>
		/// </item>
		/// <item>
		/// <description>The command list is a direct command list or a compute command list (not a copy or JPEG decode command list)</description>
		/// </item>
		/// <item>
		/// <description>The root signature of the command list matches the root signature of the command signature</description>
		/// </item>
		/// </list>
		/// <para>
		/// The functionality of two APIs from earlier versions of Direct3D, <c>DrawInstancedIndirect</c> and
		/// <c>DrawIndexedInstancedIndirect</c>, are encompassed by <b>ExecuteIndirect</b>.
		/// </para>
		/// <para><c></c><c></c><c></c> Bundles</para>
		/// <para>
		/// <b>ID3D12GraphicsCommandList::ExecuteIndirect</b> is allowed inside of bundle command lists only if all of the following are true:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>CountBuffer is NULL (CPU-specified count only).</description>
		/// </item>
		/// <item>
		/// <description>
		/// The command signature contains exactly one operation. This implies that the command signature does not contain root arguments
		/// changes, nor contain VB/IB binding changes.
		/// </description>
		/// </item>
		/// </list>
		/// <para><c></c><c></c><c></c> Obtaining buffer virtual addresses</para>
		/// <para>The <c>ID3D12Resource::GetGPUVirtualAddress</c> method enables an app to retrieve the GPU virtual address of a buffer.</para>
		/// <para>
		/// Apps are free to apply byte offsets to virtual addresses before placing them in an indirect argument buffer. Note that all of
		/// the D3D12 alignment requirements for VB/IB/CB still apply to the resulting GPU virtual address. Examples The
		/// <c>D3D12ExecuteIndirect</c> sample uses <b>ID3D12GraphicsCommandList::ExecuteIndirect</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Data structure to match the command signature used for ExecuteIndirect. struct IndirectCommand { D3D12_GPU_VIRTUAL_ADDRESS
		/// cbv; D3D12_DRAW_ARGUMENTS drawArguments; };</c>
		/// </para>
		/// <para>
		/// The call to <b>ExecuteIndirect</b> is near the end of this listing, below the comment "Draw the triangles that have not been culled."
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void D3D12ExecuteIndirect::PopulateCommandLists()
		/// { // Command list allocators can only be reset when the associated // command lists have finished execution on the GPU; apps
		/// should use // fences to determine GPU execution progress. ThrowIfFailed(m_computeCommandAllocators[m_frameIndex]-&gt;Reset());
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_computeCommandList-&gt;Reset(m_computeCommandAllocators[m_frameIndex].Get(), m_computeState.Get()));
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Record the compute
		/// commands that will cull triangles and prevent them from being processed by the vertex shader. if (m_enableCulling) { UINT
		/// frameDescriptorOffset = m_frameIndex * CbvSrvUavDescriptorCountPerFrame; D3D12_GPU_DESCRIPTOR_HANDLE cbvSrvUavHandle =
		/// m_cbvSrvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart();
		/// m_computeCommandList-&gt;SetComputeRootSignature(m_computeRootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = {
		/// m_cbvSrvUavHeap.Get() }; m_computeCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// m_computeCommandList-&gt;SetComputeRootDescriptorTable( SrvUavTable, CD3DX12_GPU_DESCRIPTOR_HANDLE(cbvSrvUavHandle, CbvSrvOffset
		/// + frameDescriptorOffset, m_cbvSrvUavDescriptorSize)); m_computeCommandList-&gt;SetComputeRoot32BitConstants(RootConstants, 4,
		/// reinterpret_cast&lt;void*&gt;(&amp;m_csRootConstants), 0); // Reset the UAV counter for this frame.
		/// m_computeCommandList-&gt;CopyBufferRegion(m_processedCommandBuffers[m_frameIndex].Get(), CommandBufferSizePerFrame,
		/// m_processedCommandBufferCounterReset.Get(), 0, sizeof(UINT)); D3D12_RESOURCE_BARRIER barrier =
		/// CD3DX12_RESOURCE_BARRIER::Transition(m_processedCommandBuffers[m_frameIndex].Get(), D3D12_RESOURCE_STATE_COPY_DEST,
		/// D3D12_RESOURCE_STATE_UNORDERED_ACCESS); m_computeCommandList-&gt;ResourceBarrier(1, &amp;barrier);
		/// m_computeCommandList-&gt;Dispatch(static_cast&lt;UINT&gt;(ceil(TriangleCount / float(ComputeThreadBlockSize))), 1, 1); }
		/// ThrowIfFailed(m_computeCommandList-&gt;Close()); // Record the rendering commands. { // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvSrvUavHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, m_enableCulling ? &amp;m_cullingScissorRect : &amp;m_scissorRect); // Indicate that the
		/// command buffer will be used for indirect drawing // and that the back buffer will be used as a render target.
		/// D3D12_RESOURCE_BARRIER barriers[2] = { CD3DX12_RESOURCE_BARRIER::Transition( m_enableCulling ?
		/// m_processedCommandBuffers[m_frameIndex].Get() : m_commandBuffer.Get(), m_enableCulling ? D3D12_RESOURCE_STATE_UNORDERED_ACCESS :
		/// D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT), CD3DX12_RESOURCE_BARRIER::Transition(
		/// m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET) };
		/// m_commandList-&gt;ResourceBarrier(_countof(barriers), barriers); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
		/// m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;m_vertexBufferView); if (m_enableCulling) { // Draw the triangles that have not
		/// been culled. m_commandList-&gt;ExecuteIndirect( m_commandSignature.Get(), TriangleCount,
		/// m_processedCommandBuffers[m_frameIndex].Get(), 0, m_processedCommandBuffers[m_frameIndex].Get(), CommandBufferSizePerFrame); }
		/// else { // Draw all of the triangles. m_commandList-&gt;ExecuteIndirect( m_commandSignature.Get(), TriangleCount,
		/// m_commandBuffer.Get(), CommandBufferSizePerFrame * m_frameIndex, nullptr, 0); } // Indicate that the command buffer may be used
		/// by the compute shader // and that the back buffer will now be used to present. barriers[0].Transition.StateBefore =
		/// D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT; barriers[0].Transition.StateAfter = m_enableCulling ? D3D12_RESOURCE_STATE_COPY_DEST :
		/// D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE; barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
		/// barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT; m_commandList-&gt;ResourceBarrier(_countof(barriers),
		/// barriers); ThrowIfFailed(m_commandList-&gt;Close()); } }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-executeindirect void
		// ExecuteIndirect( [in] ID3D12CommandSignature *pCommandSignature, [in] UINT MaxCommandCount, [in] ID3D12Resource *pArgumentBuffer,
		// [in] UINT64 ArgumentBufferOffset, [in, optional] ID3D12Resource *pCountBuffer, [in] UINT64 CountBufferOffset );
		[PreserveSig]
		new void ExecuteIndirect([In] ID3D12CommandSignature pCommandSignature, uint MaxCommandCount, [In] ID3D12Resource pArgumentBuffer,
			ulong ArgumentBufferOffset, [In, Optional] ID3D12Resource? pCountBuffer, ulong CountBufferOffset);

		/// <summary>
		/// <para>Atomically copies a primary data element of type UINT from one resource to another, along with optional dependent resources.</para>
		/// <para>
		/// These 'dependent resources' are so-named because they depend upon the primary data element to locate them, typically the key
		/// element is an address, index, or other handle that refers to one or more the dependent resources indirectly.
		/// </para>
		/// <para>
		/// This function supports a primary data element of type UINT (32bit). A different version of this function,
		/// <c>AtomicCopyBufferUINT64</c>, supports a primary data element of type UINT64 (64bit).
		/// </para>
		/// </summary>
		/// <param name="pDstBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>The resource that the UINT primary data element is copied into.</para>
		/// </param>
		/// <param name="DstOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the destination resource buffer that specifies where the primary data element is copied into, in bytes. This
		/// offset combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT values.
		/// </para>
		/// </param>
		/// <param name="pSrcBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The resource that the UINT primary data element is copied from. This data is typically an address, index, or other handle that
		/// shader code can use to locate the most-recent version of latency-sensitive information.
		/// </para>
		/// </param>
		/// <param name="SrcOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the source resource buffer that specifies where the primary data element is copied from, in bytes. This offset
		/// combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT values.
		/// </para>
		/// </param>
		/// <param name="Dependencies">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of dependent resources.</para>
		/// </param>
		/// <param name="ppDependentResources">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>An array of resources that contain the dependent elements of the data payload.</para>
		/// </param>
		/// <param name="pDependentSubresourceRanges">
		/// <para>Type: <b>const <c>D3D12_SUBRESOURCE_RANGE_UINT64</c>*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>
		/// An array of subresource ranges that specify the dependent elements of the data payload. These elements are completely updated
		/// before the primary data element is itself atomically copied. This ensures that the entire operation is logically atomic; that
		/// is, the primary data element never refers to an incomplete data payload.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// This method is typically used to update resources for which normal rendering pipeline latency can be detrimental to user
		/// experience. For example, an application can compute a view matrix from the latest user input (such as from the sensors of a
		/// head-mounted display), and use this function to update and activate this matrix in command lists already dispatched to the GPU
		/// to reduce perceived latency between input and rendering.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint void
		// AtomicCopyBufferUINT( [in] ID3D12Resource *pDstBuffer, UINT64 DstOffset, [in] ID3D12Resource *pSrcBuffer, UINT64 SrcOffset, UINT
		// Dependencies, [in] ID3D12Resource * const *ppDependentResources, [in] const D3D12_SUBRESOURCE_RANGE_UINT64
		// *pDependentSubresourceRanges );
		[PreserveSig]
		new void AtomicCopyBufferUINT([In] ID3D12Resource pDstBuffer, ulong DstOffset, [In] ID3D12Resource pSrcBuffer, ulong SrcOffset, int Dependencies,
			[In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 4)] ID3D12Resource[] ppDependentResources,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] D3D12_SUBRESOURCE_RANGE_UINT64[] pDependentSubresourceRanges);

		/// <summary>
		/// <para>Atomically copies a primary data element of type UINT64 from one resource to another, along with optional dependent resources.</para>
		/// <para>
		/// These 'dependent resources' are so-named because they depend upon the primary data element to locate them, typically the key
		/// element is an address, index, or other handle that refers to one or more the dependent resources indirectly.
		/// </para>
		/// <para>
		/// This function supports a primary data element of type UINT64 (64bit). A different version of this function,
		/// <c>AtomicCopyBufferUINT</c>, supports a primary data element of type UINT (32bit).
		/// </para>
		/// </summary>
		/// <param name="pDstBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>The resource that the UINT64 primary data element is copied into.</para>
		/// </param>
		/// <param name="DstOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the destination resource buffer that specifies where the primary data element is copied into, in bytes. This
		/// offset combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT64 values.
		/// </para>
		/// </param>
		/// <param name="pSrcBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The resource that the UINT64 primary data element is copied from. This data is typically an address, index, or other handle that
		/// shader code can use to locate the most-recent version of latency-sensitive information.
		/// </para>
		/// </param>
		/// <param name="SrcOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the source resource buffer that specifies where the primary data element is copied from, in bytes. This offset
		/// combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT64 values.
		/// </para>
		/// </param>
		/// <param name="Dependencies">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of dependent resources.</para>
		/// </param>
		/// <param name="ppDependentResources">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>An array of resources that contain the dependent elements of the data payload.</para>
		/// </param>
		/// <param name="pDependentSubresourceRanges">
		/// <para>Type: <b>const <c>D3D12_SUBRESOURCE_RANGE_UINT64</c>*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>
		/// An array of subresource ranges that specify the dependent elements of the data payload. These elements are completely updated
		/// before the primary data element is itself atomically copied. This ensures that the entire operation is logically atomic; that
		/// is, the primary data element never refers to an incomplete data payload.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// This method is typically used to update resources for which normal rendering pipeline latency can be detrimental to user
		/// experience. For example, an application can compute a view matrix from the latest user input (such as from the sensors of a
		/// head-mounted display), and use this function to update and activate this matrix in command lists already dispatched to the GPU
		/// to reduce perceived latency between input and rendering.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64 void
		// AtomicCopyBufferUINT64( [in] ID3D12Resource *pDstBuffer, UINT64 DstOffset, [in] ID3D12Resource *pSrcBuffer, UINT64 SrcOffset,
		// UINT Dependencies, [in] ID3D12Resource * const *ppDependentResources, [in] const D3D12_SUBRESOURCE_RANGE_UINT64
		// *pDependentSubresourceRanges );
		[PreserveSig]
		new void AtomicCopyBufferUINT64([In] ID3D12Resource pDstBuffer, ulong DstOffset, [In] ID3D12Resource pSrcBuffer, ulong SrcOffset, int Dependencies,
			[In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 4)] ID3D12Resource[] ppDependentResources,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] D3D12_SUBRESOURCE_RANGE_UINT64[] pDependentSubresourceRanges);

		/// <summary>This method enables you to change the depth bounds dynamically.</summary>
		/// <param name="Min">
		/// <para>Type: <b>FLOAT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Specifies the minimum depth bounds. The default value is 0. NaN values silently convert to 0.</para>
		/// </param>
		/// <param name="Max">
		/// <para>Type: <b>FLOAT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Specifies the maximum depth bounds. The default value is 1. NaN values silently convert to 0.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Depth-bounds testing allows pixels and samples to be discarded if the currently-stored depth value is outside the range
		/// specified by <i>Min</i> and <i>Max</i>, inclusive. If the currently-stored depth value of the pixel or sample is inside this
		/// range, then the depth-bounds test passes and it is rendered; otherwise, the depth-bounds test fails and the pixel or sample is
		/// discarded. Note that the depth-bounds test considers the currently-stored depth value, not the depth value generated by the
		/// executing pixel shader.
		/// </para>
		/// <para>
		/// To use depth-bounds testing, the application must use the new <c>CreatePipelineState</c> method to enable depth-bounds testing
		/// on the PSO and then can use this command list method to change the depth-bounds dynamically.
		/// </para>
		/// <para>
		/// OMSetDepthBounds is an optional feature. Use the <c>CheckFeatureSupport</c> method to determine whether or not this feature is
		/// supported by the user-mode driver. Support for this feature is reported through the <c>D3D12_FEATURE_D3D12_OPTIONS2</c> structure.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-omsetdepthbounds void
		// OMSetDepthBounds( [in] FLOAT Min, [in] FLOAT Max );
		[PreserveSig]
		new void OMSetDepthBounds(float Min, float Max);

		/// <summary>This method configures the sample positions used by subsequent draw, copy, resolve, and similar operations.</summary>
		/// <param name="NumSamplesPerPixel">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// Specifies the number of samples to take, per pixel. This value can be 1, 2, 4, 8, or 16, otherwise the SetSamplePosition call is
		/// dropped. The number of samples must match the sample count configured in the PSO at draw time, otherwise the behavior is undefined.
		/// </para>
		/// </param>
		/// <param name="NumPixels">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// Specifies the number of pixels that sample patterns are being specified for. This value can be either 1 or 4, otherwise the
		/// SetSamplePosition call is dropped. A value of 1 configures a single sample pattern to be used for each pixel; a value of 4
		/// configures separate sample patterns for each pixel in a 2x2 pixel grid which is repeated over the render-target or viewport
		/// space, aligned to even coordinates.
		/// </para>
		/// <para>
		/// Note that the maximum number of combined samples can't exceed 16, otherwise the call is dropped. If NumPixels is set to 4,
		/// NumSamplesPerPixel can specify no more than 4 samples.
		/// </para>
		/// </param>
		/// <param name="pSamplePositions">
		/// <para>Type: <b><c>D3D12_SAMPLE_POSITION</c>*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(NumSamplesPerPixel*NumPixels)</c></para>
		/// <para>
		/// Specifies an array of D3D12_SAMPLE_POSITION elements. The size of the array is NumPixels * NumSamplesPerPixel. If NumPixels is
		/// set to 4, then the first group of sample positions corresponds to the upper-left pixel in the 2x2 grid of pixels; the next group
		/// of sample positions corresponds to the upper-right pixel, the next group to the lower-left pixel, and the final group to the
		/// lower-right pixel.
		/// </para>
		/// <para>
		/// If centroid interpolation is used during rendering, the order of positions for each pixel determines centroid-sampling priority.
		/// That is, the first covered sample in the order specified is chosen as the centroid sample location.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The operational semantics of sample positions are determined by the various draw, copy, resolve, and other operations that can occur.
		/// </para>
		/// <para>
		/// <b>CommandList:</b> In the absence of any prior calls to SetSamplePositions in a CommandList, samples assume the default
		/// position based on the Pipeline State Object (PSO). The default positions are determined either by the SAMPLE_DESC portion of the
		/// PSO if it is present, or by the standard sample positions if the RASTERIZER_DESC portion of the PSO has ForcedSampleCount set to
		/// a value greater than 0.
		/// </para>
		/// <para>
		/// After SetSamplePosition has been called, subsequent draw calls must use a PSO that specifies a matching sample count either
		/// using the SAMPLE_DESC portion of the PSO, or ForcedSampleCount in the RASTERIZER_DESC portion of the PSO.
		/// </para>
		/// <para>
		/// SetSamplePositions can only be called on a graphics CommandList. It can't be called in a bundle; bundles inherit sample position
		/// state from the calling CommandList and don't modify it.
		/// </para>
		/// <para>Calling SetSamplePositions(0, 0, NULL) reverts the sample positions to their default values.</para>
		/// <para><b>Clear RenderTarget:</b> Sample positions are ignored when clearing a render target.</para>
		/// <para>
		/// <b>Clear DepthStencil:</b> When clearing the depth portion of a depth-stencil surface or any region of it, the sample positions
		/// must be set to match those of future rendering to the cleared surface or region; the contents of any uncleared regions produced
		/// using different sample positions become undefined.
		/// </para>
		/// <para>When clearing the stencil portion of a depth-stencil surface or any region of it, the sample positions are ignored.</para>
		/// <para>
		/// <b>Draw to RenderTarget:</b> When drawing to a render target the sample positions can be changed for each draw call, even when
		/// drawing to a region that overlaps previous draw calls. The current sample positions determine the operational semantics of each
		/// draw call and samples are taken from taken from the stored contents of the render target, even if the contents were produced
		/// using different sample positions.
		/// </para>
		/// <para>
		/// <b>Draw using DepthStencil:</b> When drawing to a depth-stencil surface (read or write) or any region of it, the sample
		/// positions must be set to match those used to clear the affected region previously. To use a different sample position, the
		/// target region must be cleared first. The pixels outside the clear region are unaffected.
		/// </para>
		/// <para>
		/// Hardware may store the depth portion or a depth-stencil surface as plane equations, and evaluate them to produce depth values
		/// when the application issues a read. Only the rasterizer and output-merger are required to support programmable sample positions
		/// of the depth portion of a depth-stencil surface. Any other read or write of the depth portion that has been rendered with sample
		/// positions set may ignore them and instead sample at the standard positions.
		/// </para>
		/// <para>
		/// <b>Resolve RenderTarget:</b> When resolving a render target or any region of it, the sample positions are ignored; these APIs
		/// operate only on stored color values.
		/// </para>
		/// <para>
		/// <b>Resolve DepthStencil:</b> When resolving the depth portion of a depth-stencil surface or any region of it, the sample
		/// positions must be set to match those of past rendering to the resolved surface or region. To use a different sample position,
		/// the target region must be cleared first.
		/// </para>
		/// <para>
		/// When resolving the stencil portion of a depth-stencil surface or any region of it, the sample positions are ignored; stencil
		/// resolves operate only on stored stencil values.
		/// </para>
		/// <para>
		/// <b>Copy RenderTarget:</b> When copying from a render target, the sample positions are ignored regardless of whether it is a full
		/// or partial copy.
		/// </para>
		/// <para>
		/// <b>Copy DepthStencil (Full Subresource):</b> When copying a full subresource from a depth-stencil surface, the sample positions
		/// must be set to match the sample positions used to generate the source surface. To use a different sample position, the target
		/// region must be cleared first.
		/// </para>
		/// <para>
		/// On some hardware properties of the source surface (such as stored plane equations for depth values) transfer to the destination.
		/// Therefore, if the destination surface is subsequently drawn to, the sample positions originally used to generate the source
		/// content need to be used with the destination surface. The API requires this on all hardware for consistency even if it may only
		/// apply to some.
		/// </para>
		/// <para>
		/// <b>Copy DepthStencil (Partial Subresource):</b> When copying a partial subresource from a depth-stencil surface, the sample
		/// positions must be set to match the sample positions used to generate the source surface, similarly to copying a full
		/// subresource. However, if the content of an affected destination subresources is only partially covered by the copy, the contents
		/// of the uncovered portion within those subresources becomes undefined unless all of it was generated using the same sample
		/// positions as the copy source. To use a different sample position, the target region must be cleared first.
		/// </para>
		/// <para>
		/// When copying a partial subresource from the stencil portion of a depth-stencil surface, the sample postions are ignored. It
		/// doesnt matter what sample positions were used to generate content for any other areas of the destination buffer not covered by
		/// the copy  those contents remain valid.
		/// </para>
		/// <para>
		/// <b>Shader SamplePos:</b> The HLSL SamplePos intrinsic is not aware of programmable sample positions and results returned to
		/// shaders calling this on a surface rendered with programmable positions is undefined. Applications must pass coordinates into
		/// their shader manually if needed. Similarly evaluating attributes by sample index is undefined with programmable sample positions.
		/// </para>
		/// <para>
		/// <b>Transitioning out of DEPTH_READ or DEPTH_WRITE state:</b> If a subresource in DEPTH_READ or DEPTH_WRITE state is transitioned
		/// to any other state, including COPY_SOURCE or RESOLVE_SOURCE, some hardware might need to decompress the surface. Therefore, the
		/// sample positions must be set on the command list to match those used to generate the content in the source surface. Furthermore,
		/// for any subsequent transitions of the surface while the same depth data remains in it, the sample positions must continue to
		/// match those set on the command list. To use a different sample position, the target region must be cleared first.
		/// </para>
		/// <para>
		/// If an application wants to minimize the decompressed area when only a portion needs to be used, or just to preserve compression,
		/// ResolveSubresourceRegion() can be called in DECOMPRESS mode with a rect specified. This will decompress just the relevant area
		/// to a separate resource leaving the source intact on some hardware, though on other hardware even the source area is
		/// decompressed. The separate explicitly decompressed resource can then be transitioned to the desired state (such as SHADER_RESOURCE).
		/// </para>
		/// <para>
		/// <b>Transitioning out of RENDER_TARGET state:</b> If a subresource in RENDER_TARGET state is transitioned to anything other than
		/// COPY_SOURCE or RESOLVE_SOURCE, some implementations may need to decompress the surface. This decompression is agnostic to sample positions.
		/// </para>
		/// <para>
		/// If an application wants to minimize the decompressed area when only a portion needs to be used, or just to preserve compression,
		/// ResolveSubresourceRegion() can be called in DECOMPRESS mode with a rect specified. This will decompress just the relevant area
		/// to a separate resource leaving the source intact on some hardware, though on other hardware even the source area is
		/// decompressed. The separate explicitly decompressed resource can then be transitioned to the desired state (such as SHADER_RESOURCE).
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-setsamplepositions void
		// SetSamplePositions( [in] UINT NumSamplesPerPixel, [in] UINT NumPixels, [in] D3D12_SAMPLE_POSITION *pSamplePositions );
		[PreserveSig]
		new void SetSamplePositions(uint NumSamplesPerPixel, uint NumPixels,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_SAMPLE_POSITION[] pSamplePositions);

		/// <summary>Copy a region of a multisampled or compressed resource into a non-multisampled or non-compressed resource.</summary>
		/// <param name="pDstResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// Destination resource. Must be created with the <b>D3D11_USAGE_DEFAULT</b> flag and must be single-sampled unless its to be
		/// resolved from a compressed resource ( <b>D3D12_RESOLVE_MODE_DECOMPRESS</b>); in this case it must have the same sample count as
		/// the compressed source.
		/// </para>
		/// </param>
		/// <param name="DstSubresource">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// A zero-based index that identifies the destination subresource. Use <c>D3D12CalcSubresource</c> to calculate the subresource
		/// index if the parent resource is complex.
		/// </para>
		/// </param>
		/// <param name="DstX">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The X coordinate of the left-most edge of the destination region. The width of the destination region is the same as the width
		/// of the source rect.
		/// </para>
		/// </param>
		/// <param name="DstY">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The Y coordinate of the top-most edge of the destination region. The height of the destination region is the same as the height
		/// of the source rect.
		/// </para>
		/// </param>
		/// <param name="pSrcResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Source resource. Must be multisampled or compressed.</para>
		/// </param>
		/// <param name="SrcSubresource">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>A zero-based index that identifies the source subresource.</para>
		/// </param>
		/// <param name="pSrcRect">
		/// <para>Type: <b>D3D12_RECT*</b></para>
		/// <para><c>SAL</c>: <c>In_opt</c></para>
		/// <para>
		/// Specifies the rectangular region of the source resource to be resolved. Passing NULL for <i>pSrcRect</i> specifies that the
		/// entire subresource is to be resolved.
		/// </para>
		/// </param>
		/// <param name="Format">
		/// <para>Type: <b>DXGI_FORMAT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>A DXGI_FORMAT that specifies how the source and destination resource formats are consolidated.</para>
		/// </param>
		/// <param name="ResolveMode">
		/// <para>Type: <b><c>D3D12_RESOLVE_MODE</c></b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Specifies the operation used to resolve the source samples.</para>
		/// <para>
		/// When using the <b>D3D12_RESOLVE_MODE_DECOMPRESS</b> operation, the sample count can be larger than 1 as long as the source and
		/// destination have the same sample count, and source and destination may specify the same resource as long as the source rect
		/// aligns with the destination X and Y coordinates, in which case decompression occurs in place.
		/// </para>
		/// <para>
		/// When using the <b>D3D12_RESOLVE_MODE_MIN</b>, <b>D3D12_RESOLVE_MODE_MAX</b>, or <b>D3D12_RESOLVE_MODE_AVERAGE</b> operation, the
		/// destination must have a sample count of 1.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// ResolveSubresourceRegion operates like <c>ResolveSubresource</c> but allows for only part of a resource to be resolved and for
		/// source samples to be resolved in several ways. Partial resolves can be useful in multi-adapter scenarios; for example, when the
		/// rendered area has been partitioned across adapters, each adapter might only need to resolve the portion of a subresource that
		/// corresponds to its assigned partition.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion void
		// ResolveSubresourceRegion( [in] ID3D12Resource *pDstResource, [in] UINT DstSubresource, [in] UINT DstX, [in] UINT DstY, [in]
		// ID3D12Resource *pSrcResource, [in] UINT SrcSubresource, [in, optional] D3D12_RECT *pSrcRect, [in] DXGI_FORMAT Format, [in]
		// D3D12_RESOLVE_MODE ResolveMode );
		[PreserveSig]
		new void ResolveSubresourceRegion([In] ID3D12Resource pDstResource, uint DstSubresource, uint DstX, uint DstY, [In] ID3D12Resource pSrcResource,
			uint SrcSubresource, [In, Optional] PRECT? pSrcRect, DXGI_FORMAT Format, D3D12_RESOLVE_MODE ResolveMode);

		/// <summary>Set a mask that controls which view instances are enabled for subsequent draws.</summary>
		/// <param name="Mask">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// A mask that specifies which views are enabled or disabled. If bit <i>i</i> starting from the least-significant bit is set, view
		/// instance <i>i</i> is enabled.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The view instance mask only affects PSOs that declare view instance masking by specifying the
		/// D3D12_VIEW_INSTANCING_FLAG_ENABLE_VIEW_INSTANCE_MASKING flag during their creation. Attempting to create a PSO that declares
		/// view instance masking will fail on adapters that don't support view instancing.
		/// </para>
		/// <para>
		/// The view instance mask defaults to 0 which disables all views. This forces applications that declare view instance masking to
		/// explicitly choose the views to enable, otherwise nothing will be rendered. If the view instance mask enabled all views by
		/// default the application might not remember to disable unused views, resulting in lost performance due to wasted work.
		/// </para>
		/// <para>
		/// Bundles don't inherit their view instance mask from their caller, defaulting to 0 instead. This is because the mask setting must
		/// be known when the bundle is recorded if it affects how an implementation records draws. The view instance mask set by a bundle
		/// does persist to the caller after the bundle completes, however. These inheritance semantics are similar to those of PSOs.
		/// </para>
		/// <para>
		/// No shader code paths that are dependent on SV_ViewID are executed at any shader stage for view instances that are masked off and
		/// no clipping, viewport processing, or rasterization is performed. Implementations that inspect the mask during rendering can
		/// incur a small performance penalty over PSOs that don't declare view instance masking at all, but usually the penalty can be
		/// overcome by the performance savings that result from skipping the work associated with the masked off views. Depending on the
		/// frequency and amount of skipped work, the performance gains can be significant.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-setviewinstancemask void
		// SetViewInstanceMask( [in] UINT Mask );
		[PreserveSig]
		new void SetViewInstanceMask(uint Mask);

		/// <summary>Writes a number of 32-bit immediate values to the specified buffer locations directly from the command stream.</summary>
		/// <param name="Count">
		/// The number of <c>D3D12_WRITEBUFFERIMMEDIATE_PARAMETER</c> structures that are pointed to by <i>pParams</i> and <i>pModes</i>.
		/// </param>
		/// <param name="pParams">
		/// The address of an array containing a number of <c>D3D12_WRITEBUFFERIMMEDIATE_PARAMETER</c> structures equal to <i>Count</i>.
		/// </param>
		/// <param name="pModes">
		/// The address of an array containing a number of <c>D3D12_WRITEBUFFERIMMEDIATE_MODE</c> structures equal to <i>Count</i>. The
		/// default value is <b>null</b>; passing <b>null</b> causes the system to write all immediate values using <b>D3D12_WRITEBUFFERIMMEDIATE_MODE_DEFAULT</b>.
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>WriteBufferImmediate</b> performs <i>Count</i> number of 32-bit writes: one for each value and destination specified in <i>pParams</i>.
		/// </para>
		/// <para>
		/// The receiving buffer (resource) must be in the <b>D3D12_RESOURCE_STATE_COPY_DEST</b> state to be a valid destination for <b>WriteBufferImmediate</b>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist2-writebufferimmediate void
		// WriteBufferImmediate( UINT Count, [in] const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER *pParams, [in, optional] const
		// D3D12_WRITEBUFFERIMMEDIATE_MODE *pModes );
		[PreserveSig]
		new void WriteBufferImmediate(int Count, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_WRITEBUFFERIMMEDIATE_PARAMETER[] pParams,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_WRITEBUFFERIMMEDIATE_MODE[] pModes);

		/// <summary>
		/// Specifies whether or not protected resources can be accessed by subsequent commands in the command list. By default, no
		/// protected resources are enabled. After calling <b>SetProtectedResourceSession</b> with a valid session, protected resources of
		/// the same type can refer to that session. After calling <b>SetProtectedResourceSession</b> with <b>NULL</b>, no protected
		/// resources can be accessed.
		/// </summary>
		/// <param name="pProtectedResourceSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an <b>ID3D12ProtectedResourceSession</b>. You can obtain an <b>ID3D12ProtectedResourceSession</b> by
		/// calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <returns>
		/// If set, indicates that protected resources can be accessed with the given session. Access to protected resources can only happen
		/// after <b>SetProtectedResourceSession</b> is called with a valid session. The command list state is cleared when calling this
		/// method. If you pass <b>NULL</b>, then no protected resources can be accessed.
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist3-setprotectedresourcesession void
		// SetProtectedResourceSession( [in, optional] ID3D12ProtectedResourceSession *pProtectedResourceSession );
		[PreserveSig]
		new void SetProtectedResourceSession([In, Optional] ID3D12ProtectedResourceSession? pProtectedResourceSession);

		/// <summary>
		/// Marks the beginning of a render pass by binding a set of output resources for the duration of the render pass. These bindings
		/// are to one or more render target views (RTVs), and/or to a depth stencil view (DSV).
		/// </summary>
		/// <param name="NumRenderTargets">A <b>UINT</b>. The number of render targets being bound.</param>
		/// <param name="pRenderTargets">
		/// A pointer to a constant <c>D3D12_RENDER_PASS_RENDER_TARGET_DESC</c>, which describes bindings (fixed for the duration of the
		/// render pass) to one or more render target views (RTVs), as well as their beginning and ending access characteristics.
		/// </param>
		/// <param name="pDepthStencil">
		/// A pointer to a constant <c>D3D12_RENDER_PASS_DEPTH_STENCIL_DESC</c>, which describes a binding (fixed for the duration of the
		/// render pass) to a depth stencil view (DSV), as well as its beginning and ending access characteristics.
		/// </param>
		/// <param name="Flags">
		/// A <c>D3D12_RENDER_PASS_FLAGS</c>. The nature/requirements of the render pass; for example, whether it is a suspending or a
		/// resuming render pass, or whether it wants to write to unordered access view(s).
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass void
		// BeginRenderPass( UINT NumRenderTargets, const D3D12_RENDER_PASS_RENDER_TARGET_DESC *pRenderTargets, const
		// D3D12_RENDER_PASS_DEPTH_STENCIL_DESC *pDepthStencil, D3D12_RENDER_PASS_FLAGS Flags );
		[PreserveSig]
		new void BeginRenderPass(int NumRenderTargets, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_RENDER_PASS_RENDER_TARGET_DESC[]? pRenderTargets,
			[In, Optional] ManagedStructPointer<D3D12_RENDER_PASS_DEPTH_STENCIL_DESC> pDepthStencil, D3D12_RENDER_PASS_FLAGS Flags);

		/// <summary>Marks the ending of a render pass.</summary>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-endrenderpass void EndRenderPass();
		[PreserveSig]
		new void EndRenderPass();

		/// <summary>
		/// <para>Initializes the specified meta command.</para>
		/// <para>
		/// You must initialize a meta command at least once prior (on the GPU's timeline) to executing it. Initializing gives the
		/// implementation the chance to perform any work necessary to accelerate the invocation of the meta command. You must supply the
		/// sufficient resource parameters, including the persistent cache resource.
		/// </para>
		/// </summary>
		/// <param name="pMetaCommand">A pointer to an <c>ID3D12MetaCommand</c> representing the meta command to initialize.</param>
		/// <param name="pInitializationParametersData">
		/// An optional pointer to a constant structure containing the values of the parameters for initializing the meta command.
		/// </param>
		/// <param name="InitializationParametersDataSizeInBytes">
		/// A <c>SIZE_T</c> containing the size of the structure pointed to by <i>pInitializationParametersData</i>, if set, otherwise 0.
		/// </param>
		/// <returns>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-initializemetacommand void
		// InitializeMetaCommand( [in] ID3D12MetaCommand *pMetaCommand, [in, optional] const void *pInitializationParametersData, [in]
		// SIZE_T InitializationParametersDataSizeInBytes );
		[PreserveSig]
		new void InitializeMetaCommand([In] ID3D12MetaCommand pMetaCommand, [In, Optional] IntPtr pInitializationParametersData,
			[In] SizeT InitializationParametersDataSizeInBytes);

		/// <summary>
		/// <para>Records the execution (or invocation) of the specified meta command into a graphics command list.</para>
		/// <para>
		/// Call <c>ID3D12GraphicsCommandList4::InitializeMetaCommand</c> before executing a meta command. During invocation, you can
		/// specify overrides for values of any of the runtime parameters. You can execute multiple meta commands on the same graphics
		/// command list. And you can execute the same meta command multiple times on the same command list.
		/// </para>
		/// <para>
		/// With a PIX capture taken with the use of meta commands, you can play that back on the same hardware configuration. But, by
		/// design, it's not portable to other GPUs.
		/// </para>
		/// </summary>
		/// <param name="pMetaCommand">A pointer to an <b>ID3D12MetaCommand</b> representing the meta command to initialize.</param>
		/// <param name="pExecutionParametersData">
		/// An optional pointer to a constant structure containing the values of the parameters for executing the meta command.
		/// </param>
		/// <param name="ExecutionParametersDataSizeInBytes">
		/// A <c>SIZE_T</c> containing the size of the structure pointed to by <i>pExecutionParametersData</i>, if set, otherwise 0.
		/// </param>
		/// <returns>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</returns>
		/// <remarks>
		/// <para>
		/// Your application is responsible for setting up the resources supplied to a meta command in the state required according to the
		/// meta command specification. The meta command definition specification defines the expected resource state for each parameter.
		/// Your application is responsible for inserting unordered access view (UAV) barriers for input resources before the meta command's
		/// algorithm can consume them. You're also responsible for inserting the UAV barrier for the output resources when you intend to
		/// read them back.
		/// </para>
		/// <para>
		/// During an algorithm invocation, the driver may insert as many UAV barriers to output resources as are needed to synchronize the
		/// output resource usage in the algorithm implementation. From your application's point of view, you should assume that all out and
		/// in/out resources are written to by the meta command, including scratch memory.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-executemetacommand void
		// ExecuteMetaCommand( [in] ID3D12MetaCommand *pMetaCommand, [in, optional] const void *pExecutionParametersData, [in] SIZE_T
		// ExecutionParametersDataSizeInBytes );
		[PreserveSig]
		new void ExecuteMetaCommand([In] ID3D12MetaCommand pMetaCommand, [In, Optional] IntPtr pExecutionParametersData, [In] SizeT ExecutionParametersDataSizeInBytes);

		/// <summary>
		/// Performs a raytracing acceleration structure build on the GPU and optionally outputs post-build information immediately after
		/// the build.
		/// </summary>
		/// <param name="pDesc">Description of the acceleration structure to build.</param>
		/// <param name="NumPostbuildInfoDescs">Size of the <i>pPostbuildInfoDescs</i> array. Set to 0 if no post-build info is needed.</param>
		/// <param name="pPostbuildInfoDescs">
		/// Optional array of descriptions for post-build info to generate describing properties of the acceleration structure that was built.
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This method can be called on graphics or compute command lists but not from bundles.</para>
		/// <para>
		/// Post-build information can also be obtained separately from an already built acceleration structure by calling
		/// <c>EmitRaytracingAccelerationStructurePostbuildInfo</c>. The advantage of generating post-build info along with a build is that
		/// a barrier isnt needed in between the build completing and requesting post-build information, enabling scenarios where the app
		/// needs the post-build info right away.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-buildraytracingaccelerationstructure
		// void BuildRaytracingAccelerationStructure( [in] const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC *pDesc, [in] UINT
		// NumPostbuildInfoDescs, [in] const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pPostbuildInfoDescs );
		[PreserveSig]
		new void BuildRaytracingAccelerationStructure(in D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC pDesc, int NumPostbuildInfoDescs,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC[]? pPostbuildInfoDescs);

		/// <summary>
		/// Emits post-build properties for a set of acceleration structures. This enables applications to know the output resource
		/// requirements for performing acceleration structure operations via <c>ID3D12GraphicsCommandList4::CopyRaytracingAccelerationStructure</c>.
		/// </summary>
		/// <param name="pDesc">
		/// A <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC</c> object describing post-build information to generate.
		/// </param>
		/// <param name="NumSourceAccelerationStructures">
		/// Number of pointers to acceleration structure GPU virtual addresses pointed to by <i>pSourceAccelerationStructureData</i>. This
		/// number also affects the destination (output), which will be a contiguous array of <b>NumSourceAccelerationStructures</b> output
		/// structures, where the type of the structures depends on <i>InfoType</i> field of the supplied in the <i>pDesc</i> description.
		/// </param>
		/// <param name="pSourceAccelerationStructureData">
		/// <para>Pointer to array of GPU virtual addresses of size <i>NumSourceAccelerationStructures</i>.</para>
		/// <para>The address must be aligned to 256 bytes, defined as <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT</c>.</para>
		/// <para>The memory pointed to must be in state <c>D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE</c>.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>This method can be called from graphics or compute command lists but not from bundles.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-emitraytracingaccelerationstructurepostbuildinfo
		// void EmitRaytracingAccelerationStructurePostbuildInfo( [in] const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC
		// *pDesc, [in] UINT NumSourceAccelerationStructures, [in] const D3D12_GPU_VIRTUAL_ADDRESS *pSourceAccelerationStructureData );
		[PreserveSig]
		new void EmitRaytracingAccelerationStructurePostbuildInfo(in D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC pDesc,
			int NumSourceAccelerationStructures, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_GPU_VIRTUAL_ADDRESS[] pSourceAccelerationStructureData);

		/// <summary>Copies a source acceleration structure to destination memory while applying the specified transformation.</summary>
		/// <param name="DestAccelerationStructureData">
		/// <para>
		/// The destination memory. The required size can be discovered by calling <c>EmitRaytracingAccelerationStructurePostbuildInfo</c>
		/// beforehand, if necessary for the specified <i>Mode</i>.
		/// </para>
		/// <para>
		/// The destination start address must be aligned to 256 bytes, defined as
		/// <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT</c>, regardless of the specified <i>Mode</i>.
		/// </para>
		/// <para>The destination memory range cannot overlap source. Otherwise, results are undefined.</para>
		/// <para>
		/// The resource state that the memory pointed to must be in depends on the <i>Mode</i> parameter. For more information, see <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE</c>.
		/// </para>
		/// </param>
		/// <param name="SourceAccelerationStructureData">
		/// <para>
		/// The address of the acceleration structure or other type of data to copy/transform based on the specified <i>Mode</i>. The data
		/// remains unchanged and usable. The operation only copies the data pointed to by <i>SourceAccelerationStructureData</i> and not
		/// any other data, such as acceleration structures, that the source data may point to. For example, in the case of a top-level
		/// acceleration structure, any bottom-level acceleration structures that it points to are not copied in the operation.
		/// </para>
		/// <para>
		/// The source memory must be aligned to 256 bytes, defined as <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT</c>,
		/// regardless of the specified <i>Mode</i>.
		/// </para>
		/// <para>
		/// The resource state that the memory pointed to must be in depends on the <i>Mode</i> parameter. For more information, see <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE</c>.
		/// </para>
		/// </param>
		/// <param name="Mode">The type of copy operation to perform. For more information, see <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE</c>.</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Since raytracing acceleration structures may contain internal pointers and have a device dependent opaque layout, copying them
		/// around or otherwise manipulating them requires a dedicated API so that drivers can handle the requested operation.
		/// </para>
		/// <para>This method can be called from graphics or compute command lists but not from bundles.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-copyraytracingaccelerationstructure
		// void CopyRaytracingAccelerationStructure( [in] D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData, [in]
		// D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData, [in] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode );
		[PreserveSig]
		new void CopyRaytracingAccelerationStructure(D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData, D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData,
			D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode);

		/// <summary>Sets a state object on the command list.</summary>
		/// <param name="pStateObject">The state object to set on the command list. In the current release, this can only be of type <c>D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE</c>.</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This method can be called from graphics or compute command lists and bundles.</para>
		/// <para>
		/// This method is an alternative to <c>ID3D12GraphicsCommandList::SetPipelineState</c>, which is only defined for graphics and
		/// compute shaders. There is only one pipeline state active on a command list at a time, so either call sets the current pipeline
		/// state. The distinction between the calls is that each sets particular types of pipeline state only. In the current release,
		/// <b>SetPipelineState1</b> is only used for setting raytracing pipeline state.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-setpipelinestate1 void
		// SetPipelineState1( ID3D12StateObject *pStateObject );
		[PreserveSig]
		new void SetPipelineState1([In] ID3D12StateObject pStateObject);

		/// <summary>Launch the threads of a ray generation shader.</summary>
		/// <param name="pDesc">A description of the ray dispatch</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This method can be called from graphics or compute command lists and bundles.</para>
		/// <para>A raytracing pipeline state must be set on the command list. Otherwise, the behavior of this call is undefined.</para>
		/// <para>
		/// There are 3 dimensions passed in to set the grid size: width/height/depth. These dimensions are constrained such that width *
		/// height * depth &lt;= 2^30. Exceeding this produces undefined behavior. If any grid dimension is 0, no threads are launched.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-dispatchrays void DispatchRays(
		// [in] const D3D12_DISPATCH_RAYS_DESC *pDesc );
		[PreserveSig]
		new void DispatchRays(in D3D12_DISPATCH_RAYS_DESC pDesc);

		/// <summary>
		/// Sets the base shading rate, and combiners, for variable-rate shading (VRS). For more info, see <c>Variable-rate shading (VRS)</c>.
		/// </summary>
		/// <param name="baseShadingRate">
		/// <para>Type: <c><b>D3D12_SHADING_RATE</b></c></para>
		/// <para>A constant from the <c>D3D12_SHADING_RATE</c> enumeration describing the base shading rate to set.</para>
		/// </param>
		/// <param name="combiners">
		/// <para>Type: <b>const <c>D3D12_SHADING_RATE_COMBINER</c>*</b></para>
		/// <para>
		/// An optional pointer to a constant array of <c><b>D3D12_SHADING_RATE_COMBINER</b></c> containing the shading rate combiners to
		/// set. The count of <c><b>D3D12_SHADING_RATE_COMBINER</b></c> elements in the array must be equal to the constant
		/// <c><b>D3D12_RS_SET_SHADING_RATE_COMBINER_COUNT</b></c>, which is equal to <b>2</b>.
		/// </para>
		/// <para>
		/// Because per-primitive and screen-space image-based VRS isn't supported on Tier1 <c>Variable-rate shading (VRS)</c>, for these
		/// values to be meaningful, the adapter requires Tier2 VRS support. See <c><b>D3D12_FEATURE_DATA_D3D12_OPTIONS6</b></c> and <c><b>D3D12_VARIABLE_SHADING_RATE_TIER</b></c>.
		/// </para>
		/// <para>A <b>NULL</b> pointer is equivalent to the default shading combiners, which are both <c><b>D3D12_SHADING_RATE_COMBINER_PASSTHROUGH</b></c>.</para>
		/// <para>The algorithm for final shading-rate is determined by the following.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist5-rssetshadingrate void
		// RSSetShadingRate( D3D12_SHADING_RATE baseShadingRate, const D3D12_SHADING_RATE_COMBINER *combiners );
		[PreserveSig]
		new void RSSetShadingRate(D3D12_SHADING_RATE baseShadingRate, [In, Optional, MarshalAs(UnmanagedType.LPArray)] D3D12_SHADING_RATE_COMBINER[]? combiners);

		/// <summary>
		/// Sets the screen-space shading-rate image for variable-rate shading (VRS). For more info, see <c>Variable-rate shading (VRS)</c>.
		/// This method requires Tier2 <c>Variable-rate shading (VRS)</c> support. See <c><b>D3D12_FEATURE_DATA_D3D12_OPTIONS6</b></c> and <c><b>D3D12_VARIABLE_SHADING_RATE_TIER</b></c>.
		/// </summary>
		/// <param name="shadingRateImage">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>
		/// An optional pointer to an <c>ID3D12Resource</c> representing a screen-space shading-rate image. If <b>NULL</b>, the effect is
		/// the same as having a shading-rate image where all values are a shading rate of 1x1.
		/// </para>
		/// <para>This texture must have the <c><b>D3D12_RESOURCE_STATE_SHADING_RATE_SOURCE</b></c> state applied.</para>
		/// <para>
		/// The tile-size of the shading-rate image can be determined via <c><b>D3D12_FEATURE_DATA_D3D12_OPTIONS6</b></c>. The size of the
		/// shading-rate image should therefore be
		/// </para>
		/// <para>
		/// The shading-rate image must be a 2D texture with a single mip, and format <c><b>DXGI_FORMAT_R8_UINT</b></c>. Each texel must be
		/// a value corresponding to <c><b>D3D12_SHADING_RATE</b></c>. It must have layout <c><b>D3D12_TEXTURE_LAYOUT_UNKNOWN</b></c> and
		/// can't be a depth-stencil, render-target, simultaneous-access, or cross-adapter resource.
		/// </para>
		/// <para>
		/// As (0, 0) is the top left in DirectX, a too-small or large shading-rate image results in the bottom or right having no
		/// shading-rate image area, or the image extending in these directions. When there is excess, it is ignored (but legal), and when
		/// the image is too small, all out-of-bounds areas in the bottom and right will have the default shading rate of 1x1 from the image
		/// (however, this does not mean that is the final shading rate. The combiners will still be applied to this 1x1 default value).
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// For the screen-space shading-rate image to take affect, <c><b>ID3D12GraphicsCommandList5::RSSetShadingRate</b></c> must have
		/// been called to set the combiners for shading. Else, with the default combiners (both
		/// <c><b>D3D12_SHADING_RATE_COMBINER_PASSTHROUGH</b></c>), the screen-space shading-rate image is ignored in determining shading granularity.
		/// </para>
		/// <para>
		/// The second combiner passed to [ <b>ID3D12GraphicsCommandList5::RSSetShadingRate</b>] is the one which applies to the
		/// shading-rate image, which occurs after the global shading rate and the per-primitive shading rate have been combined.
		/// </para>
		/// <para>The algorithm for final shading-rate is determined by</para>
		/// <para>
		/// <c>postRasterizerRate = ApplyCombiner(Combiners[0], CommandListShadingRate, Primitive-&gt;PrimitiveSpecifiedShadingRate);
		/// finalRate = ApplyCombiner(Combiners[1], postRasterizerRate, ScreenSpaceImage[xy]);</c>
		/// </para>
		/// <para>where <c>ApplyCombiner</c> is</para>
		/// <para>
		/// <c>UINT ApplyCombiner(D3D12_SHADING_RATE_COMBINER combiner, UINT a, UINT b) { MaxShadingRate =
		/// options6.AdditionalShadingRatesSupported ? 4 : 2; switch (combiner) { case D3D12_SHADING_RATE_COMBINER_PASSTHROUGH: // default
		/// return a; case D3D12_SHADING_RATE_COMBINER_OVERRIDE: return b; case D3D12_SHADING_RATE_COMBINER_MAX: return max(a, b); case
		/// D3D12_SHADING_RATE_COMBINER_MIN: return min(a, b); case D3D12_SHADING_RATE_COMBINER_SUM: return min(MaxShadingRate, a + b); case
		/// default: return a; } }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist5-rssetshadingrateimage void
		// RSSetShadingRateImage( ID3D12Resource *shadingRateImage );
		[PreserveSig]
		new void RSSetShadingRateImage([In, Optional] ID3D12Resource? shadingRateImage);

		/// <summary/>
		/// <param name="ThreadGroupCountX"/>
		/// <param name="ThreadGroupCountY"/>
		/// <param name="ThreadGroupCountZ"/>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist6-dispatchmesh void DispatchMesh(
		// UINT ThreadGroupCountX, UINT ThreadGroupCountY, UINT ThreadGroupCountZ );
		[PreserveSig]
		new void DispatchMesh(uint ThreadGroupCountX, uint ThreadGroupCountY, uint ThreadGroupCountZ);

		/// <summary>
		/// <para>Adds a collection of barriers into a graphics command list recording.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.608 or later.</para>
		/// </summary>
		/// <param name="NumBarrierGroups">Number of barrier groups pointed to by pBarrierGroups.</param>
		/// <param name="pBarrierGroups">Pointer to an array of <c>D3D12_BARRIER_GROUP</c> objects.</param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist7-barrier void Barrier( UINT32
		// NumBarrierGroups, const D3D12_BARRIER_GROUP *pBarrierGroups );
		[PreserveSig]
		new void Barrier(int NumBarrierGroups, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_BARRIER_GROUP[] pBarrierGroups);

		[PreserveSig]
		new void OMSetFrontAndBackStencilRef(uint FrontStencilRef, uint BackStencilRef);

		[PreserveSig]
		new void RSSetDepthBias(float DepthBias, float DepthBiasClamp, float SlopeScaledDepthBias);

		[PreserveSig]
		new void IASetIndexBufferStripCutValue(D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue);

		[PreserveSig]
		void SetProgram(in D3D12_SET_PROGRAM_DESC pDesc);

		[PreserveSig]
		void DispatchGraph(in D3D12_DISPATCH_GRAPH_DESC pDesc);
	}

	[ComImport]
	[Guid("ee936ef9-599d-4d28-938e-23c4ad05ce51")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ID3D12GraphicsCommandList8 : ID3D12GraphicsCommandList7, ID3D12GraphicsCommandList6, ID3D12GraphicsCommandList5, ID3D12GraphicsCommandList4, ID3D12GraphicsCommandList3, ID3D12GraphicsCommandList2, ID3D12GraphicsCommandList1, ID3D12GraphicsCommandList, ID3D12CommandList, ID3D12DeviceChild, ID3D12Object
	{
		/// <summary>Gets application-defined data from a device object.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> that is associated with the data.</para>
		/// </param>
		/// <param name="pDataSize">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a variable that on input contains the size, in bytes, of the buffer that <i>pData</i> points to, and on output
		/// contains the size, in bytes, of the amount of data that <b>GetPrivateData</b> retrieved.
		/// </para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a memory block that receives the data from the device object if <i>pDataSize</i> points to a value that specifies a
		/// buffer large enough to hold the data.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// If the data returned is a pointer to an <c>IUnknown</c>, or one of its derivative classes, which was previously set by
		/// SetPrivateDataInterface, that interface will have its reference count incremented before the private data is returned.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-getprivatedata HRESULT GetPrivateData( [in]
		// REFGUID guid, [in, out] UINT *pDataSize, [out, optional] void *pData );
		[PreserveSig]
		new HRESULT GetPrivateData(in Guid guid, ref uint pDataSize, [Out, Optional] IntPtr pData);

		/// <summary>Sets application-defined data to a device object and associates that data with an application-defined <b>GUID</b>.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the data.</para>
		/// </param>
		/// <param name="DataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size in bytes of the data.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>
		/// A pointer to a memory block that contains the data to be stored with this device object. If <i>pData</i> is <b>NULL</b>,
		/// <i>DataSize</i> must also be 0, and any data that was previously associated with the <b>GUID</b> specified in <i>guid</i> will
		/// be destroyed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// Rather than using the Direct3D 11 debug object naming scheme of calling <b>ID3D12Object::SetPrivateData</b> using
		/// <b>WKPDID_D3DDebugObjectName</b> with an ASCII name, call <c>ID3D12Object::SetName</c> with a UNICODE name.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedata HRESULT SetPrivateData( [in]
		// REFGUID guid, [in] UINT DataSize, [in, optional] const void *pData );
		[PreserveSig]
		new HRESULT SetPrivateData(in Guid guid, uint DataSize, [In, Optional] IntPtr pData);

		/// <summary>
		/// Associates an <c>IUnknown</c>-derived interface with the device object, and associates that interface with an
		/// application-defined <b>GUID</b>.
		/// </summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the interface.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const <c>IUnknown</c>*</b></para>
		/// <para>
		/// A pointer to the <c>IUnknown</c>-derived interface to be associated with the device object. Its reference count is incremented
		/// when set, and its reference count is decremented when either the <c>ID3D12Object</c> is destroyed, or when the data is
		/// overwritten by calling <c>SetPrivateData</c> or <b>SetPrivateDataInterface</b> with the same <b>GUID</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 return codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedatainterface HRESULT
		// SetPrivateDataInterface( [in] REFGUID guid, [in, optional] const IUnknown *pData );
		[PreserveSig]
		new HRESULT SetPrivateDataInterface(in Guid guid, [In, Optional, MarshalAs(UnmanagedType.Interface)] object? pData);

		/// <summary>Associates a name with the device object. This name is for use in debug diagnostics and tools.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the device object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>This method takes UNICODE names.</para>
		/// <para>
		/// Note that this is simply a convenience wrapper around <c>ID3D12Object::SetPrivateData</c> with
		/// <b>WKPDID_D3DDebugObjectNameW</b>. Therefore names which are set with <c>SetName</c> can be retrieved with
		/// <c>ID3D12Object::GetPrivateData</c> with the same GUID. Additionally, D3D12 supports narrow strings for names, using the
		/// <b>WKPDID_D3DDebugObjectName</b> GUID directly instead.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setname HRESULT SetName( [in] LPCWSTR Name );
		[PreserveSig]
		new HRESULT SetName([MarshalAs(UnmanagedType.LPWStr)] string Name);

		/// <summary>Gets a pointer to the device that created this interface.</summary>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier (<b>GUID</b>) for the device interface. The <b>REFIID</b>, or <b>GUID</b>, of the interface to
		/// the device can be obtained by using the __uuidof() macro. For example, __uuidof(<c>ID3D12Device</c>) will get the <b>GUID</b>
		/// of the interface to a device.
		/// </para>
		/// </param>
		/// <param name="ppvDevice">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12Device</c> interface for the device.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Any returned interfaces have their reference count incremented by one, so be sure to call ::release() on the returned pointers
		/// before they are freed or else you will have a memory leak.
		///  Examples The <c>D3D12Multithreading</c> sample uses <b>ID3D12DeviceChild::GetDevice</b> as follows:</para>
		/// <code language="cpp">
		///<![CDATA[// Returns required size of a buffer to be used for data upload
		///inline UINT64 GetRequiredIntermediateSize(
		///   _In_ ID3D12Resource* pDestinationResource,
		///   _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		///   _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources)
		///{
		///   D3D12_RESOURCE_DESC Desc = pDestinationResource->GetDesc();
		///   UINT64 RequiredSize = 0;
		///
		///   ID3D12Device* pDevice;
		///   pDestinationResource->GetDevice(__uuidof(*pDevice), reinterpret_cast<void**>(&pDevice));
		///   pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, 0, nullptr, nullptr, nullptr, &RequiredSize);
		///   pDevice->Release();
		///
		///   return RequiredSize;
		///}]]>
		/// </code>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12devicechild-getdevice HRESULT GetDevice( REFIID riid,
		// [out, optional] void **ppvDevice );
		[PreserveSig]
		new HRESULT GetDevice(in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 0)] out object? ppvDevice);

		/// <summary>Gets the type of the command list, such as direct, bundle, compute, or copy.</summary>
		/// <returns>
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>
		/// This method returns the type of the command list, as a <c>D3D12_COMMAND_LIST_TYPE</c> enumeration constant, such as direct,
		/// bundle, compute, or copy.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12commandlist-gettype D3D12_COMMAND_LIST_TYPE GetType();
		[PreserveSig]
		new D3D12_COMMAND_LIST_TYPE GetType();

		/// <summary>Indicates that recording to the command list has finished.</summary>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// <b>E_FAIL</b> if the command list has already been closed, or an invalid API was called during command list recording.
		/// </description>
		/// </item>
		/// <item>
		/// <description><b>E_OUTOFMEMORY</b> if the operating system ran out of memory during recording.</description>
		/// </item>
		/// <item>
		/// <description><b>E_INVALIDARG</b> if an invalid argument was passed to the command list API during recording.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 Return Codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The runtime will validate that the command list has not previously been closed. If an error was encountered during recording,
		/// the error code is returned here. The runtime won't call the close device driver interface (DDI) in this case. Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::Close</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::LoadAssets() { // Create an empty root signature. { CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
		/// rootSignatureDesc.Init(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);
		/// ComPtr&lt;ID3DBlob&gt; signature; ComPtr&lt;ID3DBlob&gt; error;
		/// ThrowIfFailed(D3D12SerializeRootSignature(&amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &amp;signature, &amp;error));
		/// ThrowIfFailed(m_device-&gt;CreateRootSignature(0, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(),
		/// IID_PPV_ARGS(&amp;m_rootSignature))); } // Create the pipeline state, which includes compiling and loading shaders. {
		/// ComPtr&lt;ID3DBlob&gt; vertexShader; ComPtr&lt;ID3DBlob&gt; pixelShader; #if defined(_DEBUG) // Enable better shader debugging
		/// with the graphics debugging tools. UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION; #else UINT compileFlags
		/// = 0; #endif ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L"shaders.hlsl").c_str(), nullptr, nullptr, "VSMain", "vs_5_0",
		/// compileFlags, 0, &amp;vertexShader, nullptr)); ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L"shaders.hlsl").c_str(),
		/// nullptr, nullptr, "PSMain", "ps_5_0", compileFlags, 0, &amp;pixelShader, nullptr)); // Define the vertex input layout.
		/// D3D12_INPUT_ELEMENT_DESC inputElementDescs[] = { { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,
		/// D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, { "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12,
		/// D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 } }; // Describe and create the graphics pipeline state object (PSO).
		/// D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = {}; psoDesc.InputLayout = { inputElementDescs, _countof(inputElementDescs) };
		/// psoDesc.pRootSignature = m_rootSignature.Get(); psoDesc.VS = {
		/// reinterpret_cast&lt;UINT8*&gt;(vertexShader-&gt;GetBufferPointer()), vertexShader-&gt;GetBufferSize() }; psoDesc.PS = {
		/// reinterpret_cast&lt;UINT8*&gt;(pixelShader-&gt;GetBufferPointer()), pixelShader-&gt;GetBufferSize() }; psoDesc.RasterizerState =
		/// CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT); psoDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
		/// psoDesc.DepthStencilState.DepthEnable = FALSE; psoDesc.DepthStencilState.StencilEnable = FALSE; psoDesc.SampleMask = UINT_MAX;
		/// psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE; psoDesc.NumRenderTargets = 1; psoDesc.RTVFormats[0] =
		/// DXGI_FORMAT_R8G8B8A8_UNORM; psoDesc.SampleDesc.Count = 1; ThrowIfFailed(m_device-&gt;CreateGraphicsPipelineState(&amp;psoDesc,
		/// IID_PPV_ARGS(&amp;m_pipelineState))); } // Create the command list. ThrowIfFailed(m_device-&gt;CreateCommandList(0,
		/// D3D12_COMMAND_LIST_TYPE_DIRECT, m_commandAllocator.Get(), m_pipelineState.Get(), IID_PPV_ARGS(&amp;m_commandList))); // Command
		/// lists are created in the recording state, but there is nothing // to record yet. The main loop expects it to be closed, so close
		/// it now. ThrowIfFailed(m_commandList-&gt;Close()); // Create the vertex buffer. { // Define the geometry for a triangle. Vertex
		/// triangleVertices[] = { { { 0.0f, 0.25f * m_aspectRatio, 0.0f }, { 1.0f, 0.0f, 0.0f, 1.0f } }, { { 0.25f, -0.25f * m_aspectRatio,
		/// 0.0f }, { 0.0f, 1.0f, 0.0f, 1.0f } }, { { -0.25f, -0.25f * m_aspectRatio, 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f } } }; const UINT
		/// vertexBufferSize = sizeof(triangleVertices); // Note: using upload heaps to transfer static data like vert buffers is not //
		/// recommended. Every time the GPU needs it, the upload heap will be marshalled // over. Please read up on Default Heap usage. An
		/// upload heap is used here for // code simplicity and because there are very few verts to actually transfer.
		/// ThrowIfFailed(m_device-&gt;CreateCommittedResource( &amp;CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD), D3D12_HEAP_FLAG_NONE,
		/// &amp;D3D12_RESOURCE_DESC::Buffer(vertexBufferSize), D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		/// IID_PPV_ARGS(&amp;m_vertexBuffer))); // Copy the triangle data to the vertex buffer. UINT8* pVertexDataBegin; CD3DX12_RANGE
		/// readRange(0, 0); // We do not intend to read from this resource on the CPU. ThrowIfFailed(m_vertexBuffer-&gt;Map(0,
		/// &amp;readRange, reinterpret_cast&lt;void**&gt;(&amp;pVertexDataBegin))); memcpy(pVertexDataBegin, triangleVertices,
		/// sizeof(triangleVertices)); m_vertexBuffer-&gt;Unmap(0, nullptr); // Initialize the vertex buffer view.
		/// m_vertexBufferView.BufferLocation = m_vertexBuffer-&gt;GetGPUVirtualAddress(); m_vertexBufferView.StrideInBytes =
		/// sizeof(Vertex); m_vertexBufferView.SizeInBytes = vertexBufferSize; } // Create synchronization objects and wait until assets
		/// have been uploaded to the GPU. { ThrowIfFailed(m_device-&gt;CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&amp;m_fence)));
		/// m_fenceValue = 1; // Create an event handle to use for frame synchronization. m_fenceEvent = CreateEvent(nullptr, FALSE, FALSE,
		/// nullptr); if (m_fenceEvent == nullptr) { ThrowIfFailed(HRESULT_FROM_WIN32(GetLastError())); } // Wait for the command list to
		/// execute; we are reusing the same command // list in our main loop but for now, we just want to wait for setup to // complete
		/// before continuing. WaitForPreviousFrame(); } }</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-close HRESULT Close();
		[PreserveSig]
		new HRESULT Close();

		/// <summary>Resets a command list back to its initial state as if a new command list was just created.</summary>
		/// <param name="pAllocator">
		/// <para>Type: <b>ID3D12CommandAllocator*</b></para>
		/// <para>A pointer to the <c>ID3D12CommandAllocator</c> object that the device creates command lists from.</para>
		/// </param>
		/// <param name="pInitialState">
		/// <para>Type: <b>ID3D12PipelineState*</b></para>
		/// <para>
		/// A pointer to the <c>ID3D12PipelineState</c> object that contains the initial pipeline state for the command list. This is
		/// optional and can be NULL. If NULL, the runtime sets a dummy initial pipeline state so that drivers don't have to deal with
		/// undefined state. The overhead for this is low, particularly for a command list, for which the overall cost of recording the
		/// command list likely dwarfs the cost of one initial state setting. So there is little cost in not setting the initial pipeline
		/// state parameter if it isn't convenient.
		/// </para>
		/// <para>
		/// For bundles on the other hand, it might make more sense to try to set the initial state parameter since bundles are likely
		/// smaller overall and can be reused frequently.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// <b>E_FAIL</b> if the command list was not in the "closed" state when the <b>Reset</b> call was made, or the per-device limit
		/// would have been exceeded.
		/// </description>
		/// </item>
		/// <item>
		/// <description><b>E_OUTOFMEMORY</b> if the operating system ran out of memory.</description>
		/// </item>
		/// <item>
		/// <description>
		/// <b>E_INVALIDARG</b> if the allocator is currently being used with another command list in the "recording" state or if the
		/// specified allocator was created with the wrong type.
		/// </description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 Return Codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// By using <b>Reset</b>, you can re-use command list tracking structures without any allocations. Unlike
		/// <c>ID3D12CommandAllocator::Reset</c>, you can call <b>Reset</b> while the command list is still being executed.
		/// </para>
		/// <para>You can use <b>Reset</b> for both direct command lists and bundles.</para>
		/// <para>
		/// The command allocator passed to <b>Reset</b> cannot be associated with any other currently-recording command list. The allocator
		/// type, direct command list or bundle, must match the type of command list that is being created.
		/// </para>
		/// <para>
		/// If a bundle doesn't specify a resource heap, it can't make changes to which descriptor tables are bound. Either way, bundles
		/// can't change the resource heap within the bundle. If a heap is specified for a bundle, the heap must match the calling 'parent'
		/// command lists heap.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>
		/// Before an app calls <b>Reset</b>, the command list must be in the "closed" state. <b>Reset</b> will fail if the command list
		/// isn't in the "closed" state.
		/// </para>
		/// <para>
		/// <b>Note</b>If a call to <c>ID3D12GraphicsCommandList::Close</c> fails, the command list can never be reset. Calling
		/// <b>Reset</b> will result in the same error being returned that <b>ID3D12GraphicsCommandList::Close</b> returned.
		/// </para>
		/// <para></para>
		/// <para>
		/// After <b>Reset</b> succeeds, the command list is left in the "recording" state. <b>Reset</b> will fail if it would cause the
		/// maximum concurrently recording command list limit, which is specified at device creation, to be exceeded.
		/// </para>
		/// <para>
		/// Apps must specify a command list allocator. The runtime will ensure that an allocator is never associated with more than one
		/// recording command list at the same time.
		/// </para>
		/// <para><b>Reset</b> fails for bundles that are referenced by a not yet submitted command list.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>
		/// The debug layer will also track graphics processing unit (GPU) progress and issue an error if it can't prove that there are no
		/// outstanding executions of the command list. Examples The <c>D3D12HelloTriangle</c> sample uses
		/// <b>ID3D12GraphicsCommandList::Reset</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset HRESULT Reset( [in]
		// ID3D12CommandAllocator *pAllocator, [in, optional] ID3D12PipelineState *pInitialState );
		[PreserveSig]
		new HRESULT Reset([In] ID3D12CommandAllocator pAllocator, [In, Optional] ID3D12PipelineState? pInitialState);

		/// <summary>Resets the state of a direct command list back to the state it was in when the command list was created.</summary>
		/// <param name="pPipelineState">
		/// <para>Type: <b><c>ID3D12PipelineState</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12PipelineState</c> object that contains the initial pipeline state for the command list.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// It is invalid to call <b>ClearState</b> on a bundle. If an app calls <b>ClearState</b> on a bundle, the call to <c>Close</c>
		/// will return <b>E_FAIL</b>.
		/// </para>
		/// <para>
		/// When <b>ClearState</b> is called, all currently bound resources are unbound. The primitive topology is set to
		/// <c>D3D_PRIMITIVE_TOPOLOGY_UNDEFINED</c>. Viewports, scissor rectangles, stencil reference value, and the blend factor are set to
		/// empty values (all zeros). Predication is disabled.
		/// </para>
		/// <para>The app-provided pipeline state object becomes bound as the currently set pipeline state object.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearstate void ClearState( [in,
		// optional] ID3D12PipelineState *pPipelineState );
		[PreserveSig]
		new void ClearState([In, Optional] ID3D12PipelineState? pPipelineState);

		/// <summary>Draws non-indexed, instanced primitives.</summary>
		/// <param name="VertexCountPerInstance">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of vertices to draw.</para>
		/// </param>
		/// <param name="InstanceCount">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of instances to draw.</para>
		/// </param>
		/// <param name="StartVertexLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Index of the first vertex.</para>
		/// </param>
		/// <param name="StartInstanceLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>A value added to each index before reading per-instance data from a vertex buffer.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>A draw API submits work to the rendering pipeline.</para>
		/// <para>
		/// Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing
		/// could be to draw the same object with different positions and colors.
		/// </para>
		/// <para>
		/// The vertex data for an instanced draw call typically comes from a vertex buffer that is bound to the pipeline. But, you could
		/// also provide the vertex data from a shader that has instanced data identified with a system-value semantic (SV_InstanceID).
		/// Examples The <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::DrawInstanced</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-drawinstanced void DrawInstanced(
		// [in] UINT VertexCountPerInstance, [in] UINT InstanceCount, [in] UINT StartVertexLocation, [in] UINT StartInstanceLocation );
		[PreserveSig]
		new void DrawInstanced(uint VertexCountPerInstance, uint InstanceCount, uint StartVertexLocation, uint StartInstanceLocation);

		/// <summary>Draws indexed, instanced primitives.</summary>
		/// <param name="IndexCountPerInstance">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of indices read from the index buffer for each instance.</para>
		/// </param>
		/// <param name="InstanceCount">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of instances to draw.</para>
		/// </param>
		/// <param name="StartIndexLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The location of the first index read by the GPU from the index buffer.</para>
		/// </param>
		/// <param name="BaseVertexLocation">
		/// <para>Type: <b><c>INT</c></b></para>
		/// <para>A value added to each index before reading a vertex from the vertex buffer.</para>
		/// </param>
		/// <param name="StartInstanceLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>A value added to each index before reading per-instance data from a vertex buffer.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>A draw API submits work to the rendering pipeline.</para>
		/// <para>
		/// Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing
		/// could be to draw the same object with different positions and colors. Instancing requires multiple vertex buffers: at least one
		/// for per-vertex data and a second buffer for per-instance data. Examples The <c>D3D12Bundles</c> sample uses
		/// <b>ID3D12GraphicsCommandList::DrawIndexedInstanced</b> as follows:
		/// </para>
		/// <para>
		/// <c>void FrameResource::PopulateCommandList(ID3D12GraphicsCommandList* pCommandList, ID3D12PipelineState* pPso1,
		/// ID3D12PipelineState* pPso2, UINT frameResourceIndex, UINT numIndices, D3D12_INDEX_BUFFER_VIEW* pIndexBufferViewDesc,
		/// D3D12_VERTEX_BUFFER_VIEW* pVertexBufferViewDesc, ID3D12DescriptorHeap* pCbvSrvDescriptorHeap, UINT cbvSrvDescriptorSize,
		/// ID3D12DescriptorHeap* pSamplerDescriptorHeap, ID3D12RootSignature* pRootSignature) { // If the root signature matches the root
		/// signature of the caller, then // bindings are inherited, otherwise the bind space is reset.
		/// pCommandList-&gt;SetGraphicsRootSignature(pRootSignature); ID3D12DescriptorHeap* ppHeaps[] = { pCbvSrvDescriptorHeap,
		/// pSamplerDescriptorHeap }; pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// pCommandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		/// pCommandList-&gt;IASetIndexBuffer(pIndexBufferViewDesc); pCommandList-&gt;IASetVertexBuffers(0, 1, pVertexBufferViewDesc);
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(0, pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(1, pSamplerDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart()); //
		/// Calculate the descriptor offset due to multiple frame resources. // 1 SRV + how many CBVs we have currently. UINT
		/// frameResourceDescriptorOffset = 1 + (frameResourceIndex * m_cityRowCount * m_cityColumnCount); CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvSrvHandle(pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart(), frameResourceDescriptorOffset,
		/// cbvSrvDescriptorSize); BOOL usePso1 = TRUE; for (UINT i = 0; i &lt; m_cityRowCount; i++) { for (UINT j = 0; j &lt;
		/// m_cityColumnCount; j++) { // Alternate which PSO to use; the pixel shader is different on // each just as a PSO setting
		/// demonstration. pCommandList-&gt;SetPipelineState(usePso1 ? pPso1 : pPso2); usePso1 = !usePso1; // Set this city's CBV table and
		/// move to the next descriptor. pCommandList-&gt;SetGraphicsRootDescriptorTable(2, cbvSrvHandle);
		/// cbvSrvHandle.Offset(cbvSrvDescriptorSize); pCommandList-&gt;DrawIndexedInstanced(numIndices, 1, 0, 0, 0); } } }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-drawindexedinstanced void
		// DrawIndexedInstanced( [in] UINT IndexCountPerInstance, [in] UINT InstanceCount, [in] UINT StartIndexLocation, [in] INT
		// BaseVertexLocation, [in] UINT StartInstanceLocation );
		[PreserveSig]
		new void DrawIndexedInstanced(uint IndexCountPerInstance, uint InstanceCount, uint StartIndexLocation, int BaseVertexLocation, uint StartInstanceLocation);

		/// <summary>Executes a command list from a thread group.</summary>
		/// <param name="ThreadGroupCountX">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// The number of groups dispatched in the x direction. <i>ThreadGroupCountX</i> must be less than or equal to
		/// D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).
		/// </para>
		/// </param>
		/// <param name="ThreadGroupCountY">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// The number of groups dispatched in the y direction. <i>ThreadGroupCountY</i> must be less than or equal to
		/// D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).
		/// </para>
		/// </param>
		/// <param name="ThreadGroupCountZ">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// The number of groups dispatched in the z direction. <i>ThreadGroupCountZ</i> must be less than or equal to
		/// D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535). In feature level 10 the value for <i>ThreadGroupCountZ</i> must be 1.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// You call the <b>Dispatch</b> method to execute commands in a compute shader. A compute shader can be run on many threads in
		/// parallel, within a thread group. Index a particular thread, within a thread group using a 3D vector given by (x,y,z). Examples
		/// The <c>D3D12nBodyGravity</c> sample uses <b>ID3D12GraphicsCommandList::Dispatch</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Run the particle simulation using the compute shader. void D3D12nBodyGravity::Simulate(UINT threadIndex) {
		/// ID3D12GraphicsCommandList* pCommandList = m_computeCommandList[threadIndex].Get(); UINT srvIndex; UINT uavIndex; ID3D12Resource
		/// *pUavResource; if (m_srvIndex[threadIndex] == 0) { srvIndex = SrvParticlePosVelo0; uavIndex = UavParticlePosVelo1; pUavResource
		/// = m_particleBuffer1[threadIndex].Get(); } else { srvIndex = SrvParticlePosVelo1; uavIndex = UavParticlePosVelo0; pUavResource =
		/// m_particleBuffer0[threadIndex].Get(); } pCommandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(pUavResource, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE,
		/// D3D12_RESOURCE_STATE_UNORDERED_ACCESS)); pCommandList-&gt;SetPipelineState(m_computeState.Get());
		/// pCommandList-&gt;SetComputeRootSignature(m_computeRootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_srvUavHeap.Get()
		/// }; pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// srvHandle(m_srvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart(), srvIndex + threadIndex, m_srvUavDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE uavHandle(m_srvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart(), uavIndex + threadIndex,
		/// m_srvUavDescriptorSize); pCommandList-&gt;SetComputeRootConstantBufferView(RootParameterCB,
		/// m_constantBufferCS-&gt;GetGPUVirtualAddress()); pCommandList-&gt;SetComputeRootDescriptorTable(RootParameterSRV, srvHandle);
		/// pCommandList-&gt;SetComputeRootDescriptorTable(RootParameterUAV, uavHandle);
		/// pCommandList-&gt;Dispatch(static_cast&lt;int&gt;(ceil(ParticleCount / 128.0f)), 1, 1); pCommandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(pUavResource, D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
		/// D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch void Dispatch( [in] UINT
		// ThreadGroupCountX, [in] UINT ThreadGroupCountY, [in] UINT ThreadGroupCountZ );
		[PreserveSig]
		new void Dispatch(uint ThreadGroupCountX, uint ThreadGroupCountY, uint ThreadGroupCountZ);

		/// <summary>Copies a region of a buffer from one resource to another.</summary>
		/// <param name="pDstBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies the destination <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="DstOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies a UINT64 offset (in bytes) into the destination resource.</para>
		/// </param>
		/// <param name="pSrcBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies the source <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="SrcOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies a UINT64 offset (in bytes) into the source resource, to start the copy from.</para>
		/// </param>
		/// <param name="NumBytes">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies the number of bytes to copy.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Consider using the <c>CopyResource</c> method when copying an entire resource, and use this method for copying regions of a resource.
		/// </para>
		/// <para>
		/// <b>CopyBufferRegion</b> may be used to initialize resources which alias the same heap memory. See <c>CreatePlacedResource</c>
		/// for more details. Examples The <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::CopyBufferRegion</b> as follows:
		/// </para>
		/// <para>
		/// <c>inline UINT64 UpdateSubresources( _In_ ID3D12GraphicsCommandList* pCmdList, _In_ ID3D12Resource* pDestinationResource, _In_
		/// ID3D12Resource* pIntermediate, _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		/// _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources, UINT64 RequiredSize, _In_reads_(NumSubresources)
		/// const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts, _In_reads_(NumSubresources) const UINT* pNumRows,
		/// _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes, _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData)
		/// { // Minor validation D3D12_RESOURCE_DESC IntermediateDesc = pIntermediate-&gt;GetDesc(); D3D12_RESOURCE_DESC DestinationDesc =
		/// pDestinationResource-&gt;GetDesc(); if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER || IntermediateDesc.Width
		/// &lt; RequiredSize + pLayouts[0].Offset || RequiredSize &gt; (SIZE_T)-1 || (DestinationDesc.Dimension ==
		/// D3D12_RESOURCE_DIMENSION_BUFFER &amp;&amp; (FirstSubresource != 0 || NumSubresources != 1))) { return 0; } BYTE* pData; HRESULT
		/// hr = pIntermediate-&gt;Map(0, NULL, reinterpret_cast&lt;void**&gt;(&amp;pData)); if (FAILED(hr)) { return 0; } for (UINT i = 0;
		/// i &lt; NumSubresources; ++i) { if (pRowSizesInBytes[i] &gt; (SIZE_T)-1) return 0; D3D12_MEMCPY_DEST DestData = { pData +
		/// pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, pLayouts[i].Footprint.RowPitch * pNumRows[i] };
		/// MemcpySubresource(&amp;DestData, &amp;pSrcData[i], (SIZE_T)pRowSizesInBytes[i], pNumRows[i], pLayouts[i].Footprint.Depth); }
		/// pIntermediate-&gt;Unmap(0, NULL); if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER) { CD3DX12_BOX SrcBox( UINT(
		/// pLayouts[0].Offset ), UINT( pLayouts[0].Offset + pLayouts[0].Footprint.Width ) ); pCmdList-&gt;CopyBufferRegion(
		/// pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width); } else { for (UINT i = 0; i &lt;
		/// NumSubresources; ++i) { CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
		/// CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]); pCmdList-&gt;CopyTextureRegion(&amp;Dst, 0, 0, 0, &amp;Src,
		/// nullptr); } } return RequiredSize; }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copybufferregion void
		// CopyBufferRegion( [in] ID3D12Resource *pDstBuffer, UINT64 DstOffset, [in] ID3D12Resource *pSrcBuffer, UINT64 SrcOffset, UINT64
		// NumBytes );
		[PreserveSig]
		new void CopyBufferRegion([In] ID3D12Resource pDstBuffer, ulong DstOffset, [In] ID3D12Resource pSrcBuffer, ulong SrcOffset, ulong NumBytes);

		/// <summary>
		/// This method uses the GPU to copy texture data between two locations. Both the source and the destination may reference texture
		/// data located within either a buffer resource or a texture resource.
		/// </summary>
		/// <param name="pDst">
		/// <para>Type: <b>const <c>D3D12_TEXTURE_COPY_LOCATION</c>*</b></para>
		/// <para>
		/// Specifies the destination <c>D3D12_TEXTURE_COPY_LOCATION</c>. The subresource referred to must be in the
		/// D3D12_RESOURCE_STATE_COPY_DEST state.
		/// </para>
		/// </param>
		/// <param name="DstX">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The x-coordinate of the upper left corner of the destination region.</para>
		/// </param>
		/// <param name="DstY">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The y-coordinate of the upper left corner of the destination region. For a 1D subresource, this must be zero.</para>
		/// </param>
		/// <param name="DstZ">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The z-coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero.</para>
		/// </param>
		/// <param name="pSrc">
		/// <para>Type: <b>const <c>D3D12_TEXTURE_COPY_LOCATION</c>*</b></para>
		/// <para>
		/// Specifies the source <c>D3D12_TEXTURE_COPY_LOCATION</c>. The subresource referred to must be in the
		/// D3D12_RESOURCE_STATE_COPY_SOURCE state.
		/// </para>
		/// </param>
		/// <param name="pSrcBox">
		/// <para>Type: <b>const <c>D3D12_BOX</c>*</b></para>
		/// <para>Specifies an optional D3D12_BOX that sets the size of the source texture to copy.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The source box must be within the size of the source resource. The destination offsets, (x, y, and z), allow the source box to
		/// be offset when writing into the destination resource; however, the dimensions of the source box and the offsets must be within
		/// the size of the resource. If you try and copy outside the destination resource or specify a source box that is larger than the
		/// source resource, the behavior of <b>CopyTextureRegion</b> is undefined. If you created a device that supports the <c>debug
		/// layer</c>, the debug output reports an error on this invalid <b>CopyTextureRegion</b> call. Invalid parameters to
		/// <b>CopyTextureRegion</b> cause undefined behavior and might result in incorrect rendering, clipping, no copy, or even the
		/// removal of the rendering device.
		/// </para>
		/// <para>If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels.</para>
		/// <para>
		/// <b>CopyTextureRegion</b> performs the copy on the GPU (similar to a <c>memcpy</c> by the CPU). As a consequence, the source and
		/// destination resources:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>Must be different subresources (although they can be from the same resource).</description>
		/// </item>
		/// <item>
		/// <description>
		/// Must have compatible <c>DXGI_FORMAT</c> s (identical or from the same type group). For example, a DXGI_FORMAT_R32G32B32_FLOAT
		/// texture can be copied to a DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the
		/// DXGI_FORMAT_R32G32B32_TYPELESS group. <b>CopyTextureRegion</b> can copy between a few format types. For more info, see <c>Format
		/// Conversion using Direct3D 10.1</c>.
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// <b>CopyTextureRegion</b> only supports copy; it does not support any stretch, color key, or blend. <b>CopyTextureRegion</b> can
		/// reinterpret the resource data between a few format types.
		/// </para>
		/// <para>Note that for a depth-stencil buffer, the depth and stencil planes are <c>separate subresources</c> within the buffer.</para>
		/// <para>To copy an entire resource, rather than just a region of a subresource, we recommend to use <c>CopyResource</c> instead.</para>
		/// <para>
		/// <b>Note</b>If you use <b>CopyTextureRegion</b> with a depth-stencil buffer or a multisampled resource, you must copy the
		/// entire subresource rectangle. In this situation, you must pass 0 to the <i>DstX</i>, <i>DstY</i>, and <i>DstZ</i> parameters and
		/// <b>NULL</b> to the <i>pSrcBox</i> parameter. In addition, source and destination resources, which are represented by the
		/// <i>pSrcResource</i> and <i>pDstResource</i> parameters, should have identical sample count values.
		/// </para>
		/// <para></para>
		/// <para>
		/// <b>CopyTextureRegion</b> may be used to initialize resources which alias the same heap memory. See <c>CreatePlacedResource</c>
		/// for more details.
		/// </para>
		/// <para><c></c><c></c><c></c> Example</para>
		/// <para>
		/// The following code snippet copies the box (located at (120,100),(200,220)) from a source texture into the region
		/// (10,20),(90,140) in a destination texture.
		/// </para>
		/// <para>
		/// <c>D3D12_BOX sourceRegion; sourceRegion.left = 120; sourceRegion.top = 100; sourceRegion.right = 200; sourceRegion.bottom = 220;
		/// sourceRegion.front = 0; sourceRegion.back = 1; pCmdList -&gt; CopyTextureRegion(pDestTexture, 10, 20, 0, pSourceTexture, &amp;sourceRegion);</c>
		/// </para>
		/// <para>
		/// Notice, that for a 2D texture, front and back are set to 0 and 1 respectively. Examples The <b>HelloTriangle</b> sample uses
		/// <b>ID3D12GraphicsCommandList::CopyTextureRegion</b> as follows:
		/// </para>
		/// <para>
		/// <c>inline UINT64 UpdateSubresources( _In_ ID3D12GraphicsCommandList* pCmdList, _In_ ID3D12Resource* pDestinationResource, _In_
		/// ID3D12Resource* pIntermediate, _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		/// _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources, UINT64 RequiredSize, _In_reads_(NumSubresources)
		/// const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts, _In_reads_(NumSubresources) const UINT* pNumRows,
		/// _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes, _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData)
		/// { // Minor validation D3D12_RESOURCE_DESC IntermediateDesc = pIntermediate-&gt;GetDesc(); D3D12_RESOURCE_DESC DestinationDesc =
		/// pDestinationResource-&gt;GetDesc(); if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER || IntermediateDesc.Width
		/// &lt; RequiredSize + pLayouts[0].Offset || RequiredSize &gt; (SIZE_T)-1 || (DestinationDesc.Dimension ==
		/// D3D12_RESOURCE_DIMENSION_BUFFER &amp;&amp; (FirstSubresource != 0 || NumSubresources != 1))) { return 0; } BYTE* pData; HRESULT
		/// hr = pIntermediate-&gt;Map(0, NULL, reinterpret_cast&lt;void**&gt;(&amp;pData)); if (FAILED(hr)) { return 0; } for (UINT i = 0;
		/// i &lt; NumSubresources; ++i) { if (pRowSizesInBytes[i] &gt; (SIZE_T)-1) return 0; D3D12_MEMCPY_DEST DestData = { pData +
		/// pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, pLayouts[i].Footprint.RowPitch * pNumRows[i] };
		/// MemcpySubresource(&amp;DestData, &amp;pSrcData[i], (SIZE_T)pRowSizesInBytes[i], pNumRows[i], pLayouts[i].Footprint.Depth); }
		/// pIntermediate-&gt;Unmap(0, NULL); if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER) { CD3DX12_BOX SrcBox( UINT(
		/// pLayouts[0].Offset ), UINT( pLayouts[0].Offset + pLayouts[0].Footprint.Width ) ); pCmdList-&gt;CopyBufferRegion(
		/// pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width); } else { for (UINT i = 0; i &lt;
		/// NumSubresources; ++i) { CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
		/// CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]); pCmdList-&gt;CopyTextureRegion(&amp;Dst, 0, 0, 0, &amp;Src,
		/// nullptr); } } return RequiredSize; }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion void
		// CopyTextureRegion( [in] const D3D12_TEXTURE_COPY_LOCATION *pDst, UINT DstX, UINT DstY, UINT DstZ, [in] const
		// D3D12_TEXTURE_COPY_LOCATION *pSrc, [in, optional] const D3D12_BOX *pSrcBox );
		[PreserveSig]
		new void CopyTextureRegion(in D3D12_TEXTURE_COPY_LOCATION pDst, uint DstX, uint DstY, uint DstZ, in D3D12_TEXTURE_COPY_LOCATION pSrc,
			[In, Optional] StructPointer<D3D12_BOX> pSrcBox);

		/// <summary>Copies the entire contents of the source resource to the destination resource.</summary>
		/// <param name="pDstResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the destination resource.</para>
		/// </param>
		/// <param name="pSrcResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the source resource.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>CopyResource</b> operations are performed on the GPU, and do not incur a significant CPU workload linearly dependent on the
		/// size of the data to copy.
		/// </para>
		/// <para>
		/// <b>CopyResource</b> can be used to initialize resources that alias the same heap memory. See <c>CreatePlacedResource</c> for
		/// more details.
		/// </para>
		/// <para>Debug layer</para>
		/// <para>The debug layer issues an error if the source subresource is not in the <c>D3D12_RESOURCE_STATE_COPY_SOURCE</c> state.</para>
		/// <para>
		/// The debug layer issues an error if the destination subresource is not in the <c>D3D12_RESOURCE_STATE_COPY_DEST</c> state.
		/// Restrictions This method has a few restrictions designed for improving performance. For instance, the source and destination resources:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>Must be different resources.</description>
		/// </item>
		/// <item>
		/// <description>Must be the same type.</description>
		/// </item>
		/// <item>
		/// <description>Must be the same total size (bytes).</description>
		/// </item>
		/// <item>
		/// <description>Must have identical dimensions (width, height, depth) or be a compatible <c>Reinterpret Copy</c>.</description>
		/// </item>
		/// <item>
		/// <description>
		/// Must have compatible <c>DXGI formats</c>, which means the formats must be identical or at least from the same type group. For
		/// example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to a DXGI_FORMAT_R32G32B32_UINT texture since both of these formats
		/// are in the DXGI_FORMAT_R32G32B32_TYPELESS group. <b>CopyResource</b> can copy between a few format types (see <c>Reinterpret copy</c>).
		/// </description>
		/// </item>
		/// <item>
		/// <description>Can't be currently mapped.</description>
		/// </item>
		/// </list>
		/// <para><b>CopyResource</b> only supports copy; it doesn't support any stretch, color key, or blend.</para>
		/// <para>
		/// <b>CopyResource</b> can reinterpret the resource data between a few format types, see <c>Reinterpret Copy</c> below for details.
		/// </para>
		/// <para>
		/// You can use a <c>depth-stencil</c> resource as either a source or a destination. Resources created with multi-sampling
		/// capability (see <c>DXGI_SAMPLE_DESC</c>) can be used as source and destination only if both source and destination have
		/// identical multi-sampled count and quality. If source and destination differ in multi-sampled count and quality or if one is
		/// multi-sampled and the other is not multi-sampled, the call to <b>CopyResource</b> fails. Use <c>ResolveSubresource</c> to
		/// resolve a multi-sampled resource to a resource that is not multi-sampled.
		/// </para>
		/// <para>
		/// The method is an asynchronous call, which may be added to the command-buffer queue. This attempts to remove pipeline stalls that
		/// may occur when copying data. For more info, see <c>performance considerations</c>.
		/// </para>
		/// <para>
		/// Consider using <c>CopyTextureRegion</c> or <c>CopyBufferRegion</c> if you only need to copy a portion of the data in a resource.
		/// </para>
		/// <para>Reinterpret copy</para>
		/// <para>
		/// The following table lists the allowable source and destination formats that you can use in the reinterpretation type of format
		/// conversion. The underlying data values are not converted or compressed/decompressed and must be encoded properly for the
		/// reinterpretation to work as expected. For more info, see <c>Format Conversion using Direct3D 10.1</c>.
		/// </para>
		/// <para>For DXGI_FORMAT_R9G9B9E5_SHAREDEXP the width and height must be equal (1 texel per block).</para>
		/// <para>
		/// Block-compressed resource width and height must be 4 times the uncompressed resource width and height (16 texels per block). For
		/// example, a uncompressed 256x256 DXGI_FORMAT_R32G32B32A32_UINT texture will map to a 1024x1024 DXGI_FORMAT_BC5_UNORM compressed texture.
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Bit width</description>
		/// <description>Uncompressed resource</description>
		/// <description>Block-compressed resource</description>
		/// <description>Width / height difference</description>
		/// </listheader>
		/// <item>
		/// <description>32</description>
		/// <description>DXGI_FORMAT_R32_UINT DXGI_FORMAT_R32_SINT</description>
		/// <description>DXGI_FORMAT_R9G9B9E5_SHAREDEXP</description>
		/// <description>1:1</description>
		/// </item>
		/// <item>
		/// <description>64</description>
		/// <description>DXGI_FORMAT_R16G16B16A16_UINT DXGI_FORMAT_R16G16B16A16_SINT DXGI_FORMAT_R32G32_UINT DXGI_FORMAT_R32G32_SINT</description>
		/// <description>DXGI_FORMAT_BC1_UNORM[_SRGB] DXGI_FORMAT_BC4_UNORM DXGI_FORMAT_BC4_SNORM</description>
		/// <description>1:4</description>
		/// </item>
		/// <item>
		/// <description>128</description>
		/// <description>DXGI_FORMAT_R32G32B32A32_UINT DXGI_FORMAT_R32G32B32A32_SINT</description>
		/// <description>DXGI_FORMAT_BC2_UNORM[_SRGB] DXGI_FORMAT_BC3_UNORM[_SRGB] DXGI_FORMAT_BC5_UNORM DXGI_FORMAT_BC5_SNORM</description>
		/// <description>1:4</description>
		/// </item>
		/// </list>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copyresource void CopyResource( [in]
		// ID3D12Resource *pDstResource, [in] ID3D12Resource *pSrcResource );
		[PreserveSig]
		new void CopyResource([In] ID3D12Resource pDstResource, [In] ID3D12Resource pSrcResource);

		/// <summary>Copies tiles from buffer to tiled resource or vice versa.</summary>
		/// <param name="pTiledResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to a tiled resource.</para>
		/// </param>
		/// <param name="pTileRegionStartCoordinate">
		/// <para>Type: <b>const <c>D3D12_TILED_RESOURCE_COORDINATE</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_TILED_RESOURCE_COORDINATE</c> structure that describes the starting coordinates of the tiled resource.</para>
		/// </param>
		/// <param name="pTileRegionSize">
		/// <para>Type: <b>const <c>D3D12_TILE_REGION_SIZE</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_TILE_REGION_SIZE</c> structure that describes the size of the tiled region.</para>
		/// </param>
		/// <param name="pBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to an <c>ID3D12Resource</c> that represents a default, dynamic, or staging buffer.</para>
		/// </param>
		/// <param name="BufferStartOffsetInBytes">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset in bytes into the buffer at <i>pBuffer</i> to start the operation.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_TILE_COPY_FLAGS</c></b></para>
		/// <para>
		/// A combination of <c>D3D12_TILE_COPY_FLAGS</c>-typed values that are combined by using a bitwise OR operation and that identifies
		/// how to copy tiles.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>CopyTiles</b> drops write operations to unmapped areas and handles read operations from unmapped areas (except on Tier_1
		/// tiled resources, where reading and writing unmapped areas is invalid - refer to <c>D3D12_TILED_RESOURCES_TIER</c>).
		/// </para>
		/// <para>
		/// If a copy operation involves writing to the same memory location multiple times because multiple locations in the destination
		/// resource are mapped to the same tile memory, the resulting write operations to multi-mapped tiles are non-deterministic and
		/// non-repeatable; that is, accesses to the tile memory happen in whatever order the hardware happens to execute the copy operation.
		/// </para>
		/// <para>
		/// The tiles involved in the copy operation can't include tiles that contain packed mipmaps or results of the copy operation are
		/// undefined. To transfer data to and from mipmaps that the hardware packs into the one-or-more tiles that constitute the packed
		/// mips, you must use the standard (that is, non-tile specific) copy APIs like <c>CopyTextureRegion</c>.
		/// </para>
		/// <para><b>CopyTiles</b> does copy data in a slightly different pattern than the standard copy methods.</para>
		/// <para>
		/// The memory layout of the tiles in the non-tiled buffer resource side of the copy operation is linear in memory within 64 KB
		/// tiles, which the hardware and driver swizzle and de-swizzle per tile as appropriate when they transfer to and from a tiled
		/// resource. For multisample antialiasing (MSAA) surfaces, the hardware and driver traverse each pixel's samples in sample-index
		/// order before they move to the next pixel. For tiles that are partially filled on the right side (for a surface that has a width
		/// not a multiple of tile width in pixels), the pitch and stride to move down a row is the full size in bytes of the number pixels
		/// that would fit across the tile if the tile was full. So, there can be a gap between each row of pixels in memory. Mipmaps that
		/// are smaller than a tile are not packed together in the linear layout, which might seem to be a waste of memory space, but as
		/// mentioned you can't use <b>CopyTiles</b> to copy to mipmaps that the hardware packs together. You can just use generic copy
		/// APIs, like <c>CopyTextureRegion</c>, to copy small mipmaps individually.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytiles void CopyTiles( [in]
		// ID3D12Resource *pTiledResource, [in] const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate, [in] const
		// D3D12_TILE_REGION_SIZE *pTileRegionSize, [in] ID3D12Resource *pBuffer, UINT64 BufferStartOffsetInBytes, D3D12_TILE_COPY_FLAGS
		// Flags );
		[PreserveSig]
		new void CopyTiles([In] ID3D12Resource pTiledResource, in D3D12_TILED_RESOURCE_COORDINATE pTileRegionStartCoordinate,
			in D3D12_TILE_REGION_SIZE pTileRegionSize, [In] ID3D12Resource pBuffer, ulong BufferStartOffsetInBytes, D3D12_TILE_COPY_FLAGS Flags);

		/// <summary>Copy a multi-sampled resource into a non-multi-sampled resource.</summary>
		/// <param name="pDstResource">
		/// <para>Type: [in] <b>ID3D12Resource*</b></para>
		/// <para>Destination resource. Must be a created on a <c>D3D12_HEAP_TYPE_DEFAULT</c> heap and be single-sampled. See <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="DstSubresource">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>
		/// A zero-based index, that identifies the destination subresource. Use <c>D3D12CalcSubresource</c> to calculate the subresource
		/// index if the parent resource is complex.
		/// </para>
		/// </param>
		/// <param name="pSrcResource">
		/// <para>Type: [in] <b>ID3D12Resource*</b></para>
		/// <para>Source resource. Must be multisampled.</para>
		/// </param>
		/// <param name="SrcSubresource">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The source subresource of the source resource.</para>
		/// </param>
		/// <param name="Format">
		/// <para>Type: [in] <b>DXGI_FORMAT</b></para>
		/// <para>A <c>DXGI_FORMAT</c> that indicates how the multisampled resource will be resolved to a single-sampled resource. See remarks.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>
		/// The debug layer will issue an error if the subresources referenced by the source view is not in the
		/// <c>D3D12_RESOURCE_STATE_RESOLVE_SOURCE</c> state.
		/// </para>
		/// <para>The debug layer will issue an error if the destination buffer is not in the <c>D3D12_RESOURCE_STATE_RESOLVE_DEST</c> state.</para>
		/// <para>
		/// The source and destination resources must be the same resource type and have the same dimensions. In addition, they must have
		/// compatible formats. There are three scenarios for this:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Scenario</description>
		/// <description>Requirements</description>
		/// </listheader>
		/// <item>
		/// <description>Source and destination are prestructured and typed</description>
		/// <description>
		/// Both the source and destination must have identical formats and that format must be specified in the Format parameter.
		/// </description>
		/// </item>
		/// <item>
		/// <description>One resource is prestructured and typed and the other is prestructured and typeless</description>
		/// <description>
		/// The typed resource must have a format that is compatible with the typeless resource (i.e. the typed resource is
		/// DXGI_FORMAT_R32_FLOAT and the typeless resource is DXGI_FORMAT_R32_TYPELESS). The format of the typed resource must be specified
		/// in the Format parameter.
		/// </description>
		/// </item>
		/// <item>
		/// <description>Source and destination are prestructured and typeless</description>
		/// <description>
		/// Both the source and destination must have the same typeless format (i.e. both must have DXGI_FORMAT_R32_TYPELESS), and the
		/// Format parameter must specify a format that is compatible with the source and destination (i.e. if both are
		/// DXGI_FORMAT_R32_TYPELESS then DXGI_FORMAT_R32_FLOAT could be specified in the Format parameter). For example, given the
		/// DXGI_FORMAT_R16G16B16A16_TYPELESS format:
		/// </description>
		/// </item>
		/// </list>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvesubresource void
		// ResolveSubresource( ID3D12Resource *pDstResource, UINT DstSubresource, ID3D12Resource *pSrcResource, UINT SrcSubresource,
		// DXGI_FORMAT Format );
		[PreserveSig]
		new void ResolveSubresource([In] ID3D12Resource pDstResource, uint DstSubresource, [In] ID3D12Resource pSrcResource, uint SrcSubresource,
			DXGI_FORMAT Format);

		/// <summary>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</summary>
		/// <param name="PrimitiveTopology">
		/// <para>Type: <b>D3D12_PRIMITIVE_TOPOLOGY</b></para>
		/// <para>The type of primitive and ordering of the primitive data (see <c>D3D_PRIMITIVE_TOPOLOGY</c>).</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-iasetprimitivetopology void
		// IASetPrimitiveTopology( [in] D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology );
		[PreserveSig]
		new void IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY PrimitiveTopology);

		/// <summary>Bind an array of viewports to the rasterizer stage of the pipeline.</summary>
		/// <param name="NumViewports">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Number of viewports to bind. The range of valid values is (0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE).</para>
		/// </param>
		/// <param name="pViewports">
		/// <para>Type: <b>const <c>D3D12_VIEWPORT</c>*</b></para>
		/// <para>An array of <c>D3D12_VIEWPORT</c> structures to bind to the device.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled.</para>
		/// <para>
		/// Which viewport to use is determined by the <c>SV_ViewportArrayIndex</c> semantic output by a geometry shader; if a geometry
		/// shader does not specify the semantic, Direct3D will use the first viewport in the array. Examples The <c>D3D12HelloTriangle</c>
		/// sample uses <b>ID3D12GraphicsCommandList::RSSetViewports</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-rssetviewports void RSSetViewports(
		// [in] UINT NumViewports, [in] const D3D12_VIEWPORT *pViewports );
		[PreserveSig]
		new void RSSetViewports(int NumViewports, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_VIEWPORT[] pViewports);

		/// <summary>Binds an array of scissor rectangles to the rasterizer stage.</summary>
		/// <param name="NumRects">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of scissor rectangles to bind.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: <b>const D3D12_RECT*</b></para>
		/// <para>An array of scissor rectangles.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>All scissor rectangles must be set atomically as one operation. Any scissor rectangles not defined by the call are disabled.</para>
		/// <para>
		/// Which scissor rectangle to use is determined by the <c>SV_ViewportArrayIndex</c> semantic output by a geometry shader (see
		/// shader semantic syntax). If a geometry shader does not make use of the <c>SV_ViewportArrayIndex</c> semantic then Direct3D will
		/// use the first scissor rectangle in the array.
		/// </para>
		/// <para>
		/// Each scissor rectangle in the array corresponds to a viewport in an array of viewports (see <c>RSSetViewports</c>). Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::RSSetScissorRects</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>// Command list allocators can only be reset when the associated // command lists have finished execution on the GPU; apps
		/// should use // fences to determine GPU execution progress. ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when
		/// ExecuteCommandList() is called on a particular command // list, that command list can then be reset at any time and must be
		/// before // re-recording. ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set
		/// necessary state. m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1,
		/// &amp;m_viewport); m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a
		/// render target. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT,
		/// D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close());</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-rssetscissorrects void
		// RSSetScissorRects( [in] UINT NumRects, [in] const D3D12_RECT *pRects );
		[PreserveSig]
		new void RSSetScissorRects(int NumRects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] RECT[] pRects);

		/// <summary>Sets the blend factor that modulate values for a pixel shader, render target, or both.</summary>
		/// <param name="BlendFactor">
		/// <para>Type: <b>const FLOAT[4]</b></para>
		/// <para>Array of blend factors, one for each RGBA component.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// If you created the blend-state object with <c>D3D12_BLEND_BLEND_FACTOR</c> or <b>D3D12_BLEND_INV_BLEND_FACTOR</b>, then the
		/// blending stage uses the non-NULL array of blend factors. Otherwise,the blending stage doesn't use the non-NULL array of blend
		/// factors; the runtime stores the blend factors.
		/// </para>
		/// <para>If you pass NULL, then the runtime uses or stores a blend factor equal to <c>{ 1, 1, 1, 1 }</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetblendfactor void
		// OMSetBlendFactor( [in, optional] const FLOAT [4] BlendFactor );
		[PreserveSig]
		new void OMSetBlendFactor([In, Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] float[]? BlendFactor);

		/// <summary>Sets the reference value for depth stencil tests.</summary>
		/// <param name="StencilRef">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Reference value to perform against when doing a depth-stencil test.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetstencilref void
		// OMSetStencilRef( [in] UINT StencilRef );
		[PreserveSig]
		new void OMSetStencilRef(uint StencilRef);

		/// <summary>Sets all shaders and programs most of the fixed-function state of the graphics processing unit (GPU) pipeline.</summary>
		/// <param name="pPipelineState">
		/// <para>Type: <b><c>ID3D12PipelineState</c>*</b></para>
		/// <para>Pointer to the <c>ID3D12PipelineState</c> containing the pipeline state data.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setpipelinestate void
		// SetPipelineState( [in] ID3D12PipelineState *pPipelineState );
		[PreserveSig]
		new void SetPipelineState([In] ID3D12PipelineState pPipelineState);

		/// <summary>Notifies the driver that it needs to synchronize multiple accesses to resources.</summary>
		/// <param name="NumBarriers">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of submitted barrier descriptions.</para>
		/// </param>
		/// <param name="pBarriers">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_BARRIER</c>*</b></para>
		/// <para>Pointer to an array of barrier descriptions.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <para>Note</para>
		/// <para>
		/// A resource to be used for the <c>D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE</c> state must be created in that state,
		/// and then never transitioned out of it. Nor may a resource that was created not in that state be transitioned into it. For more
		/// info, see <c>Acceleration structure memory restrictions</c> in the DirectX raytracing (DXR) functional specification on GitHub.
		/// </para>
		/// </para>
		/// <para>There are three types of barrier descriptions:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// <c>D3D12_RESOURCE_TRANSITION_BARRIER</c> - Transition barriers indicate that a set of subresources transition between different
		/// usages. The caller must specify the <i>before</i> and <i>after</i> usages of the subresources. The
		/// D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES flag is used to transition all subresources in a resource at the same time.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// <c>D3D12_RESOURCE_ALIASING_BARRIER</c> - Aliasing barriers indicate a transition between usages of two different resources which
		/// have mappings into the same heap. The application can specify both the before and the after resource. Note that one or both
		/// resources can be NULL (indicating that any tiled resource could cause aliasing).
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// <c>D3D12_RESOURCE_UAV_BARRIER</c> - Unordered access view barriers indicate all UAV accesses (read or writes) to a particular
		/// resource must complete before any future UAV accesses (read or write) can begin. The specified resource may be NULL. It is not
		/// necessary to insert a UAV barrier between two draw or dispatch calls which only read a UAV. Additionally, it is not necessary to
		/// insert a UAV barrier between two draw or dispatch calls which write to the same UAV if the application knows that it is safe to
		/// execute the UAV accesses in any order. The resource can be NULL (indicating that any UAV access could require the barrier).
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// When <b>ID3D12GraphicsCommandList::ResourceBarrier</b> is passed an array of resource barrier descriptions, the API behaves as
		/// if it was called N times (1 for each array element), in the specified order. Transitions should be batched together into a
		/// single API call when possible, as a performance optimization.
		/// </para>
		/// <para>
		/// For descriptions of the usage states a subresource can be in, see the <c>D3D12_RESOURCE_STATES</c> enumeration and the <c>Using
		/// Resource Barriers to Synchronize Resource States in Direct3D 12</c> section.
		/// </para>
		/// <para>
		/// All subresources in a resource must be in the RENDER_TARGET state, or DEPTH_WRITE state, for render targets/depth-stencil
		/// resources respectively, when <c>ID3D12GraphicsCommandList::DiscardResource</c> is called.
		/// </para>
		/// <para>
		/// When a back buffer is presented, it must be in the D3D12_RESOURCE_STATE_PRESENT state. If <c>IDXGISwapChain1::Present1</c> is
		/// called on a resource which is not in the PRESENT state, a debug layer warning will be emitted.
		/// </para>
		/// <para>The resource usage bits are group into two categories, read-only and read/write.</para>
		/// <para>The following usage bits are read-only:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_INDEX_BUFFER</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_COPY_SOURCE</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_DEPTH_READ</description>
		/// </item>
		/// </list>
		/// <para>The following usage bits are read/write:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_DEPTH_WRITE</description>
		/// </item>
		/// </list>
		/// <para>The following usage bits are write-only:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_COPY_DEST</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_RENDER_TARGET</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_STREAM_OUT</description>
		/// </item>
		/// </list>
		/// <para>
		/// At most one write bit can be set. If any write bit is set, then no read bit may be set. If no write bit is set, then any number
		/// of read bits may be set.
		/// </para>
		/// <para>
		/// At any given time, a subresource is in exactly one state (determined by a set of flags). The application must ensure that the
		/// states are matched when making a sequence of <b>ResourceBarrier</b> calls. In other words, the before and after states in
		/// consecutive calls to <b>ResourceBarrier</b> must agree.
		/// </para>
		/// <para>
		/// To transition all subresources within a resource, the application can set the subresource index to
		/// D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES, which implies that all subresources are changed.
		/// </para>
		/// <para>
		/// For improved performance, applications should use split barriers (refer to <c>Multi-engine synchronization</c>). Your
		/// application should also batch multiple transitions into a single call whenever possible.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>The runtime will validate that the barrier type values are valid members of the <c>D3D12_RESOURCE_BARRIER_TYPE</c> enumeration.</para>
		/// <para>In addition, the runtime checks the following:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>The resource pointer is non-NULL.</description>
		/// </item>
		/// <item>
		/// <description>The subresource index is valid</description>
		/// </item>
		/// <item>
		/// <description>
		/// The before and after states are supported by the <c>D3D12_RESOURCE_BINDING_TIER</c> and <c>D3D12_RESOURCE_FLAGS</c> flags of the resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description>Reserved bits in the state masks are not set.</description>
		/// </item>
		/// <item>
		/// <description>The before and after states are different.</description>
		/// </item>
		/// <item>
		/// <description>The set of bits in the before and after states are valid.</description>
		/// </item>
		/// <item>
		/// <description>
		/// If the D3D12_RESOURCE_STATE_RESOLVE_SOURCE bit is set, then the resource sample count must be greater than 1.
		/// </description>
		/// </item>
		/// <item>
		/// <description>If the D3D12_RESOURCE_STATE_RESOLVE_DEST bit is set, then the resource sample count must be equal to 1.</description>
		/// </item>
		/// </list>
		/// <para>For aliasing barriers the runtime will validate that, if either resource pointer is non-NULL, it refers to a tiled resource.</para>
		/// <para>
		/// For UAV barriers the runtime will validate that, if the resource is non-NULL, the resource has the
		/// D3D12_RESOURCE_STATE_UNORDERED_ACCESS bind flag set.
		/// </para>
		/// <para>Validation failure causes <c>ID3D12GraphicsCommandList::Close</c> to return E_INVALIDARG.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>The debug layer normally issues errors where runtime validation fails:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// If a subresource transition in a command list is inconsistent with previous transitions in the same command list.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// If a resource is used without first calling <b>ResourceBarrier</b> to put the resource into the correct state.
		/// </description>
		/// </item>
		/// <item>
		/// <description>If a resource is illegally bound for read and write at the same time.</description>
		/// </item>
		/// <item>
		/// <description>
		/// If the <i>before</i> states passed to the <b>ResourceBarrier</b> do not match the <i>after</i> states of previous calls to
		/// <b>ResourceBarrier</b>, including the aliasing case.
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// Whereas the debug layer attempts to validate the runtime rules, it operates conservatively so that debug layer errors are real
		/// errors, and in some cases real errors may not produce debug layer errors.
		/// </para>
		/// <para>The debug layer will issue warnings in the following cases:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>All of the cases where the D3D12 debug layer would issues warnings for <c>ID3D12GraphicsCommandList::ResourceBarrier</c>.</description>
		/// </item>
		/// <item>
		/// <description>
		/// If a depth buffer is used in a non-read-only mode while the resource has the D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE usage
		/// bit set.
		/// </description>
		/// </item>
		/// </list>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier void
		// ResourceBarrier( [in] UINT NumBarriers, [in] const D3D12_RESOURCE_BARRIER *pBarriers );
		[PreserveSig]
		new void ResourceBarrier(int NumBarriers, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_RESOURCE_BARRIER[] pBarriers);

		/// <summary>Executes a bundle.</summary>
		/// <param name="pCommandList">
		/// <para>Type: <b><c>ID3D12GraphicsCommandList</c>*</b></para>
		/// <para>Specifies the <c>ID3D12GraphicsCommandList</c> that determines the bundle to be executed.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Bundles inherit all state from the parent command list on which <b>ExecuteBundle</b> is called, except the pipeline state object
		/// and primitive topology. All of the state that is set in a bundle will affect the state of the parent command list. Note that
		/// <b>ExecuteBundle</b> is not a predicated operation.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>
		/// The runtime will validate that the "callee" is a bundle and that the "caller" is a direct command list. The runtime will also
		/// validate that the bundle has been closed. If the contract is violated, the runtime will silently drop the call. Validation
		/// failure will result in <c>Close</c> returning E_INVALIDARG.
		/// </para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>
		/// The debug layer will issue a warning in the same cases where the runtime will fail. The debug layer will issue a warning if a
		/// predicate is set when <c>ExecuteCommandList</c> is called. Also, the debug layer will issue an error if it detects that any
		/// resource reference by the command list has been destroyed.
		/// </para>
		/// <para>
		/// The debug layer will also validate that the command allocator associated with the bundle has not been reset since <c>Close</c>
		/// was called on the command list. This validation occurs at <b>ExecuteBundle</b> time, and when the parent command list is
		/// executed on a command queue. Examples The <c>D3D12Bundles</c> sample uses <b>ID3D12GraphicsCommandList::ExecuteBundle</b> as follows:
		/// </para>
		/// <para>
		/// <c>void D3D12Bundles::PopulateCommandList(FrameResource* pFrameResource) { // Command list allocators can only be reset when the
		/// associated // command lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a
		/// particular command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_pCurrentFrameResource-&gt;m_commandAllocator.Get(), m_pipelineState1.Get())); // Set
		/// necessary state. m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = {
		/// m_cbvSrvHeap.Get(), m_samplerHeap.Get() }; m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// m_commandList-&gt;RSSetViewports(1, &amp;m_viewport); m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate
		/// that the back buffer will be used as a render target. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT,
		/// D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;ClearDepthStencilView(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0,
		/// nullptr); if (UseBundles) { // Execute the prebuilt bundle. m_commandList-&gt;ExecuteBundle(pFrameResource-&gt;m_bundle.Get());
		/// } else { // Populate a new command list. pFrameResource-&gt;PopulateCommandList(m_commandList.Get(), m_pipelineState1.Get(),
		/// m_pipelineState2.Get(), m_currentFrameResourceIndex, m_numIndices, &amp;m_indexBufferView, &amp;m_vertexBufferView,
		/// m_cbvSrvHeap.Get(), m_cbvSrvDescriptorSize, m_samplerHeap.Get(), m_rootSignature.Get()); } // Indicate that the back buffer will
		/// now be used to present. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET,
		/// D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-executebundle void ExecuteBundle(
		// [in] ID3D12GraphicsCommandList *pCommandList );
		[PreserveSig]
		new void ExecuteBundle([In] ID3D12GraphicsCommandList pCommandList);

		/// <summary>Changes the currently bound descriptor heaps that are associated with a command list.</summary>
		/// <param name="NumDescriptorHeaps">
		/// <para>Type: [in] <b><c>UINT</c></b></para>
		/// <para>Number of descriptor heaps to bind.</para>
		/// </param>
		/// <param name="ppDescriptorHeaps">
		/// <para>Type: [in] <b><c>ID3D12DescriptorHeap</c>*</b></para>
		/// <para>A pointer to an array of <c>ID3D12DescriptorHeap</c> objects for the heaps to set on the command list.</para>
		/// <para>You can only bind descriptor heaps of type <c><b>D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV</b></c> and <c><b>D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER</b></c>.</para>
		/// <para>
		/// Only one descriptor heap of each type can be set at one time, which means a maximum of 2 heaps (one sampler, one CBV/SRV/UAV)
		/// can be set at one time.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>SetDescriptorHeaps</b> can be called on a bundle, but the bundle descriptor heaps must match the calling command list
		/// descriptor heap. For more information on bundle restrictions, refer to <c>Creating and Recording Command Lists and Bundles</c>.
		/// </para>
		/// <para>All previously set heaps are unset by the call. At most one heap of each shader-visible type can be set in the call.</para>
		/// <para>
		/// Changing descriptor heaps can incur a pipeline flush on some hardware. Because of this, it is recommended to use a single
		/// shader-visible heap of each type, and set it once per frame, rather than regularly changing the bound descriptor heaps. Instead,
		/// use <c><b>ID3D12Device::CopyDescriptors</b></c> and <c><b>ID3D12Device::CopyDescriptorsSimple</b></c> to copy the required
		/// descriptors from shader-opaque heaps to the single shader-visible heap as required during rendering.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps void
		// SetDescriptorHeaps( UINT NumDescriptorHeaps, ID3D12DescriptorHeap * const *ppDescriptorHeaps );
		[PreserveSig]
		new void SetDescriptorHeaps(int NumDescriptorHeaps, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12DescriptorHeap[] ppDescriptorHeaps);

		/// <summary>Sets the layout of the compute root signature.</summary>
		/// <param name="pRootSignature">
		/// <para>Type: <b><c>ID3D12RootSignature</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12RootSignature</c> object.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootsignature void
		// SetComputeRootSignature( [in, optional] ID3D12RootSignature *pRootSignature );
		[PreserveSig]
		new void SetComputeRootSignature([In, Optional] ID3D12RootSignature? pRootSignature);

		/// <summary>Sets the layout of the graphics root signature.</summary>
		/// <param name="pRootSignature">
		/// <para>Type: <b><c>ID3D12RootSignature</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12RootSignature</c> object.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootsignature void
		// SetGraphicsRootSignature( [in, optional] ID3D12RootSignature *pRootSignature );
		[PreserveSig]
		new void SetGraphicsRootSignature([In, Optional] ID3D12RootSignature? pRootSignature);

		/// <summary>Sets a descriptor table into the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BaseDescriptor">
		/// <para>Type: <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A GPU_descriptor_handle object for the base descriptor to set.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable void
		// SetComputeRootDescriptorTable( [in] UINT RootParameterIndex, [in] D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor );
		[PreserveSig]
		new void SetComputeRootDescriptorTable(uint RootParameterIndex, D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);

		/// <summary>Sets a descriptor table into the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BaseDescriptor">
		/// <para>Type: <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A GPU_descriptor_handle object for the base descriptor to set.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable void
		// SetGraphicsRootDescriptorTable( [in] UINT RootParameterIndex, [in] D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor );
		[PreserveSig]
		new void SetGraphicsRootDescriptorTable(uint RootParameterIndex, D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);

		/// <summary>Sets a constant in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="SrcData">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The source data for the constant to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The offset, in 32-bit values, to set the constant in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputeroot32bitconstant void
		// SetComputeRoot32BitConstant( [in] UINT RootParameterIndex, [in] UINT SrcData, [in] UINT DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetComputeRoot32BitConstant(uint RootParameterIndex, uint SrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a constant in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="SrcData">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The source data for the constant to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The offset, in 32-bit values, to set the constant in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsroot32bitconstant void
		// SetGraphicsRoot32BitConstant( [in] UINT RootParameterIndex, [in] UINT SrcData, [in] UINT DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetGraphicsRoot32BitConstant(uint RootParameterIndex, uint SrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a group of constants in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="Num32BitValuesToSet">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of constants to set in the root signature.</para>
		/// </param>
		/// <param name="pSrcData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>The source data for the group of constants to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The offset, in 32-bit values, to set the first constant of the group in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputeroot32bitconstants void
		// SetComputeRoot32BitConstants( [in] UINT RootParameterIndex, [in] UINT Num32BitValuesToSet, [in] const void *pSrcData, [in] UINT
		// DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetComputeRoot32BitConstants(uint RootParameterIndex, uint Num32BitValuesToSet,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] uint[] pSrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a group of constants in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="Num32BitValuesToSet">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of constants to set in the root signature.</para>
		/// </param>
		/// <param name="pSrcData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>The source data for the group of constants to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The offset, in 32-bit values, to set the first constant of the group in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsroot32bitconstants void
		// SetGraphicsRoot32BitConstants( [in] UINT RootParameterIndex, [in] UINT Num32BitValuesToSet, [in] const void *pSrcData, [in] UINT
		// DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetGraphicsRoot32BitConstants(uint RootParameterIndex, uint Num32BitValuesToSet,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] uint[] pSrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a CPU descriptor handle for the constant buffer in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>Specifies the D3D12_GPU_VIRTUAL_ADDRESS of the constant buffer.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootconstantbufferview
		// void SetComputeRootConstantBufferView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetComputeRootConstantBufferView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the constant buffer in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the constant buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootconstantbufferview
		// void SetGraphicsRootConstantBufferView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetGraphicsRootConstantBufferView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the shader resource in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootshaderresourceview
		// void SetComputeRootShaderResourceView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetComputeRootShaderResourceView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the shader resource in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the Buffer. Textures are not supported. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootshaderresourceview
		// void SetGraphicsRootShaderResourceView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetGraphicsRootShaderResourceView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the unordered-access-view resource in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootunorderedaccessview
		// void SetComputeRootUnorderedAccessView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetComputeRootUnorderedAccessView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the unordered-access-view resource in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootunorderedaccessview
		// void SetGraphicsRootUnorderedAccessView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetGraphicsRootUnorderedAccessView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets the view for the index buffer.</summary>
		/// <param name="pView">
		/// <para>Type: <b>const <c>D3D12_INDEX_BUFFER_VIEW</c>*</b></para>
		/// <para>
		/// The view specifies the index buffer's address, size, and <c>DXGI_FORMAT</c>, as a pointer to a <c>D3D12_INDEX_BUFFER_VIEW</c> structure.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Only one index buffer can be bound to the graphics pipeline at any one time. Examples The <c>D3D12Bundles</c> sample uses
		/// <b>ID3D12GraphicsCommandList::IASetIndexBuffer</b> as follows:
		/// </para>
		/// <para>
		/// <c>void FrameResource::PopulateCommandList(ID3D12GraphicsCommandList* pCommandList, ID3D12PipelineState* pPso1,
		/// ID3D12PipelineState* pPso2, UINT frameResourceIndex, UINT numIndices, D3D12_INDEX_BUFFER_VIEW* pIndexBufferViewDesc,
		/// D3D12_VERTEX_BUFFER_VIEW* pVertexBufferViewDesc, ID3D12DescriptorHeap* pCbvSrvDescriptorHeap, UINT cbvSrvDescriptorSize,
		/// ID3D12DescriptorHeap* pSamplerDescriptorHeap, ID3D12RootSignature* pRootSignature) { // If the root signature matches the root
		/// signature of the caller, then // bindings are inherited, otherwise the bind space is reset.
		/// pCommandList-&gt;SetGraphicsRootSignature(pRootSignature); ID3D12DescriptorHeap* ppHeaps[] = { pCbvSrvDescriptorHeap,
		/// pSamplerDescriptorHeap }; pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// pCommandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		/// pCommandList-&gt;IASetIndexBuffer(pIndexBufferViewDesc); pCommandList-&gt;IASetVertexBuffers(0, 1, pVertexBufferViewDesc);
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(0, pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(1, pSamplerDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart()); //
		/// Calculate the descriptor offset due to multiple frame resources. // 1 SRV + how many CBVs we have currently. UINT
		/// frameResourceDescriptorOffset = 1 + (frameResourceIndex * m_cityRowCount * m_cityColumnCount); CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvSrvHandle(pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart(), frameResourceDescriptorOffset,
		/// cbvSrvDescriptorSize); BOOL usePso1 = TRUE; for (UINT i = 0; i &lt; m_cityRowCount; i++) { for (UINT j = 0; j &lt;
		/// m_cityColumnCount; j++) { // Alternate which PSO to use; the pixel shader is different on // each just as a PSO setting
		/// demonstration. pCommandList-&gt;SetPipelineState(usePso1 ? pPso1 : pPso2); usePso1 = !usePso1; // Set this city's CBV table and
		/// move to the next descriptor. pCommandList-&gt;SetGraphicsRootDescriptorTable(2, cbvSrvHandle);
		/// cbvSrvHandle.Offset(cbvSrvDescriptorSize); pCommandList-&gt;DrawIndexedInstanced(numIndices, 1, 0, 0, 0); } } }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-iasetindexbuffer void
		// IASetIndexBuffer( [in, optional] const D3D12_INDEX_BUFFER_VIEW *pView );
		[PreserveSig]
		new void IASetIndexBuffer([In, Optional] StructPointer<D3D12_INDEX_BUFFER_VIEW> pView);

		/// <summary>Sets a CPU descriptor handle for the vertex buffers.</summary>
		/// <param name="StartSlot">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Index into the device's zero-based array to begin setting vertex buffers.</para>
		/// </param>
		/// <param name="NumViews">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of views in the <i>pViews</i> array.</para>
		/// </param>
		/// <param name="pViews">
		/// <para>Type: <b>const <c>D3D12_VERTEX_BUFFER_VIEW</c>*</b></para>
		/// <para>Specifies the vertex buffer views in an array of <c>D3D12_VERTEX_BUFFER_VIEW</c> structures.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-iasetvertexbuffers void
		// IASetVertexBuffers( [in] UINT StartSlot, [in] UINT NumViews, [in, optional] const D3D12_VERTEX_BUFFER_VIEW *pViews );
		[PreserveSig]
		new void IASetVertexBuffers(uint StartSlot, int NumViews, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_VERTEX_BUFFER_VIEW[] pViews);

		/// <summary>Sets the stream output buffer views.</summary>
		/// <param name="StartSlot">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Index into the device's zero-based array to begin setting stream output buffers.</para>
		/// </param>
		/// <param name="NumViews">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of entries in the <i>pViews</i> array.</para>
		/// </param>
		/// <param name="pViews">
		/// <para>Type: <b>const <c>D3D12_STREAM_OUTPUT_BUFFER_VIEW</c>*</b></para>
		/// <para>Specifies an array of <c>D3D12_STREAM_OUTPUT_BUFFER_VIEW</c> structures.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-sosettargets void SOSetTargets( [in]
		// UINT StartSlot, [in] UINT NumViews, [in, optional] const D3D12_STREAM_OUTPUT_BUFFER_VIEW *pViews );
		[PreserveSig]
		new void SOSetTargets(uint StartSlot, int NumViews, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_STREAM_OUTPUT_BUFFER_VIEW[] pViews);

		/// <summary>Sets CPU descriptor handles for the render targets and depth stencil.</summary>
		/// <param name="NumRenderTargetDescriptors">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// The number of entries in the <i>pRenderTargetDescriptors</i> array (ranges between 0 and
		/// <b>D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT</b>). If this parameter is nonzero, the number of entries in the array to which
		/// pRenderTargetDescriptors points must equal the number in this parameter.
		/// </para>
		/// </param>
		/// <param name="pRenderTargetDescriptors">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>
		/// Specifies an array of <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> structures that describe the CPU descriptor handles that represents the
		/// start of the heap of render target descriptors. If this parameter is NULL and NumRenderTargetDescriptors is 0, no render targets
		/// are bound.
		/// </para>
		/// </param>
		/// <param name="RTsSingleHandleToDescriptorRange">
		/// <para>Type: <b>BOOL</b></para>
		/// <para>
		/// <b>True</b> means the handle passed in is the pointer to a contiguous range of <i>NumRenderTargetDescriptors</i> descriptors.
		/// This case is useful if the set of descriptors to bind already happens to be contiguous in memory (so all thats needed is a
		/// handle to the first one). For example, if <i>NumRenderTargetDescriptors</i> is 3 then the memory layout is taken as follows:
		/// </para>
		/// <para>In this case the driver dereferences the handle and then increments the memory being pointed to.</para>
		/// <para>
		/// <b>False</b> means that the handle is the first of an array of <i>NumRenderTargetDescriptors</i> handles. The false case allows
		/// an application to bind a set of descriptors from different locations at once. Again assuming that
		/// <i>NumRenderTargetDescriptors</i> is 3, the memory layout is taken as follows:
		/// </para>
		/// <para>In this case the driver dereferences three handles that are expected to be adjacent to each other in memory.</para>
		/// </param>
		/// <param name="pDepthStencilDescriptor">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>
		/// A pointer to a <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> structure that describes the CPU descriptor handle that represents the start
		/// of the heap that holds the depth stencil descriptor. If this parameter is NULL, no depth stencil descriptor is bound.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets void
		// OMSetRenderTargets( [in] UINT NumRenderTargetDescriptors, [in, optional] const D3D12_CPU_DESCRIPTOR_HANDLE
		// *pRenderTargetDescriptors, [in] BOOL RTsSingleHandleToDescriptorRange, [in, optional] const D3D12_CPU_DESCRIPTOR_HANDLE
		// *pDepthStencilDescriptor );
		[PreserveSig]
		new void OMSetRenderTargets(uint NumRenderTargetDescriptors,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_CPU_DESCRIPTOR_HANDLE[]? pRenderTargetDescriptors,
			bool RTsSingleHandleToDescriptorRange, [In, Optional] StructPointer<D3D12_CPU_DESCRIPTOR_HANDLE> pDepthStencilDescriptor);

		/// <summary>Clears the depth-stencil resource.</summary>
		/// <param name="DepthStencilView">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap for the depth stencil to be cleared.</para>
		/// </param>
		/// <param name="ClearFlags">
		/// <para>Type: <b><c>D3D12_CLEAR_FLAGS</c></b></para>
		/// <para>
		/// A combination of <c>D3D12_CLEAR_FLAGS</c> values that are combined by using a bitwise OR operation. The resulting value
		/// identifies the type of data to clear (depth buffer, stencil buffer, or both).
		/// </para>
		/// </param>
		/// <param name="Depth">
		/// <para>Type: <b><c>FLOAT</c></b></para>
		/// <para>A value to clear the depth buffer with. This value will be clamped between 0 and 1.</para>
		/// </param>
		/// <param name="Stencil">
		/// <para>Type: <b>UINT8</b></para>
		/// <para>A value to clear the stencil buffer with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of rectangles in the array that the <i>pRects</i> parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: <b>const <b>D3D12_RECT</b>*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearDepthStencilView</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>Only direct and bundle command lists support this operation.</para>
		/// <para>
		/// <b>ClearDepthStencilView</b> may be used to initialize resources which alias the same heap memory. See
		/// <c>CreatePlacedResource</c> for more details.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>For floating-point inputs, the runtime will set denormalized values to 0 (while preserving NANs).</para>
		/// <para>Validation failure will result in the call to <c>Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>The debug layer will issue errors if the input colors are denormalized.</para>
		/// <para>
		/// The debug layer will issue an error if the subresources referenced by the view are not in the appropriate state. For
		/// <b>ClearDepthStencilView</b>, the state must be in the state <c>D3D12_RESOURCE_STATE_DEPTH_WRITE</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-cleardepthstencilview void
		// ClearDepthStencilView( [in] D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView, [in] D3D12_CLEAR_FLAGS ClearFlags, [in] FLOAT Depth,
		// [in] UINT8 Stencil, [in] UINT NumRects, [in] const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearDepthStencilView([In] D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView, D3D12_CLEAR_FLAGS ClearFlags, float Depth, byte Stencil,
			[Optional] int NumRects, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] RECT[]? pRects);

		/// <summary>Sets all the elements in a render target to one value.</summary>
		/// <param name="RenderTargetView">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// Specifies a D3D12_CPU_DESCRIPTOR_HANDLE structure that describes the CPU descriptor handle that represents the start of the heap
		/// for the render target to be cleared.
		/// </para>
		/// </param>
		/// <param name="ColorRGBA">
		/// <para>Type: <b>const FLOAT[4]</b></para>
		/// <para>A 4-component array that represents the color to fill the render target with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of rectangles in the array that the <i>pRects</i> parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: <b>const D3D12_RECT*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearRenderTargetView</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>ClearRenderTargetView</b> may be used to initialize resources which alias the same heap memory. See
		/// <c>CreatePlacedResource</c> for more details.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>For floating-point inputs, the runtime will set denormalized values to 0 (while preserving NANs).</para>
		/// <para>Validation failure will result in the call to <c>Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>The debug layer will issue errors if the input colors are denormalized.</para>
		/// <para>
		/// The debug layer will issue an error if the subresources referenced by the view are not in the appropriate state. For
		/// <b>ClearRenderTargetView</b>, the state must be <c>D3D12_RESOURCE_STATE_RENDER_TARGET</c>. Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::ClearRenderTargetView</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>The <c>D3D12Multithreading</c> sample uses <b>ID3D12GraphicsCommandList::ClearRenderTargetView</b> as follows:</para>
		/// <para><c>// Frame resources. FrameResource* m_frameResources[FrameCount]; FrameResource* m_pCurrentFrameResource; int m_currentFrameResourceIndex;</c></para>
		/// <para>
		/// <c>// Assemble the CommandListPre command list. void D3D12Multithreading::BeginFrame() { m_pCurrentFrameResource-&gt;Init(); //
		/// Indicate that the back buffer will be used as a render target.
		/// m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT,
		/// D3D12_RESOURCE_STATE_RENDER_TARGET)); // Clear the render target and depth stencil. const float clearColor[] = { 0.0f, 0.0f,
		/// 0.0f, 1.0f }; CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex,
		/// m_rtvDescriptorSize); m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ClearRenderTargetView(rtvHandle,
		/// clearColor, 0, nullptr);
		/// m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ClearDepthStencilView(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(),
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
		/// ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;Close()); } // Assemble the CommandListMid command
		/// list. void D3D12Multithreading::MidFrame() { // Transition our shadow map from the shadow pass to readable in the scene pass.
		/// m_pCurrentFrameResource-&gt;SwapBarriers();
		/// ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandLists[CommandListMid]-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearrendertargetview void
		// ClearRenderTargetView( [in] D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView, [in] const FLOAT [4] ColorRGBA, [in] UINT NumRects,
		// [in] const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearRenderTargetView([In] D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] float[] ColorRGBA,
			[Optional] int NumRects, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] RECT[]? pRects);

		/// <summary>
		/// <para>Sets all the elements in a unordered-access view (UAV) to the specified integer values.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This behaves like a compute operation in that it isn't ordered with respect to surrounding work such as <b>Dispatch</b> calls.
		/// To ensure ordering, barrier calls must be issued before and/or after the <b>ClearUnorderedAccessViewXxx</b> call as needed. It
		/// might appear on some drivers that such barriers aren't necessary. But implicit barriers are not a spec guarantee; so they can't
		/// be relied upon. This is in contrast to <b>ClearDepthStencilView</b> and <b>ClearRenderTargetView</b> which (like <b>DrawXxx</b>
		/// commands), respect command list ordering.
		/// </para>
		/// </para>
		/// </summary>
		/// <param name="ViewGPUHandleInCurrentHeap">
		/// <para>Type: [in] <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_GPU_DESCRIPTOR_HANDLE</c> that references an initialized descriptor for the unordered-access view (UAV) that is to be
		/// cleared. This descriptor must be in a shader-visible descriptor heap, which must be set on the command list via <c>SetDescriptorHeaps</c>.
		/// </para>
		/// </param>
		/// <param name="ViewCPUHandle">
		/// <para>Type: [in] <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> in a non-shader visible descriptor heap that references an initialized descriptor for the
		/// unordered-access view (UAV) that is to be cleared.
		/// </para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This descriptor must not be in a shader-visible descriptor heap. This is to allow drivers that implement the clear as a
		/// fixed-function hardware operation (rather than as a dispatch) to efficiently read from the descriptor, as shader-visible heaps
		/// may be created in <b>WRITE_BACK</b> memory (similar to <b>D3D12_HEAP_TYPE_UPLOAD</b> heap types), and CPU reads from this type
		/// of memory are prohibitively slow.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="pResource">
		/// <para>Type: [in] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the unordered-access-view (UAV) resource to clear.</para>
		/// </param>
		/// <param name="Values">
		/// <para>Type: [in] <b>const UINT[4]</b></para>
		/// <para>A 4-component array that containing the values to fill the unordered-access-view resource with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The number of rectangles in the array that the pRects parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: [in] <b>const <c>D3D12_RECT</c>*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearUnorderedAccessViewUint</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>Runtime validation</para>
		/// <para>Validation failure results in the call to <c>ID3D12GraphicsCommandList::Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para>Debug layer</para>
		/// <para>The debug layer issues errors if the input values are outside of a normalized range.</para>
		/// <para>
		/// The debug layer issues an error if the subresources referenced by the view aren't in the appropriate state. For
		/// <b>ClearUnorderedAccessViewUint</b>, the state must be <c>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewuint void
		// ClearUnorderedAccessViewUint( D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
		// ID3D12Resource *pResource, const UINT [4] Values, UINT NumRects, const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearUnorderedAccessViewUint([In] D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, [In] D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
			[In] ID3D12Resource pResource, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] uint[] Values, int NumRects,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] RECT[] pRects);

		/// <summary>
		/// <para>Sets all of the elements in an unordered-access view (UAV) to the specified float values.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This behaves like a compute operation in that it isn't ordered with respect to surrounding work such as <b>Dispatch</b> calls.
		/// To ensure ordering, barrier calls must be issued before and/or after the <b>ClearUnorderedAccessViewXxx</b> call as needed. It
		/// might appear on some drivers that such barriers aren't necessary. But implicit barriers are not a spec guarantee; so they can't
		/// be relied upon. This is in contrast to <b>ClearDepthStencilView</b> and <b>ClearRenderTargetView</b> which (like <b>DrawXxx</b>
		/// commands), respect command list ordering.
		/// </para>
		/// </para>
		/// </summary>
		/// <param name="ViewGPUHandleInCurrentHeap">
		/// <para>Type: [in] <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_GPU_DESCRIPTOR_HANDLE</c> that references an initialized descriptor for the unordered-access view (UAV) that is to be
		/// cleared. This descriptor must be in a shader-visible descriptor heap, which must be set on the command list via <c>SetDescriptorHeaps</c>.
		/// </para>
		/// </param>
		/// <param name="ViewCPUHandle">
		/// <para>Type: [in] <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> in a non-shader visible descriptor heap that references an initialized descriptor for the
		/// unordered-access view (UAV) that is to be cleared.
		/// </para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This descriptor must not be in a shader-visible descriptor heap. This is to allow drivers that implement the clear as a
		/// fixed-function hardware operation (rather than as a dispatch) to efficiently read from the descriptor, as shader-visible heaps
		/// may be created in <b>WRITE_BACK</b> memory (similar to <b>D3D12_HEAP_TYPE_UPLOAD</b> heap types), and CPU reads from this type
		/// of memory are prohibitively slow.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="pResource">
		/// <para>Type: [in] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the unordered-access-view (UAV) resource to clear.</para>
		/// </param>
		/// <param name="Values">
		/// <para>Type: [in] <b>const FLOAT[4]</b></para>
		/// <para>A 4-component array that containing the values to fill the unordered-access-view resource with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The number of rectangles in the array that the pRects parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: [in] <b>const <c>D3D12_RECT</c>*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearUnorderedAccessViewFloat</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>Runtime validation</para>
		/// <para>For floating-point inputs, the runtime sets denormalized values to 0 (while preserving NANs).</para>
		/// <para>If you want to clear the UAV to a specific bit pattern, consider using <c>ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint</c>.</para>
		/// <para>Validation failure results in the call to <c>ID3D12GraphicsCommandList::Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para>Debug layer</para>
		/// <para>The debug layer issues errors if the input values are outside of a normalized range.</para>
		/// <para>
		/// The debug layer issues an error if the subresources referenced by the view aren't in the appropriate state. For
		/// <b>ClearUnorderedAccessViewFloat</b>, the state must be <c>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewfloat void
		// ClearUnorderedAccessViewFloat( D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
		// ID3D12Resource *pResource, const FLOAT [4] Values, UINT NumRects, const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearUnorderedAccessViewFloat([In] D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, [In] D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
			[In] ID3D12Resource pResource, [In, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] float[] Values, int NumRects,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] RECT[] pRects);

		/// <summary>
		/// Indicates that the contents of a resource don't need to be preserved. The function may re-initialize resource metadata in some cases.
		/// </summary>
		/// <param name="pResource">
		/// <para>Type: [in] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface for the resource to discard.</para>
		/// </param>
		/// <param name="pRegion">
		/// <para>Type: [in, optional] <b>const <c>D3D12_DISCARD_REGION</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DISCARD_REGION</c> structure that describes details for the discard-resource operation.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>The semantics of <b>DiscardResource</b> change based on the command list type.</para>
		/// <para>For <c>D3D12_COMMAND_LIST_TYPE_DIRECT</c>, the following two rules apply:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// When a resource has the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> flag, <b>DiscardResource</b> must be called when the
		/// discarded subresource regions are in the <c>D3D12_RESOURCE_STATE_RENDER_TARGET</c> resource barrier state.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// When a resource has the <c>D3D12_RESOURCE_FLAG _ALLOW_DEPTH_STENCIL</c> flag, <b>DiscardResource</b> must be called when the
		/// discarded subresource regions are in the <c>D3D12_RESOURCE_STATE_DEPTH_WRITE</c>.
		/// </description>
		/// </item>
		/// </list>
		/// <para>For <c>D3D12_COMMAND_LIST_TYPE_COMPUTE</c>, the following rule applies:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// The resource must have the <c>D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS</c> flag, and <b>DiscardResource</b> must be called
		/// when the discarded subresource regions are in the <c>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</c> resource barrier state.
		/// </description>
		/// </item>
		/// </list>
		/// <para><b>DiscardResource</b> is not supported on command lists with either <c>D3D12_COMMAND_LIST_TYPE_BUNDLE</c> nor <b>D3D12_COMMAND_LIST_TYPE_COPY</b>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-discardresource void
		// DiscardResource( ID3D12Resource *pResource, const D3D12_DISCARD_REGION *pRegion );
		[PreserveSig]
		new void DiscardResource([In] ID3D12Resource pResource, [In, Optional] StructPointer<D3D12_DISCARD_REGION> pRegion);

		/// <summary>Starts a query running.</summary>
		/// <param name="pQueryHeap">
		/// <para>Type: <b><c>ID3D12QueryHeap</c>*</b></para>
		/// <para>Specifies the <c>ID3D12QueryHeap</c> containing the query.</para>
		/// </param>
		/// <param name="Type">
		/// <para>Type: <b><c>D3D12_QUERY_TYPE</c></b></para>
		/// <para>Specifies one member of <c>D3D12_QUERY_TYPE</c>.</para>
		/// </param>
		/// <param name="Index">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the index of the query within the query heap.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// See <c>Queries</c> for more information about D3D12 queries. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12GraphicsCommandList::BeginQuery</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void
		/// D3D12PredicationQueries::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); // Draw the quads and perform the occlusion query. { CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); // Draw the far quad conditionally based on the result of the occlusion query // from the previous
		/// frame. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad); m_commandList-&gt;SetPredication(m_queryResult.Get(), 0,
		/// D3D12_PREDICATION_OP_EQUAL_ZERO); m_commandList-&gt;DrawInstanced(4, 1, 0, 0); // Disable predication and always draw the near
		/// quad. m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
		/// m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad); m_commandList-&gt;DrawInstanced(4, 1, 4, 0); // Run the
		/// occlusion query with the bounding box quad. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
		/// m_commandList-&gt;SetPipelineState(m_queryState.Get()); m_commandList-&gt;BeginQuery(m_queryHeap.Get(),
		/// D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
		/// m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); // Resolve the occlusion query and store
		/// the results in the query result buffer // to be used on the subsequent frame. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION,
		/// D3D12_RESOURCE_STATE_COPY_DEST)); m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1,
		/// m_queryResult.Get(), 0); m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(),
		/// D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION)); } // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-beginquery void BeginQuery( [in]
		// ID3D12QueryHeap *pQueryHeap, [in] D3D12_QUERY_TYPE Type, [in] UINT Index );
		[PreserveSig]
		new void BeginQuery([In] ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);

		/// <summary>Ends a running query.</summary>
		/// <param name="pQueryHeap">
		/// <para>Type: <b><c>ID3D12QueryHeap</c>*</b></para>
		/// <para>Specifies the <c>ID3D12QueryHeap</c> containing the query.</para>
		/// </param>
		/// <param name="Type">
		/// <para>Type: <b><c>D3D12_QUERY_TYPE</c></b></para>
		/// <para>Specifies one member of <c>D3D12_QUERY_TYPE</c>.</para>
		/// </param>
		/// <param name="Index">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the index of the query in the query heap.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// See <c>Queries</c> for more information about D3D12 queries. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12GraphicsCommandList::EndQuery</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void
		/// D3D12PredicationQueries::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); // Draw the quads and perform the occlusion query. { CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); // Draw the far quad conditionally based on the result of the occlusion query // from the previous
		/// frame. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad); m_commandList-&gt;SetPredication(m_queryResult.Get(), 0,
		/// D3D12_PREDICATION_OP_EQUAL_ZERO); m_commandList-&gt;DrawInstanced(4, 1, 0, 0); // Disable predication and always draw the near
		/// quad. m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
		/// m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad); m_commandList-&gt;DrawInstanced(4, 1, 4, 0); // Run the
		/// occlusion query with the bounding box quad. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
		/// m_commandList-&gt;SetPipelineState(m_queryState.Get()); m_commandList-&gt;BeginQuery(m_queryHeap.Get(),
		/// D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
		/// m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); // Resolve the occlusion query and store
		/// the results in the query result buffer // to be used on the subsequent frame. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION,
		/// D3D12_RESOURCE_STATE_COPY_DEST)); m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1,
		/// m_queryResult.Get(), 0); m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(),
		/// D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION)); } // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-endquery void EndQuery( [in]
		// ID3D12QueryHeap *pQueryHeap, [in] D3D12_QUERY_TYPE Type, [in] UINT Index );
		[PreserveSig]
		new void EndQuery([In] ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);

		/// <summary>Extracts data from a query. <b>ResolveQueryData</b> works with all heap types (default, upload, and readback).</summary>
		/// <param name="pQueryHeap">
		/// <para>Type: <b><c>ID3D12QueryHeap</c>*</b></para>
		/// <para>Specifies the <c>ID3D12QueryHeap</c> containing the queries to resolve.</para>
		/// </param>
		/// <param name="Type">
		/// <para>Type: <b><c>D3D12_QUERY_TYPE</c></b></para>
		/// <para>Specifies the type of query, one member of <c>D3D12_QUERY_TYPE</c>.</para>
		/// </param>
		/// <param name="StartIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies an index of the first query to resolve.</para>
		/// </param>
		/// <param name="NumQueries">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of queries to resolve.</para>
		/// </param>
		/// <param name="pDestinationBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies an <c>ID3D12Resource</c> destination buffer, which must be in the state <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.</para>
		/// </param>
		/// <param name="AlignedDestinationBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies an alignment offset into the destination buffer. Must be a multiple of 8 bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>ResolveQueryData</b> performs a batched operation that writes query data into a destination buffer. Query data is written
		/// contiguously to the destination buffer, and the parameter.
		/// </para>
		/// <para>
		/// <b>ResolveQueryData</b> turns application-opaque query data in an application-opaque query heap into adapter-agnostic values
		/// usable by your application. Resolving queries within a heap that have not been completed (so have had
		/// <c><b>ID3D12GraphicsCommandList::BeginQuery</b></c> called for them, but not <c><b>ID3D12GraphicsCommandList::EndQuery</b></c>),
		/// or that have been uninitialized, results in undefined behavior and might cause device hangs or removal. The debug layer will
		/// emit an error if it detects an application has resolved incomplete or uninitialized queries.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>
		/// Resolving incomplete or uninitialized queries is undefined behavior because the driver might internally store GPUVAs or other
		/// data within unresolved queries. And so attempting to resolve these queries on uninitialized data could cause a page fault or
		/// device hang. Older versions of the debug layer didn't validate this behavior.
		/// </para>
		/// </para>
		/// <para>
		/// Binary occlusion queries write 64-bits per query. The least significant bit is either 0 (the object was entirely occluded) or 1
		/// (at least 1 sample of the object would have been drawn). The rest of the bits are 0. Occlusion queries write 64-bits per query.
		/// The value is the number of samples that passed testing. Timestamp queries write 64-bits per query, which is a tick value that
		/// must be compared to the respective command queue frequency (see <c>Timing</c>).
		/// </para>
		/// <para>
		/// Pipeline statistics queries write a <c><b>D3D12_QUERY_DATA_PIPELINE_STATISTICS</b></c> structure per query. All stream-out
		/// statistics queries write a <c><b>D3D12_QUERY_DATA_SO_STATISTICS</b></c> structure per query.
		/// </para>
		/// <para>The core runtime will validate the following.</para>
		/// <list type="bullet">
		/// <item>
		/// <description><i>StartIndex</i> and <i>NumQueries</i> are within range.</description>
		/// </item>
		/// <item>
		/// <description><i>AlignedDestinationBufferOffset</i> is a multiple of 8 bytes.</description>
		/// </item>
		/// <item>
		/// <description><i>DestinationBuffer</i> is a buffer.</description>
		/// </item>
		/// <item>
		/// <description>The written data will not overflow the output buffer.</description>
		/// </item>
		/// <item>
		/// <description>The query type must be supported by the command list type.</description>
		/// </item>
		/// <item>
		/// <description>The query type must be supported by the query heap.</description>
		/// </item>
		/// </list>
		/// <para>
		/// The debug layer will issue a warning if the destination buffer is not in the D3D12_RESOURCE_STATE_COPY_DEST state, or if any
		/// queries being resolved have not had <c><b>ID3D12GraphicsCommandList::EndQuery</b></c> called on them.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvequerydata void
		// ResolveQueryData( [in] ID3D12QueryHeap *pQueryHeap, [in] D3D12_QUERY_TYPE Type, [in] UINT StartIndex, [in] UINT NumQueries, [in]
		// ID3D12Resource *pDestinationBuffer, [in] UINT64 AlignedDestinationBufferOffset );
		[PreserveSig]
		new void ResolveQueryData([In] ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint StartIndex, uint NumQueries,
			[In] ID3D12Resource pDestinationBuffer, ulong AlignedDestinationBufferOffset);

		/// <summary>Sets a rendering predicate.</summary>
		/// <param name="pBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>
		/// The buffer, as an <c>ID3D12Resource</c>, which must be in the <c><b>D3D12_RESOURCE_STATE_PREDICATION</b></c> or
		/// <c><b>D3D21_RESOURCE_STATE_INDIRECT_ARGUMENT</b></c> state (both values are identical, and provided as aliases for clarity), or
		/// <b>NULL</b> to disable predication.
		/// </para>
		/// </param>
		/// <param name="AlignedBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The aligned buffer offset, as a UINT64.</para>
		/// </param>
		/// <param name="Operation">
		/// <para>Type: <b><c>D3D12_PREDICATION_OP</c></b></para>
		/// <para>Specifies a <c>D3D12_PREDICATION_OP</c>, such as D3D12_PREDICATION_OP_EQUAL_ZERO or D3D12_PREDICATION_OP_NOT_EQUAL_ZERO.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Use this method to denote that subsequent rendering and resource manipulation commands are not actually performed if the
		/// resulting predicate data of the predicate is equal to the operation specified.
		/// </para>
		/// <para>
		/// Unlike Direct3D 11, in Direct3D 12 predication state is not inherited by direct command lists, and predication is always
		/// respected (there are no predication hints). All direct command lists begin with predication disabled. Bundles do inherit
		/// predication state. It is legal for the same predicate to be bound multiple times.
		/// </para>
		/// <para>
		/// Illegal API calls will result in <c>Close</c> returning an error, or <c>ID3D12CommandQueue::ExecuteCommandLists</c> dropping the
		/// command list and removing the device.
		/// </para>
		/// <para>The debug layer will issue errors whenever the runtime validation fails.</para>
		/// <para>
		/// Refer to <c>Predication</c> for more information. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12GraphicsCommandList::SetPredication</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void
		/// D3D12PredicationQueries::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); // Draw the quads and perform the occlusion query. { CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); // Draw the far quad conditionally based on the result of the occlusion query // from the previous
		/// frame. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad); m_commandList-&gt;SetPredication(m_queryResult.Get(), 0,
		/// D3D12_PREDICATION_OP_EQUAL_ZERO); m_commandList-&gt;DrawInstanced(4, 1, 0, 0); // Disable predication and always draw the near
		/// quad. m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
		/// m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad); m_commandList-&gt;DrawInstanced(4, 1, 4, 0); // Run the
		/// occlusion query with the bounding box quad. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
		/// m_commandList-&gt;SetPipelineState(m_queryState.Get()); m_commandList-&gt;BeginQuery(m_queryHeap.Get(),
		/// D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
		/// m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); // Resolve the occlusion query and store
		/// the results in the query result buffer // to be used on the subsequent frame. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION,
		/// D3D12_RESOURCE_STATE_COPY_DEST)); m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1,
		/// m_queryResult.Get(), 0); m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(),
		/// D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION)); } // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setpredication void SetPredication(
		// [in, optional] ID3D12Resource *pBuffer, [in] UINT64 AlignedBufferOffset, [in] D3D12_PREDICATION_OP Operation );
		[PreserveSig]
		new void SetPredication([In, Optional] ID3D12Resource? pBuffer, ulong AlignedBufferOffset, D3D12_PREDICATION_OP Operation);

		/// <summary>Not intended to be called directly. Use the <c>PIX event runtime</c> to insert events into a command list.</summary>
		/// <param name="Metadata">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="Size">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This is a support method used internally by the PIX event runtime. It is not intended to be called directly.</para>
		/// <para>
		/// To insert instrumentation markers at the current location within a D3D12 command list, use the <b>PIXSetMarker</b> function.
		/// This is provided by the <c>WinPixEventRuntime</c> NuGet package.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setmarker void SetMarker( UINT
		// Metadata, [in, optional] const void *pData, UINT Size );
		[PreserveSig]
		new void SetMarker(uint Metadata, [In, Optional] IntPtr pData, uint Size);

		/// <summary>Not intended to be called directly. Use the <c>PIX event runtime</c> to insert events into a command list.</summary>
		/// <param name="Metadata">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="Size">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This is a support method used internally by the PIX event runtime. It is not intended to be called directly.</para>
		/// <para>
		/// To mark the start of an instrumentation region at the current location within a D3D12 command list, use the <b>PIXBeginEvent</b>
		/// function or <b>PIXScopedEvent</b> macro. These are provided by the <c>WinPixEventRuntime</c> NuGet package.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-beginevent void BeginEvent( UINT
		// Metadata, [in, optional] const void *pData, UINT Size );
		[PreserveSig]
		new void BeginEvent(uint Metadata, [In, Optional] IntPtr pData, uint Size);

		/// <summary>Not intended to be called directly. Use the <c>PIX event runtime</c> to insert events into a command list.</summary>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This is a support method used internally by the PIX event runtime. It is not intended to be called directly.</para>
		/// <para>
		/// To mark the end of an instrumentation region at the current location within a D3D12 command list, use the <b>PIXEndEvent</b>
		/// function or <b>PIXScopedEvent</b> macro. These are provided by the <c>WinPixEventRuntime</c> NuGet package.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-endevent void EndEvent();
		[PreserveSig]
		new void EndEvent();

		/// <summary>Apps perform indirect draws/dispatches using the <b>ExecuteIndirect</b> method.</summary>
		/// <param name="pCommandSignature">
		/// <para>Type: <b><c>ID3D12CommandSignature</c>*</b></para>
		/// <para>
		/// Specifies a <c>ID3D12CommandSignature</c>. The data referenced by <i>pArgumentBuffer</i> will be interpreted depending on the
		/// contents of the command signature. Refer to <c>Indirect Drawing</c> for the APIs that are used to create a command signature.
		/// </para>
		/// </param>
		/// <param name="MaxCommandCount">
		/// <para>Type: <b>UINT</b></para>
		/// <para>There are two ways that command counts can be specified:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// If <i>pCountBuffer</i> is not NULL, then <i>MaxCommandCount</i> specifies the maximum number of operations which will be
		/// performed. The actual number of operations to be performed are defined by the minimum of this value, and a 32-bit unsigned
		/// integer contained in <i>pCountBuffer</i> (at the byte offset specified by <i>CountBufferOffset</i>).
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// If <i>pCountBuffer</i> is NULL, the <i>MaxCommandCount</i> specifies the exact number of operations which will be performed.
		/// </description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pArgumentBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies one or more <c>ID3D12Resource</c> objects, containing the command arguments.</para>
		/// </param>
		/// <param name="ArgumentBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies an offset into <i>pArgumentBuffer</i> to identify the first command argument.</para>
		/// </param>
		/// <param name="pCountBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies a pointer to a <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="CountBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies a UINT64 that is the offset into <i>pCountBuffer</i>, identifying the argument count.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>The semantics of this API are defined with the following pseudo-code:</para>
		/// <para>Non-NULL pCountBuffer:</para>
		/// <para>
		/// <c>// Read draw count out of count buffer UINT CommandCount = pCountBuffer-&gt;ReadUINT32(CountBufferOffset); CommandCount =
		/// min(CommandCount, MaxCommandCount) // Get pointer to first Commanding argument BYTE* Arguments = pArgumentBuffer-&gt;GetBase() +
		/// ArgumentBufferOffset; for(UINT CommandIndex = 0; CommandIndex &lt; CommandCount; CommandIndex++) { // Interpret the data
		/// contained in *Arguments // according to the command signature pCommandSignature-&gt;Interpret(Arguments); Arguments +=
		/// pCommandSignature-&gt;GetByteStride(); }</c>
		/// </para>
		/// <para>NULL pCountBuffer:</para>
		/// <para>
		/// <c>// Get pointer to first Commanding argument BYTE* Arguments = pArgumentBuffer-&gt;GetBase() + ArgumentBufferOffset; for(UINT
		/// CommandIndex = 0; CommandIndex &lt; MaxCommandCount; CommandIndex++) { // Interpret the data contained in *Arguments //
		/// according to the command signature pCommandSignature-&gt;Interpret(Arguments); Arguments +=
		/// pCommandSignature-&gt;GetByteStride(); }</c>
		/// </para>
		/// <para>
		/// The debug layer will issue an error if either the count buffer or the argument buffer are not in the
		/// D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT state. The core runtime will validate:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description><i>CountBufferOffset</i> and <i>ArgumentBufferOffset</i> are 4-byte aligned</description>
		/// </item>
		/// <item>
		/// <description><i>pCountBuffer</i> and <i>pArgumentBuffer</i> are buffer resources (any heap type)</description>
		/// </item>
		/// <item>
		/// <description>
		/// The offset implied by <i>MaxCommandCount</i>, <i>ArgumentBufferOffset</i>, and the drawing program stride do not exceed the
		/// bounds of <i>pArgumentBuffer</i> (similarly for count buffer)
		/// </description>
		/// </item>
		/// <item>
		/// <description>The command list is a direct command list or a compute command list (not a copy or JPEG decode command list)</description>
		/// </item>
		/// <item>
		/// <description>The root signature of the command list matches the root signature of the command signature</description>
		/// </item>
		/// </list>
		/// <para>
		/// The functionality of two APIs from earlier versions of Direct3D, <c>DrawInstancedIndirect</c> and
		/// <c>DrawIndexedInstancedIndirect</c>, are encompassed by <b>ExecuteIndirect</b>.
		/// </para>
		/// <para><c></c><c></c><c></c> Bundles</para>
		/// <para>
		/// <b>ID3D12GraphicsCommandList::ExecuteIndirect</b> is allowed inside of bundle command lists only if all of the following are true:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>CountBuffer is NULL (CPU-specified count only).</description>
		/// </item>
		/// <item>
		/// <description>
		/// The command signature contains exactly one operation. This implies that the command signature does not contain root arguments
		/// changes, nor contain VB/IB binding changes.
		/// </description>
		/// </item>
		/// </list>
		/// <para><c></c><c></c><c></c> Obtaining buffer virtual addresses</para>
		/// <para>The <c>ID3D12Resource::GetGPUVirtualAddress</c> method enables an app to retrieve the GPU virtual address of a buffer.</para>
		/// <para>
		/// Apps are free to apply byte offsets to virtual addresses before placing them in an indirect argument buffer. Note that all of
		/// the D3D12 alignment requirements for VB/IB/CB still apply to the resulting GPU virtual address. Examples The
		/// <c>D3D12ExecuteIndirect</c> sample uses <b>ID3D12GraphicsCommandList::ExecuteIndirect</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Data structure to match the command signature used for ExecuteIndirect. struct IndirectCommand { D3D12_GPU_VIRTUAL_ADDRESS
		/// cbv; D3D12_DRAW_ARGUMENTS drawArguments; };</c>
		/// </para>
		/// <para>
		/// The call to <b>ExecuteIndirect</b> is near the end of this listing, below the comment "Draw the triangles that have not been culled."
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void D3D12ExecuteIndirect::PopulateCommandLists()
		/// { // Command list allocators can only be reset when the associated // command lists have finished execution on the GPU; apps
		/// should use // fences to determine GPU execution progress. ThrowIfFailed(m_computeCommandAllocators[m_frameIndex]-&gt;Reset());
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_computeCommandList-&gt;Reset(m_computeCommandAllocators[m_frameIndex].Get(), m_computeState.Get()));
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Record the compute
		/// commands that will cull triangles and prevent them from being processed by the vertex shader. if (m_enableCulling) { UINT
		/// frameDescriptorOffset = m_frameIndex * CbvSrvUavDescriptorCountPerFrame; D3D12_GPU_DESCRIPTOR_HANDLE cbvSrvUavHandle =
		/// m_cbvSrvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart();
		/// m_computeCommandList-&gt;SetComputeRootSignature(m_computeRootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = {
		/// m_cbvSrvUavHeap.Get() }; m_computeCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// m_computeCommandList-&gt;SetComputeRootDescriptorTable( SrvUavTable, CD3DX12_GPU_DESCRIPTOR_HANDLE(cbvSrvUavHandle, CbvSrvOffset
		/// + frameDescriptorOffset, m_cbvSrvUavDescriptorSize)); m_computeCommandList-&gt;SetComputeRoot32BitConstants(RootConstants, 4,
		/// reinterpret_cast&lt;void*&gt;(&amp;m_csRootConstants), 0); // Reset the UAV counter for this frame.
		/// m_computeCommandList-&gt;CopyBufferRegion(m_processedCommandBuffers[m_frameIndex].Get(), CommandBufferSizePerFrame,
		/// m_processedCommandBufferCounterReset.Get(), 0, sizeof(UINT)); D3D12_RESOURCE_BARRIER barrier =
		/// CD3DX12_RESOURCE_BARRIER::Transition(m_processedCommandBuffers[m_frameIndex].Get(), D3D12_RESOURCE_STATE_COPY_DEST,
		/// D3D12_RESOURCE_STATE_UNORDERED_ACCESS); m_computeCommandList-&gt;ResourceBarrier(1, &amp;barrier);
		/// m_computeCommandList-&gt;Dispatch(static_cast&lt;UINT&gt;(ceil(TriangleCount / float(ComputeThreadBlockSize))), 1, 1); }
		/// ThrowIfFailed(m_computeCommandList-&gt;Close()); // Record the rendering commands. { // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvSrvUavHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, m_enableCulling ? &amp;m_cullingScissorRect : &amp;m_scissorRect); // Indicate that the
		/// command buffer will be used for indirect drawing // and that the back buffer will be used as a render target.
		/// D3D12_RESOURCE_BARRIER barriers[2] = { CD3DX12_RESOURCE_BARRIER::Transition( m_enableCulling ?
		/// m_processedCommandBuffers[m_frameIndex].Get() : m_commandBuffer.Get(), m_enableCulling ? D3D12_RESOURCE_STATE_UNORDERED_ACCESS :
		/// D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT), CD3DX12_RESOURCE_BARRIER::Transition(
		/// m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET) };
		/// m_commandList-&gt;ResourceBarrier(_countof(barriers), barriers); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
		/// m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;m_vertexBufferView); if (m_enableCulling) { // Draw the triangles that have not
		/// been culled. m_commandList-&gt;ExecuteIndirect( m_commandSignature.Get(), TriangleCount,
		/// m_processedCommandBuffers[m_frameIndex].Get(), 0, m_processedCommandBuffers[m_frameIndex].Get(), CommandBufferSizePerFrame); }
		/// else { // Draw all of the triangles. m_commandList-&gt;ExecuteIndirect( m_commandSignature.Get(), TriangleCount,
		/// m_commandBuffer.Get(), CommandBufferSizePerFrame * m_frameIndex, nullptr, 0); } // Indicate that the command buffer may be used
		/// by the compute shader // and that the back buffer will now be used to present. barriers[0].Transition.StateBefore =
		/// D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT; barriers[0].Transition.StateAfter = m_enableCulling ? D3D12_RESOURCE_STATE_COPY_DEST :
		/// D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE; barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
		/// barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT; m_commandList-&gt;ResourceBarrier(_countof(barriers),
		/// barriers); ThrowIfFailed(m_commandList-&gt;Close()); } }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-executeindirect void
		// ExecuteIndirect( [in] ID3D12CommandSignature *pCommandSignature, [in] UINT MaxCommandCount, [in] ID3D12Resource *pArgumentBuffer,
		// [in] UINT64 ArgumentBufferOffset, [in, optional] ID3D12Resource *pCountBuffer, [in] UINT64 CountBufferOffset );
		[PreserveSig]
		new void ExecuteIndirect([In] ID3D12CommandSignature pCommandSignature, uint MaxCommandCount, [In] ID3D12Resource pArgumentBuffer,
			ulong ArgumentBufferOffset, [In, Optional] ID3D12Resource? pCountBuffer, ulong CountBufferOffset);

		/// <summary>
		/// <para>Atomically copies a primary data element of type UINT from one resource to another, along with optional dependent resources.</para>
		/// <para>
		/// These 'dependent resources' are so-named because they depend upon the primary data element to locate them, typically the key
		/// element is an address, index, or other handle that refers to one or more the dependent resources indirectly.
		/// </para>
		/// <para>
		/// This function supports a primary data element of type UINT (32bit). A different version of this function,
		/// <c>AtomicCopyBufferUINT64</c>, supports a primary data element of type UINT64 (64bit).
		/// </para>
		/// </summary>
		/// <param name="pDstBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>The resource that the UINT primary data element is copied into.</para>
		/// </param>
		/// <param name="DstOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the destination resource buffer that specifies where the primary data element is copied into, in bytes. This
		/// offset combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT values.
		/// </para>
		/// </param>
		/// <param name="pSrcBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The resource that the UINT primary data element is copied from. This data is typically an address, index, or other handle that
		/// shader code can use to locate the most-recent version of latency-sensitive information.
		/// </para>
		/// </param>
		/// <param name="SrcOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the source resource buffer that specifies where the primary data element is copied from, in bytes. This offset
		/// combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT values.
		/// </para>
		/// </param>
		/// <param name="Dependencies">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of dependent resources.</para>
		/// </param>
		/// <param name="ppDependentResources">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>An array of resources that contain the dependent elements of the data payload.</para>
		/// </param>
		/// <param name="pDependentSubresourceRanges">
		/// <para>Type: <b>const <c>D3D12_SUBRESOURCE_RANGE_UINT64</c>*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>
		/// An array of subresource ranges that specify the dependent elements of the data payload. These elements are completely updated
		/// before the primary data element is itself atomically copied. This ensures that the entire operation is logically atomic; that
		/// is, the primary data element never refers to an incomplete data payload.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// This method is typically used to update resources for which normal rendering pipeline latency can be detrimental to user
		/// experience. For example, an application can compute a view matrix from the latest user input (such as from the sensors of a
		/// head-mounted display), and use this function to update and activate this matrix in command lists already dispatched to the GPU
		/// to reduce perceived latency between input and rendering.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint void
		// AtomicCopyBufferUINT( [in] ID3D12Resource *pDstBuffer, UINT64 DstOffset, [in] ID3D12Resource *pSrcBuffer, UINT64 SrcOffset, UINT
		// Dependencies, [in] ID3D12Resource * const *ppDependentResources, [in] const D3D12_SUBRESOURCE_RANGE_UINT64
		// *pDependentSubresourceRanges );
		[PreserveSig]
		new void AtomicCopyBufferUINT([In] ID3D12Resource pDstBuffer, ulong DstOffset, [In] ID3D12Resource pSrcBuffer, ulong SrcOffset, int Dependencies,
			[In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 4)] ID3D12Resource[] ppDependentResources,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] D3D12_SUBRESOURCE_RANGE_UINT64[] pDependentSubresourceRanges);

		/// <summary>
		/// <para>Atomically copies a primary data element of type UINT64 from one resource to another, along with optional dependent resources.</para>
		/// <para>
		/// These 'dependent resources' are so-named because they depend upon the primary data element to locate them, typically the key
		/// element is an address, index, or other handle that refers to one or more the dependent resources indirectly.
		/// </para>
		/// <para>
		/// This function supports a primary data element of type UINT64 (64bit). A different version of this function,
		/// <c>AtomicCopyBufferUINT</c>, supports a primary data element of type UINT (32bit).
		/// </para>
		/// </summary>
		/// <param name="pDstBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>The resource that the UINT64 primary data element is copied into.</para>
		/// </param>
		/// <param name="DstOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the destination resource buffer that specifies where the primary data element is copied into, in bytes. This
		/// offset combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT64 values.
		/// </para>
		/// </param>
		/// <param name="pSrcBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The resource that the UINT64 primary data element is copied from. This data is typically an address, index, or other handle that
		/// shader code can use to locate the most-recent version of latency-sensitive information.
		/// </para>
		/// </param>
		/// <param name="SrcOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the source resource buffer that specifies where the primary data element is copied from, in bytes. This offset
		/// combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT64 values.
		/// </para>
		/// </param>
		/// <param name="Dependencies">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of dependent resources.</para>
		/// </param>
		/// <param name="ppDependentResources">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>An array of resources that contain the dependent elements of the data payload.</para>
		/// </param>
		/// <param name="pDependentSubresourceRanges">
		/// <para>Type: <b>const <c>D3D12_SUBRESOURCE_RANGE_UINT64</c>*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>
		/// An array of subresource ranges that specify the dependent elements of the data payload. These elements are completely updated
		/// before the primary data element is itself atomically copied. This ensures that the entire operation is logically atomic; that
		/// is, the primary data element never refers to an incomplete data payload.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// This method is typically used to update resources for which normal rendering pipeline latency can be detrimental to user
		/// experience. For example, an application can compute a view matrix from the latest user input (such as from the sensors of a
		/// head-mounted display), and use this function to update and activate this matrix in command lists already dispatched to the GPU
		/// to reduce perceived latency between input and rendering.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64 void
		// AtomicCopyBufferUINT64( [in] ID3D12Resource *pDstBuffer, UINT64 DstOffset, [in] ID3D12Resource *pSrcBuffer, UINT64 SrcOffset,
		// UINT Dependencies, [in] ID3D12Resource * const *ppDependentResources, [in] const D3D12_SUBRESOURCE_RANGE_UINT64
		// *pDependentSubresourceRanges );
		[PreserveSig]
		new void AtomicCopyBufferUINT64([In] ID3D12Resource pDstBuffer, ulong DstOffset, [In] ID3D12Resource pSrcBuffer, ulong SrcOffset, int Dependencies,
			[In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 4)] ID3D12Resource[] ppDependentResources,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] D3D12_SUBRESOURCE_RANGE_UINT64[] pDependentSubresourceRanges);

		/// <summary>This method enables you to change the depth bounds dynamically.</summary>
		/// <param name="Min">
		/// <para>Type: <b>FLOAT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Specifies the minimum depth bounds. The default value is 0. NaN values silently convert to 0.</para>
		/// </param>
		/// <param name="Max">
		/// <para>Type: <b>FLOAT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Specifies the maximum depth bounds. The default value is 1. NaN values silently convert to 0.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Depth-bounds testing allows pixels and samples to be discarded if the currently-stored depth value is outside the range
		/// specified by <i>Min</i> and <i>Max</i>, inclusive. If the currently-stored depth value of the pixel or sample is inside this
		/// range, then the depth-bounds test passes and it is rendered; otherwise, the depth-bounds test fails and the pixel or sample is
		/// discarded. Note that the depth-bounds test considers the currently-stored depth value, not the depth value generated by the
		/// executing pixel shader.
		/// </para>
		/// <para>
		/// To use depth-bounds testing, the application must use the new <c>CreatePipelineState</c> method to enable depth-bounds testing
		/// on the PSO and then can use this command list method to change the depth-bounds dynamically.
		/// </para>
		/// <para>
		/// OMSetDepthBounds is an optional feature. Use the <c>CheckFeatureSupport</c> method to determine whether or not this feature is
		/// supported by the user-mode driver. Support for this feature is reported through the <c>D3D12_FEATURE_D3D12_OPTIONS2</c> structure.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-omsetdepthbounds void
		// OMSetDepthBounds( [in] FLOAT Min, [in] FLOAT Max );
		[PreserveSig]
		new void OMSetDepthBounds(float Min, float Max);

		/// <summary>This method configures the sample positions used by subsequent draw, copy, resolve, and similar operations.</summary>
		/// <param name="NumSamplesPerPixel">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// Specifies the number of samples to take, per pixel. This value can be 1, 2, 4, 8, or 16, otherwise the SetSamplePosition call is
		/// dropped. The number of samples must match the sample count configured in the PSO at draw time, otherwise the behavior is undefined.
		/// </para>
		/// </param>
		/// <param name="NumPixels">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// Specifies the number of pixels that sample patterns are being specified for. This value can be either 1 or 4, otherwise the
		/// SetSamplePosition call is dropped. A value of 1 configures a single sample pattern to be used for each pixel; a value of 4
		/// configures separate sample patterns for each pixel in a 2x2 pixel grid which is repeated over the render-target or viewport
		/// space, aligned to even coordinates.
		/// </para>
		/// <para>
		/// Note that the maximum number of combined samples can't exceed 16, otherwise the call is dropped. If NumPixels is set to 4,
		/// NumSamplesPerPixel can specify no more than 4 samples.
		/// </para>
		/// </param>
		/// <param name="pSamplePositions">
		/// <para>Type: <b><c>D3D12_SAMPLE_POSITION</c>*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(NumSamplesPerPixel*NumPixels)</c></para>
		/// <para>
		/// Specifies an array of D3D12_SAMPLE_POSITION elements. The size of the array is NumPixels * NumSamplesPerPixel. If NumPixels is
		/// set to 4, then the first group of sample positions corresponds to the upper-left pixel in the 2x2 grid of pixels; the next group
		/// of sample positions corresponds to the upper-right pixel, the next group to the lower-left pixel, and the final group to the
		/// lower-right pixel.
		/// </para>
		/// <para>
		/// If centroid interpolation is used during rendering, the order of positions for each pixel determines centroid-sampling priority.
		/// That is, the first covered sample in the order specified is chosen as the centroid sample location.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The operational semantics of sample positions are determined by the various draw, copy, resolve, and other operations that can occur.
		/// </para>
		/// <para>
		/// <b>CommandList:</b> In the absence of any prior calls to SetSamplePositions in a CommandList, samples assume the default
		/// position based on the Pipeline State Object (PSO). The default positions are determined either by the SAMPLE_DESC portion of the
		/// PSO if it is present, or by the standard sample positions if the RASTERIZER_DESC portion of the PSO has ForcedSampleCount set to
		/// a value greater than 0.
		/// </para>
		/// <para>
		/// After SetSamplePosition has been called, subsequent draw calls must use a PSO that specifies a matching sample count either
		/// using the SAMPLE_DESC portion of the PSO, or ForcedSampleCount in the RASTERIZER_DESC portion of the PSO.
		/// </para>
		/// <para>
		/// SetSamplePositions can only be called on a graphics CommandList. It can't be called in a bundle; bundles inherit sample position
		/// state from the calling CommandList and don't modify it.
		/// </para>
		/// <para>Calling SetSamplePositions(0, 0, NULL) reverts the sample positions to their default values.</para>
		/// <para><b>Clear RenderTarget:</b> Sample positions are ignored when clearing a render target.</para>
		/// <para>
		/// <b>Clear DepthStencil:</b> When clearing the depth portion of a depth-stencil surface or any region of it, the sample positions
		/// must be set to match those of future rendering to the cleared surface or region; the contents of any uncleared regions produced
		/// using different sample positions become undefined.
		/// </para>
		/// <para>When clearing the stencil portion of a depth-stencil surface or any region of it, the sample positions are ignored.</para>
		/// <para>
		/// <b>Draw to RenderTarget:</b> When drawing to a render target the sample positions can be changed for each draw call, even when
		/// drawing to a region that overlaps previous draw calls. The current sample positions determine the operational semantics of each
		/// draw call and samples are taken from taken from the stored contents of the render target, even if the contents were produced
		/// using different sample positions.
		/// </para>
		/// <para>
		/// <b>Draw using DepthStencil:</b> When drawing to a depth-stencil surface (read or write) or any region of it, the sample
		/// positions must be set to match those used to clear the affected region previously. To use a different sample position, the
		/// target region must be cleared first. The pixels outside the clear region are unaffected.
		/// </para>
		/// <para>
		/// Hardware may store the depth portion or a depth-stencil surface as plane equations, and evaluate them to produce depth values
		/// when the application issues a read. Only the rasterizer and output-merger are required to support programmable sample positions
		/// of the depth portion of a depth-stencil surface. Any other read or write of the depth portion that has been rendered with sample
		/// positions set may ignore them and instead sample at the standard positions.
		/// </para>
		/// <para>
		/// <b>Resolve RenderTarget:</b> When resolving a render target or any region of it, the sample positions are ignored; these APIs
		/// operate only on stored color values.
		/// </para>
		/// <para>
		/// <b>Resolve DepthStencil:</b> When resolving the depth portion of a depth-stencil surface or any region of it, the sample
		/// positions must be set to match those of past rendering to the resolved surface or region. To use a different sample position,
		/// the target region must be cleared first.
		/// </para>
		/// <para>
		/// When resolving the stencil portion of a depth-stencil surface or any region of it, the sample positions are ignored; stencil
		/// resolves operate only on stored stencil values.
		/// </para>
		/// <para>
		/// <b>Copy RenderTarget:</b> When copying from a render target, the sample positions are ignored regardless of whether it is a full
		/// or partial copy.
		/// </para>
		/// <para>
		/// <b>Copy DepthStencil (Full Subresource):</b> When copying a full subresource from a depth-stencil surface, the sample positions
		/// must be set to match the sample positions used to generate the source surface. To use a different sample position, the target
		/// region must be cleared first.
		/// </para>
		/// <para>
		/// On some hardware properties of the source surface (such as stored plane equations for depth values) transfer to the destination.
		/// Therefore, if the destination surface is subsequently drawn to, the sample positions originally used to generate the source
		/// content need to be used with the destination surface. The API requires this on all hardware for consistency even if it may only
		/// apply to some.
		/// </para>
		/// <para>
		/// <b>Copy DepthStencil (Partial Subresource):</b> When copying a partial subresource from a depth-stencil surface, the sample
		/// positions must be set to match the sample positions used to generate the source surface, similarly to copying a full
		/// subresource. However, if the content of an affected destination subresources is only partially covered by the copy, the contents
		/// of the uncovered portion within those subresources becomes undefined unless all of it was generated using the same sample
		/// positions as the copy source. To use a different sample position, the target region must be cleared first.
		/// </para>
		/// <para>
		/// When copying a partial subresource from the stencil portion of a depth-stencil surface, the sample postions are ignored. It
		/// doesnt matter what sample positions were used to generate content for any other areas of the destination buffer not covered by
		/// the copy  those contents remain valid.
		/// </para>
		/// <para>
		/// <b>Shader SamplePos:</b> The HLSL SamplePos intrinsic is not aware of programmable sample positions and results returned to
		/// shaders calling this on a surface rendered with programmable positions is undefined. Applications must pass coordinates into
		/// their shader manually if needed. Similarly evaluating attributes by sample index is undefined with programmable sample positions.
		/// </para>
		/// <para>
		/// <b>Transitioning out of DEPTH_READ or DEPTH_WRITE state:</b> If a subresource in DEPTH_READ or DEPTH_WRITE state is transitioned
		/// to any other state, including COPY_SOURCE or RESOLVE_SOURCE, some hardware might need to decompress the surface. Therefore, the
		/// sample positions must be set on the command list to match those used to generate the content in the source surface. Furthermore,
		/// for any subsequent transitions of the surface while the same depth data remains in it, the sample positions must continue to
		/// match those set on the command list. To use a different sample position, the target region must be cleared first.
		/// </para>
		/// <para>
		/// If an application wants to minimize the decompressed area when only a portion needs to be used, or just to preserve compression,
		/// ResolveSubresourceRegion() can be called in DECOMPRESS mode with a rect specified. This will decompress just the relevant area
		/// to a separate resource leaving the source intact on some hardware, though on other hardware even the source area is
		/// decompressed. The separate explicitly decompressed resource can then be transitioned to the desired state (such as SHADER_RESOURCE).
		/// </para>
		/// <para>
		/// <b>Transitioning out of RENDER_TARGET state:</b> If a subresource in RENDER_TARGET state is transitioned to anything other than
		/// COPY_SOURCE or RESOLVE_SOURCE, some implementations may need to decompress the surface. This decompression is agnostic to sample positions.
		/// </para>
		/// <para>
		/// If an application wants to minimize the decompressed area when only a portion needs to be used, or just to preserve compression,
		/// ResolveSubresourceRegion() can be called in DECOMPRESS mode with a rect specified. This will decompress just the relevant area
		/// to a separate resource leaving the source intact on some hardware, though on other hardware even the source area is
		/// decompressed. The separate explicitly decompressed resource can then be transitioned to the desired state (such as SHADER_RESOURCE).
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-setsamplepositions void
		// SetSamplePositions( [in] UINT NumSamplesPerPixel, [in] UINT NumPixels, [in] D3D12_SAMPLE_POSITION *pSamplePositions );
		[PreserveSig]
		new void SetSamplePositions(uint NumSamplesPerPixel, uint NumPixels,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_SAMPLE_POSITION[] pSamplePositions);

		/// <summary>Copy a region of a multisampled or compressed resource into a non-multisampled or non-compressed resource.</summary>
		/// <param name="pDstResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// Destination resource. Must be created with the <b>D3D11_USAGE_DEFAULT</b> flag and must be single-sampled unless its to be
		/// resolved from a compressed resource ( <b>D3D12_RESOLVE_MODE_DECOMPRESS</b>); in this case it must have the same sample count as
		/// the compressed source.
		/// </para>
		/// </param>
		/// <param name="DstSubresource">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// A zero-based index that identifies the destination subresource. Use <c>D3D12CalcSubresource</c> to calculate the subresource
		/// index if the parent resource is complex.
		/// </para>
		/// </param>
		/// <param name="DstX">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The X coordinate of the left-most edge of the destination region. The width of the destination region is the same as the width
		/// of the source rect.
		/// </para>
		/// </param>
		/// <param name="DstY">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The Y coordinate of the top-most edge of the destination region. The height of the destination region is the same as the height
		/// of the source rect.
		/// </para>
		/// </param>
		/// <param name="pSrcResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Source resource. Must be multisampled or compressed.</para>
		/// </param>
		/// <param name="SrcSubresource">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>A zero-based index that identifies the source subresource.</para>
		/// </param>
		/// <param name="pSrcRect">
		/// <para>Type: <b>D3D12_RECT*</b></para>
		/// <para><c>SAL</c>: <c>In_opt</c></para>
		/// <para>
		/// Specifies the rectangular region of the source resource to be resolved. Passing NULL for <i>pSrcRect</i> specifies that the
		/// entire subresource is to be resolved.
		/// </para>
		/// </param>
		/// <param name="Format">
		/// <para>Type: <b>DXGI_FORMAT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>A DXGI_FORMAT that specifies how the source and destination resource formats are consolidated.</para>
		/// </param>
		/// <param name="ResolveMode">
		/// <para>Type: <b><c>D3D12_RESOLVE_MODE</c></b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Specifies the operation used to resolve the source samples.</para>
		/// <para>
		/// When using the <b>D3D12_RESOLVE_MODE_DECOMPRESS</b> operation, the sample count can be larger than 1 as long as the source and
		/// destination have the same sample count, and source and destination may specify the same resource as long as the source rect
		/// aligns with the destination X and Y coordinates, in which case decompression occurs in place.
		/// </para>
		/// <para>
		/// When using the <b>D3D12_RESOLVE_MODE_MIN</b>, <b>D3D12_RESOLVE_MODE_MAX</b>, or <b>D3D12_RESOLVE_MODE_AVERAGE</b> operation, the
		/// destination must have a sample count of 1.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// ResolveSubresourceRegion operates like <c>ResolveSubresource</c> but allows for only part of a resource to be resolved and for
		/// source samples to be resolved in several ways. Partial resolves can be useful in multi-adapter scenarios; for example, when the
		/// rendered area has been partitioned across adapters, each adapter might only need to resolve the portion of a subresource that
		/// corresponds to its assigned partition.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion void
		// ResolveSubresourceRegion( [in] ID3D12Resource *pDstResource, [in] UINT DstSubresource, [in] UINT DstX, [in] UINT DstY, [in]
		// ID3D12Resource *pSrcResource, [in] UINT SrcSubresource, [in, optional] D3D12_RECT *pSrcRect, [in] DXGI_FORMAT Format, [in]
		// D3D12_RESOLVE_MODE ResolveMode );
		[PreserveSig]
		new void ResolveSubresourceRegion([In] ID3D12Resource pDstResource, uint DstSubresource, uint DstX, uint DstY, [In] ID3D12Resource pSrcResource,
			uint SrcSubresource, [In, Optional] PRECT? pSrcRect, DXGI_FORMAT Format, D3D12_RESOLVE_MODE ResolveMode);

		/// <summary>Set a mask that controls which view instances are enabled for subsequent draws.</summary>
		/// <param name="Mask">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// A mask that specifies which views are enabled or disabled. If bit <i>i</i> starting from the least-significant bit is set, view
		/// instance <i>i</i> is enabled.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The view instance mask only affects PSOs that declare view instance masking by specifying the
		/// D3D12_VIEW_INSTANCING_FLAG_ENABLE_VIEW_INSTANCE_MASKING flag during their creation. Attempting to create a PSO that declares
		/// view instance masking will fail on adapters that don't support view instancing.
		/// </para>
		/// <para>
		/// The view instance mask defaults to 0 which disables all views. This forces applications that declare view instance masking to
		/// explicitly choose the views to enable, otherwise nothing will be rendered. If the view instance mask enabled all views by
		/// default the application might not remember to disable unused views, resulting in lost performance due to wasted work.
		/// </para>
		/// <para>
		/// Bundles don't inherit their view instance mask from their caller, defaulting to 0 instead. This is because the mask setting must
		/// be known when the bundle is recorded if it affects how an implementation records draws. The view instance mask set by a bundle
		/// does persist to the caller after the bundle completes, however. These inheritance semantics are similar to those of PSOs.
		/// </para>
		/// <para>
		/// No shader code paths that are dependent on SV_ViewID are executed at any shader stage for view instances that are masked off and
		/// no clipping, viewport processing, or rasterization is performed. Implementations that inspect the mask during rendering can
		/// incur a small performance penalty over PSOs that don't declare view instance masking at all, but usually the penalty can be
		/// overcome by the performance savings that result from skipping the work associated with the masked off views. Depending on the
		/// frequency and amount of skipped work, the performance gains can be significant.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-setviewinstancemask void
		// SetViewInstanceMask( [in] UINT Mask );
		[PreserveSig]
		new void SetViewInstanceMask(uint Mask);

		/// <summary>Writes a number of 32-bit immediate values to the specified buffer locations directly from the command stream.</summary>
		/// <param name="Count">
		/// The number of <c>D3D12_WRITEBUFFERIMMEDIATE_PARAMETER</c> structures that are pointed to by <i>pParams</i> and <i>pModes</i>.
		/// </param>
		/// <param name="pParams">
		/// The address of an array containing a number of <c>D3D12_WRITEBUFFERIMMEDIATE_PARAMETER</c> structures equal to <i>Count</i>.
		/// </param>
		/// <param name="pModes">
		/// The address of an array containing a number of <c>D3D12_WRITEBUFFERIMMEDIATE_MODE</c> structures equal to <i>Count</i>. The
		/// default value is <b>null</b>; passing <b>null</b> causes the system to write all immediate values using <b>D3D12_WRITEBUFFERIMMEDIATE_MODE_DEFAULT</b>.
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>WriteBufferImmediate</b> performs <i>Count</i> number of 32-bit writes: one for each value and destination specified in <i>pParams</i>.
		/// </para>
		/// <para>
		/// The receiving buffer (resource) must be in the <b>D3D12_RESOURCE_STATE_COPY_DEST</b> state to be a valid destination for <b>WriteBufferImmediate</b>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist2-writebufferimmediate void
		// WriteBufferImmediate( UINT Count, [in] const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER *pParams, [in, optional] const
		// D3D12_WRITEBUFFERIMMEDIATE_MODE *pModes );
		[PreserveSig]
		new void WriteBufferImmediate(int Count, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_WRITEBUFFERIMMEDIATE_PARAMETER[] pParams,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_WRITEBUFFERIMMEDIATE_MODE[] pModes);

		/// <summary>
		/// Specifies whether or not protected resources can be accessed by subsequent commands in the command list. By default, no
		/// protected resources are enabled. After calling <b>SetProtectedResourceSession</b> with a valid session, protected resources of
		/// the same type can refer to that session. After calling <b>SetProtectedResourceSession</b> with <b>NULL</b>, no protected
		/// resources can be accessed.
		/// </summary>
		/// <param name="pProtectedResourceSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an <b>ID3D12ProtectedResourceSession</b>. You can obtain an <b>ID3D12ProtectedResourceSession</b> by
		/// calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <returns>
		/// If set, indicates that protected resources can be accessed with the given session. Access to protected resources can only happen
		/// after <b>SetProtectedResourceSession</b> is called with a valid session. The command list state is cleared when calling this
		/// method. If you pass <b>NULL</b>, then no protected resources can be accessed.
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist3-setprotectedresourcesession void
		// SetProtectedResourceSession( [in, optional] ID3D12ProtectedResourceSession *pProtectedResourceSession );
		[PreserveSig]
		new void SetProtectedResourceSession([In, Optional] ID3D12ProtectedResourceSession? pProtectedResourceSession);

		/// <summary>
		/// Marks the beginning of a render pass by binding a set of output resources for the duration of the render pass. These bindings
		/// are to one or more render target views (RTVs), and/or to a depth stencil view (DSV).
		/// </summary>
		/// <param name="NumRenderTargets">A <b>UINT</b>. The number of render targets being bound.</param>
		/// <param name="pRenderTargets">
		/// A pointer to a constant <c>D3D12_RENDER_PASS_RENDER_TARGET_DESC</c>, which describes bindings (fixed for the duration of the
		/// render pass) to one or more render target views (RTVs), as well as their beginning and ending access characteristics.
		/// </param>
		/// <param name="pDepthStencil">
		/// A pointer to a constant <c>D3D12_RENDER_PASS_DEPTH_STENCIL_DESC</c>, which describes a binding (fixed for the duration of the
		/// render pass) to a depth stencil view (DSV), as well as its beginning and ending access characteristics.
		/// </param>
		/// <param name="Flags">
		/// A <c>D3D12_RENDER_PASS_FLAGS</c>. The nature/requirements of the render pass; for example, whether it is a suspending or a
		/// resuming render pass, or whether it wants to write to unordered access view(s).
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass void
		// BeginRenderPass( UINT NumRenderTargets, const D3D12_RENDER_PASS_RENDER_TARGET_DESC *pRenderTargets, const
		// D3D12_RENDER_PASS_DEPTH_STENCIL_DESC *pDepthStencil, D3D12_RENDER_PASS_FLAGS Flags );
		[PreserveSig]
		new void BeginRenderPass(int NumRenderTargets, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_RENDER_PASS_RENDER_TARGET_DESC[]? pRenderTargets,
			[In, Optional] ManagedStructPointer<D3D12_RENDER_PASS_DEPTH_STENCIL_DESC> pDepthStencil, D3D12_RENDER_PASS_FLAGS Flags);

		/// <summary>Marks the ending of a render pass.</summary>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-endrenderpass void EndRenderPass();
		[PreserveSig]
		new void EndRenderPass();

		/// <summary>
		/// <para>Initializes the specified meta command.</para>
		/// <para>
		/// You must initialize a meta command at least once prior (on the GPU's timeline) to executing it. Initializing gives the
		/// implementation the chance to perform any work necessary to accelerate the invocation of the meta command. You must supply the
		/// sufficient resource parameters, including the persistent cache resource.
		/// </para>
		/// </summary>
		/// <param name="pMetaCommand">A pointer to an <c>ID3D12MetaCommand</c> representing the meta command to initialize.</param>
		/// <param name="pInitializationParametersData">
		/// An optional pointer to a constant structure containing the values of the parameters for initializing the meta command.
		/// </param>
		/// <param name="InitializationParametersDataSizeInBytes">
		/// A <c>SIZE_T</c> containing the size of the structure pointed to by <i>pInitializationParametersData</i>, if set, otherwise 0.
		/// </param>
		/// <returns>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-initializemetacommand void
		// InitializeMetaCommand( [in] ID3D12MetaCommand *pMetaCommand, [in, optional] const void *pInitializationParametersData, [in]
		// SIZE_T InitializationParametersDataSizeInBytes );
		[PreserveSig]
		new void InitializeMetaCommand([In] ID3D12MetaCommand pMetaCommand, [In, Optional] IntPtr pInitializationParametersData,
			[In] SizeT InitializationParametersDataSizeInBytes);

		/// <summary>
		/// <para>Records the execution (or invocation) of the specified meta command into a graphics command list.</para>
		/// <para>
		/// Call <c>ID3D12GraphicsCommandList4::InitializeMetaCommand</c> before executing a meta command. During invocation, you can
		/// specify overrides for values of any of the runtime parameters. You can execute multiple meta commands on the same graphics
		/// command list. And you can execute the same meta command multiple times on the same command list.
		/// </para>
		/// <para>
		/// With a PIX capture taken with the use of meta commands, you can play that back on the same hardware configuration. But, by
		/// design, it's not portable to other GPUs.
		/// </para>
		/// </summary>
		/// <param name="pMetaCommand">A pointer to an <b>ID3D12MetaCommand</b> representing the meta command to initialize.</param>
		/// <param name="pExecutionParametersData">
		/// An optional pointer to a constant structure containing the values of the parameters for executing the meta command.
		/// </param>
		/// <param name="ExecutionParametersDataSizeInBytes">
		/// A <c>SIZE_T</c> containing the size of the structure pointed to by <i>pExecutionParametersData</i>, if set, otherwise 0.
		/// </param>
		/// <returns>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</returns>
		/// <remarks>
		/// <para>
		/// Your application is responsible for setting up the resources supplied to a meta command in the state required according to the
		/// meta command specification. The meta command definition specification defines the expected resource state for each parameter.
		/// Your application is responsible for inserting unordered access view (UAV) barriers for input resources before the meta command's
		/// algorithm can consume them. You're also responsible for inserting the UAV barrier for the output resources when you intend to
		/// read them back.
		/// </para>
		/// <para>
		/// During an algorithm invocation, the driver may insert as many UAV barriers to output resources as are needed to synchronize the
		/// output resource usage in the algorithm implementation. From your application's point of view, you should assume that all out and
		/// in/out resources are written to by the meta command, including scratch memory.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-executemetacommand void
		// ExecuteMetaCommand( [in] ID3D12MetaCommand *pMetaCommand, [in, optional] const void *pExecutionParametersData, [in] SIZE_T
		// ExecutionParametersDataSizeInBytes );
		[PreserveSig]
		new void ExecuteMetaCommand([In] ID3D12MetaCommand pMetaCommand, [In, Optional] IntPtr pExecutionParametersData, [In] SizeT ExecutionParametersDataSizeInBytes);

		/// <summary>
		/// Performs a raytracing acceleration structure build on the GPU and optionally outputs post-build information immediately after
		/// the build.
		/// </summary>
		/// <param name="pDesc">Description of the acceleration structure to build.</param>
		/// <param name="NumPostbuildInfoDescs">Size of the <i>pPostbuildInfoDescs</i> array. Set to 0 if no post-build info is needed.</param>
		/// <param name="pPostbuildInfoDescs">
		/// Optional array of descriptions for post-build info to generate describing properties of the acceleration structure that was built.
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This method can be called on graphics or compute command lists but not from bundles.</para>
		/// <para>
		/// Post-build information can also be obtained separately from an already built acceleration structure by calling
		/// <c>EmitRaytracingAccelerationStructurePostbuildInfo</c>. The advantage of generating post-build info along with a build is that
		/// a barrier isnt needed in between the build completing and requesting post-build information, enabling scenarios where the app
		/// needs the post-build info right away.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-buildraytracingaccelerationstructure
		// void BuildRaytracingAccelerationStructure( [in] const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC *pDesc, [in] UINT
		// NumPostbuildInfoDescs, [in] const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pPostbuildInfoDescs );
		[PreserveSig]
		new void BuildRaytracingAccelerationStructure(in D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC pDesc, int NumPostbuildInfoDescs,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC[]? pPostbuildInfoDescs);

		/// <summary>
		/// Emits post-build properties for a set of acceleration structures. This enables applications to know the output resource
		/// requirements for performing acceleration structure operations via <c>ID3D12GraphicsCommandList4::CopyRaytracingAccelerationStructure</c>.
		/// </summary>
		/// <param name="pDesc">
		/// A <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC</c> object describing post-build information to generate.
		/// </param>
		/// <param name="NumSourceAccelerationStructures">
		/// Number of pointers to acceleration structure GPU virtual addresses pointed to by <i>pSourceAccelerationStructureData</i>. This
		/// number also affects the destination (output), which will be a contiguous array of <b>NumSourceAccelerationStructures</b> output
		/// structures, where the type of the structures depends on <i>InfoType</i> field of the supplied in the <i>pDesc</i> description.
		/// </param>
		/// <param name="pSourceAccelerationStructureData">
		/// <para>Pointer to array of GPU virtual addresses of size <i>NumSourceAccelerationStructures</i>.</para>
		/// <para>The address must be aligned to 256 bytes, defined as <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT</c>.</para>
		/// <para>The memory pointed to must be in state <c>D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE</c>.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>This method can be called from graphics or compute command lists but not from bundles.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-emitraytracingaccelerationstructurepostbuildinfo
		// void EmitRaytracingAccelerationStructurePostbuildInfo( [in] const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC
		// *pDesc, [in] UINT NumSourceAccelerationStructures, [in] const D3D12_GPU_VIRTUAL_ADDRESS *pSourceAccelerationStructureData );
		[PreserveSig]
		new void EmitRaytracingAccelerationStructurePostbuildInfo(in D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC pDesc,
			int NumSourceAccelerationStructures, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_GPU_VIRTUAL_ADDRESS[] pSourceAccelerationStructureData);

		/// <summary>Copies a source acceleration structure to destination memory while applying the specified transformation.</summary>
		/// <param name="DestAccelerationStructureData">
		/// <para>
		/// The destination memory. The required size can be discovered by calling <c>EmitRaytracingAccelerationStructurePostbuildInfo</c>
		/// beforehand, if necessary for the specified <i>Mode</i>.
		/// </para>
		/// <para>
		/// The destination start address must be aligned to 256 bytes, defined as
		/// <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT</c>, regardless of the specified <i>Mode</i>.
		/// </para>
		/// <para>The destination memory range cannot overlap source. Otherwise, results are undefined.</para>
		/// <para>
		/// The resource state that the memory pointed to must be in depends on the <i>Mode</i> parameter. For more information, see <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE</c>.
		/// </para>
		/// </param>
		/// <param name="SourceAccelerationStructureData">
		/// <para>
		/// The address of the acceleration structure or other type of data to copy/transform based on the specified <i>Mode</i>. The data
		/// remains unchanged and usable. The operation only copies the data pointed to by <i>SourceAccelerationStructureData</i> and not
		/// any other data, such as acceleration structures, that the source data may point to. For example, in the case of a top-level
		/// acceleration structure, any bottom-level acceleration structures that it points to are not copied in the operation.
		/// </para>
		/// <para>
		/// The source memory must be aligned to 256 bytes, defined as <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT</c>,
		/// regardless of the specified <i>Mode</i>.
		/// </para>
		/// <para>
		/// The resource state that the memory pointed to must be in depends on the <i>Mode</i> parameter. For more information, see <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE</c>.
		/// </para>
		/// </param>
		/// <param name="Mode">The type of copy operation to perform. For more information, see <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE</c>.</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Since raytracing acceleration structures may contain internal pointers and have a device dependent opaque layout, copying them
		/// around or otherwise manipulating them requires a dedicated API so that drivers can handle the requested operation.
		/// </para>
		/// <para>This method can be called from graphics or compute command lists but not from bundles.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-copyraytracingaccelerationstructure
		// void CopyRaytracingAccelerationStructure( [in] D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData, [in]
		// D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData, [in] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode );
		[PreserveSig]
		new void CopyRaytracingAccelerationStructure(D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData, D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData,
			D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode);

		/// <summary>Sets a state object on the command list.</summary>
		/// <param name="pStateObject">The state object to set on the command list. In the current release, this can only be of type <c>D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE</c>.</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This method can be called from graphics or compute command lists and bundles.</para>
		/// <para>
		/// This method is an alternative to <c>ID3D12GraphicsCommandList::SetPipelineState</c>, which is only defined for graphics and
		/// compute shaders. There is only one pipeline state active on a command list at a time, so either call sets the current pipeline
		/// state. The distinction between the calls is that each sets particular types of pipeline state only. In the current release,
		/// <b>SetPipelineState1</b> is only used for setting raytracing pipeline state.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-setpipelinestate1 void
		// SetPipelineState1( ID3D12StateObject *pStateObject );
		[PreserveSig]
		new void SetPipelineState1([In] ID3D12StateObject pStateObject);

		/// <summary>Launch the threads of a ray generation shader.</summary>
		/// <param name="pDesc">A description of the ray dispatch</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This method can be called from graphics or compute command lists and bundles.</para>
		/// <para>A raytracing pipeline state must be set on the command list. Otherwise, the behavior of this call is undefined.</para>
		/// <para>
		/// There are 3 dimensions passed in to set the grid size: width/height/depth. These dimensions are constrained such that width *
		/// height * depth &lt;= 2^30. Exceeding this produces undefined behavior. If any grid dimension is 0, no threads are launched.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-dispatchrays void DispatchRays(
		// [in] const D3D12_DISPATCH_RAYS_DESC *pDesc );
		[PreserveSig]
		new void DispatchRays(in D3D12_DISPATCH_RAYS_DESC pDesc);

		/// <summary>
		/// Sets the base shading rate, and combiners, for variable-rate shading (VRS). For more info, see <c>Variable-rate shading (VRS)</c>.
		/// </summary>
		/// <param name="baseShadingRate">
		/// <para>Type: <c><b>D3D12_SHADING_RATE</b></c></para>
		/// <para>A constant from the <c>D3D12_SHADING_RATE</c> enumeration describing the base shading rate to set.</para>
		/// </param>
		/// <param name="combiners">
		/// <para>Type: <b>const <c>D3D12_SHADING_RATE_COMBINER</c>*</b></para>
		/// <para>
		/// An optional pointer to a constant array of <c><b>D3D12_SHADING_RATE_COMBINER</b></c> containing the shading rate combiners to
		/// set. The count of <c><b>D3D12_SHADING_RATE_COMBINER</b></c> elements in the array must be equal to the constant
		/// <c><b>D3D12_RS_SET_SHADING_RATE_COMBINER_COUNT</b></c>, which is equal to <b>2</b>.
		/// </para>
		/// <para>
		/// Because per-primitive and screen-space image-based VRS isn't supported on Tier1 <c>Variable-rate shading (VRS)</c>, for these
		/// values to be meaningful, the adapter requires Tier2 VRS support. See <c><b>D3D12_FEATURE_DATA_D3D12_OPTIONS6</b></c> and <c><b>D3D12_VARIABLE_SHADING_RATE_TIER</b></c>.
		/// </para>
		/// <para>A <b>NULL</b> pointer is equivalent to the default shading combiners, which are both <c><b>D3D12_SHADING_RATE_COMBINER_PASSTHROUGH</b></c>.</para>
		/// <para>The algorithm for final shading-rate is determined by the following.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist5-rssetshadingrate void
		// RSSetShadingRate( D3D12_SHADING_RATE baseShadingRate, const D3D12_SHADING_RATE_COMBINER *combiners );
		[PreserveSig]
		new void RSSetShadingRate(D3D12_SHADING_RATE baseShadingRate, [In, Optional, MarshalAs(UnmanagedType.LPArray)] D3D12_SHADING_RATE_COMBINER[]? combiners);

		/// <summary>
		/// Sets the screen-space shading-rate image for variable-rate shading (VRS). For more info, see <c>Variable-rate shading (VRS)</c>.
		/// This method requires Tier2 <c>Variable-rate shading (VRS)</c> support. See <c><b>D3D12_FEATURE_DATA_D3D12_OPTIONS6</b></c> and <c><b>D3D12_VARIABLE_SHADING_RATE_TIER</b></c>.
		/// </summary>
		/// <param name="shadingRateImage">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>
		/// An optional pointer to an <c>ID3D12Resource</c> representing a screen-space shading-rate image. If <b>NULL</b>, the effect is
		/// the same as having a shading-rate image where all values are a shading rate of 1x1.
		/// </para>
		/// <para>This texture must have the <c><b>D3D12_RESOURCE_STATE_SHADING_RATE_SOURCE</b></c> state applied.</para>
		/// <para>
		/// The tile-size of the shading-rate image can be determined via <c><b>D3D12_FEATURE_DATA_D3D12_OPTIONS6</b></c>. The size of the
		/// shading-rate image should therefore be
		/// </para>
		/// <para>
		/// The shading-rate image must be a 2D texture with a single mip, and format <c><b>DXGI_FORMAT_R8_UINT</b></c>. Each texel must be
		/// a value corresponding to <c><b>D3D12_SHADING_RATE</b></c>. It must have layout <c><b>D3D12_TEXTURE_LAYOUT_UNKNOWN</b></c> and
		/// can't be a depth-stencil, render-target, simultaneous-access, or cross-adapter resource.
		/// </para>
		/// <para>
		/// As (0, 0) is the top left in DirectX, a too-small or large shading-rate image results in the bottom or right having no
		/// shading-rate image area, or the image extending in these directions. When there is excess, it is ignored (but legal), and when
		/// the image is too small, all out-of-bounds areas in the bottom and right will have the default shading rate of 1x1 from the image
		/// (however, this does not mean that is the final shading rate. The combiners will still be applied to this 1x1 default value).
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// For the screen-space shading-rate image to take affect, <c><b>ID3D12GraphicsCommandList5::RSSetShadingRate</b></c> must have
		/// been called to set the combiners for shading. Else, with the default combiners (both
		/// <c><b>D3D12_SHADING_RATE_COMBINER_PASSTHROUGH</b></c>), the screen-space shading-rate image is ignored in determining shading granularity.
		/// </para>
		/// <para>
		/// The second combiner passed to [ <b>ID3D12GraphicsCommandList5::RSSetShadingRate</b>] is the one which applies to the
		/// shading-rate image, which occurs after the global shading rate and the per-primitive shading rate have been combined.
		/// </para>
		/// <para>The algorithm for final shading-rate is determined by</para>
		/// <para>
		/// <c>postRasterizerRate = ApplyCombiner(Combiners[0], CommandListShadingRate, Primitive-&gt;PrimitiveSpecifiedShadingRate);
		/// finalRate = ApplyCombiner(Combiners[1], postRasterizerRate, ScreenSpaceImage[xy]);</c>
		/// </para>
		/// <para>where <c>ApplyCombiner</c> is</para>
		/// <para>
		/// <c>UINT ApplyCombiner(D3D12_SHADING_RATE_COMBINER combiner, UINT a, UINT b) { MaxShadingRate =
		/// options6.AdditionalShadingRatesSupported ? 4 : 2; switch (combiner) { case D3D12_SHADING_RATE_COMBINER_PASSTHROUGH: // default
		/// return a; case D3D12_SHADING_RATE_COMBINER_OVERRIDE: return b; case D3D12_SHADING_RATE_COMBINER_MAX: return max(a, b); case
		/// D3D12_SHADING_RATE_COMBINER_MIN: return min(a, b); case D3D12_SHADING_RATE_COMBINER_SUM: return min(MaxShadingRate, a + b); case
		/// default: return a; } }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist5-rssetshadingrateimage void
		// RSSetShadingRateImage( ID3D12Resource *shadingRateImage );
		[PreserveSig]
		new void RSSetShadingRateImage([In, Optional] ID3D12Resource? shadingRateImage);

		/// <summary/>
		/// <param name="ThreadGroupCountX"/>
		/// <param name="ThreadGroupCountY"/>
		/// <param name="ThreadGroupCountZ"/>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist6-dispatchmesh void DispatchMesh(
		// UINT ThreadGroupCountX, UINT ThreadGroupCountY, UINT ThreadGroupCountZ );
		[PreserveSig]
		new void DispatchMesh(uint ThreadGroupCountX, uint ThreadGroupCountY, uint ThreadGroupCountZ);

		/// <summary>
		/// <para>Adds a collection of barriers into a graphics command list recording.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.608 or later.</para>
		/// </summary>
		/// <param name="NumBarrierGroups">Number of barrier groups pointed to by pBarrierGroups.</param>
		/// <param name="pBarrierGroups">Pointer to an array of <c>D3D12_BARRIER_GROUP</c> objects.</param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist7-barrier void Barrier( UINT32
		// NumBarrierGroups, const D3D12_BARRIER_GROUP *pBarrierGroups );
		[PreserveSig]
		new void Barrier(int NumBarrierGroups, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_BARRIER_GROUP[] pBarrierGroups);

		[PreserveSig]
		void OMSetFrontAndBackStencilRef(uint FrontStencilRef, uint BackStencilRef);
	}

	[ComImport]
	[Guid("34ed2808-ffe6-4c2b-b11a-cabd2b0c59e1")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ID3D12GraphicsCommandList9 : ID3D12GraphicsCommandList8, ID3D12GraphicsCommandList7, ID3D12GraphicsCommandList6, ID3D12GraphicsCommandList5, ID3D12GraphicsCommandList4, ID3D12GraphicsCommandList3, ID3D12GraphicsCommandList2, ID3D12GraphicsCommandList1, ID3D12GraphicsCommandList, ID3D12CommandList, ID3D12DeviceChild, ID3D12Object
	{
		/// <summary>Gets application-defined data from a device object.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> that is associated with the data.</para>
		/// </param>
		/// <param name="pDataSize">
		/// <para>Type: <b><c>UINT</c>*</b></para>
		/// <para>
		/// A pointer to a variable that on input contains the size, in bytes, of the buffer that <i>pData</i> points to, and on output
		/// contains the size, in bytes, of the amount of data that <b>GetPrivateData</b> retrieved.
		/// </para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>void*</b></para>
		/// <para>
		/// A pointer to a memory block that receives the data from the device object if <i>pDataSize</i> points to a value that specifies a
		/// buffer large enough to hold the data.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// If the data returned is a pointer to an <c>IUnknown</c>, or one of its derivative classes, which was previously set by
		/// SetPrivateDataInterface, that interface will have its reference count incremented before the private data is returned.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-getprivatedata HRESULT GetPrivateData( [in]
		// REFGUID guid, [in, out] UINT *pDataSize, [out, optional] void *pData );
		[PreserveSig]
		new HRESULT GetPrivateData(in Guid guid, ref uint pDataSize, [Out, Optional] IntPtr pData);

		/// <summary>Sets application-defined data to a device object and associates that data with an application-defined <b>GUID</b>.</summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the data.</para>
		/// </param>
		/// <param name="DataSize">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The size in bytes of the data.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>
		/// A pointer to a memory block that contains the data to be stored with this device object. If <i>pData</i> is <b>NULL</b>,
		/// <i>DataSize</i> must also be 0, and any data that was previously associated with the <b>GUID</b> specified in <i>guid</i> will
		/// be destroyed.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// Rather than using the Direct3D 11 debug object naming scheme of calling <b>ID3D12Object::SetPrivateData</b> using
		/// <b>WKPDID_D3DDebugObjectName</b> with an ASCII name, call <c>ID3D12Object::SetName</c> with a UNICODE name.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedata HRESULT SetPrivateData( [in]
		// REFGUID guid, [in] UINT DataSize, [in, optional] const void *pData );
		[PreserveSig]
		new HRESULT SetPrivateData(in Guid guid, uint DataSize, [In, Optional] IntPtr pData);

		/// <summary>
		/// Associates an <c>IUnknown</c>-derived interface with the device object, and associates that interface with an
		/// application-defined <b>GUID</b>.
		/// </summary>
		/// <param name="guid">
		/// <para>Type: <b><c>REFGUID</c></b></para>
		/// <para>The <b>GUID</b> to associate with the interface.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const <c>IUnknown</c>*</b></para>
		/// <para>
		/// A pointer to the <c>IUnknown</c>-derived interface to be associated with the device object. Its reference count is incremented
		/// when set, and its reference count is decremented when either the <c>ID3D12Object</c> is destroyed, or when the data is
		/// overwritten by calling <c>SetPrivateData</c> or <b>SetPrivateDataInterface</b> with the same <b>GUID</b>.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 return codes</c>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setprivatedatainterface HRESULT
		// SetPrivateDataInterface( [in] REFGUID guid, [in, optional] const IUnknown *pData );
		[PreserveSig]
		new HRESULT SetPrivateDataInterface(in Guid guid, [In, Optional, MarshalAs(UnmanagedType.Interface)] object? pData);

		/// <summary>Associates a name with the device object. This name is for use in debug diagnostics and tools.</summary>
		/// <param name="Name">
		/// <para>Type: <b>LPCWSTR</b></para>
		/// <para>A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the device object.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>This method takes UNICODE names.</para>
		/// <para>
		/// Note that this is simply a convenience wrapper around <c>ID3D12Object::SetPrivateData</c> with
		/// <b>WKPDID_D3DDebugObjectNameW</b>. Therefore names which are set with <c>SetName</c> can be retrieved with
		/// <c>ID3D12Object::GetPrivateData</c> with the same GUID. Additionally, D3D12 supports narrow strings for names, using the
		/// <b>WKPDID_D3DDebugObjectName</b> GUID directly instead.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12object-setname HRESULT SetName( [in] LPCWSTR Name );
		[PreserveSig]
		new HRESULT SetName([MarshalAs(UnmanagedType.LPWStr)] string Name);

		/// <summary>Gets a pointer to the device that created this interface.</summary>
		/// <param name="riid">
		/// <para>Type: <b>REFIID</b></para>
		/// <para>
		/// The globally unique identifier (<b>GUID</b>) for the device interface. The <b>REFIID</b>, or <b>GUID</b>, of the interface to
		/// the device can be obtained by using the __uuidof() macro. For example, __uuidof(<c>ID3D12Device</c>) will get the <b>GUID</b>
		/// of the interface to a device.
		/// </para>
		/// </param>
		/// <param name="ppvDevice">
		/// <para>Type: <b>void**</b></para>
		/// <para>A pointer to a memory block that receives a pointer to the <c>ID3D12Device</c> interface for the device.</para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>This method returns one of the <c>Direct3D 12 Return Codes</c>.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// Any returned interfaces have their reference count incremented by one, so be sure to call ::release() on the returned pointers
		/// before they are freed or else you will have a memory leak.
		///  Examples The <c>D3D12Multithreading</c> sample uses <b>ID3D12DeviceChild::GetDevice</b> as follows:</para>
		/// <code language="cpp">
		///<![CDATA[// Returns required size of a buffer to be used for data upload
		///inline UINT64 GetRequiredIntermediateSize(
		///   _In_ ID3D12Resource* pDestinationResource,
		///   _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		///   _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources)
		///{
		///   D3D12_RESOURCE_DESC Desc = pDestinationResource->GetDesc();
		///   UINT64 RequiredSize = 0;
		///
		///   ID3D12Device* pDevice;
		///   pDestinationResource->GetDevice(__uuidof(*pDevice), reinterpret_cast<void**>(&pDevice));
		///   pDevice->GetCopyableFootprints(&Desc, FirstSubresource, NumSubresources, 0, nullptr, nullptr, nullptr, &RequiredSize);
		///   pDevice->Release();
		///
		///   return RequiredSize;
		///}]]>
		/// </code>
		/// <para>Refer to the <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12devicechild-getdevice HRESULT GetDevice( REFIID riid,
		// [out, optional] void **ppvDevice );
		[PreserveSig]
		new HRESULT GetDevice(in Guid riid, [MarshalAs(UnmanagedType.IUnknown, IidParameterIndex = 0)] out object? ppvDevice);

		/// <summary>Gets the type of the command list, such as direct, bundle, compute, or copy.</summary>
		/// <returns>
		/// <para>Type: <b><c>D3D12_COMMAND_LIST_TYPE</c></b></para>
		/// <para>
		/// This method returns the type of the command list, as a <c>D3D12_COMMAND_LIST_TYPE</c> enumeration constant, such as direct,
		/// bundle, compute, or copy.
		/// </para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12commandlist-gettype D3D12_COMMAND_LIST_TYPE GetType();
		[PreserveSig]
		new D3D12_COMMAND_LIST_TYPE GetType();

		/// <summary>Indicates that recording to the command list has finished.</summary>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// <b>E_FAIL</b> if the command list has already been closed, or an invalid API was called during command list recording.
		/// </description>
		/// </item>
		/// <item>
		/// <description><b>E_OUTOFMEMORY</b> if the operating system ran out of memory during recording.</description>
		/// </item>
		/// <item>
		/// <description><b>E_INVALIDARG</b> if an invalid argument was passed to the command list API during recording.</description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 Return Codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// The runtime will validate that the command list has not previously been closed. If an error was encountered during recording,
		/// the error code is returned here. The runtime won't call the close device driver interface (DDI) in this case. Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::Close</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::LoadAssets() { // Create an empty root signature. { CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
		/// rootSignatureDesc.Init(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);
		/// ComPtr&lt;ID3DBlob&gt; signature; ComPtr&lt;ID3DBlob&gt; error;
		/// ThrowIfFailed(D3D12SerializeRootSignature(&amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &amp;signature, &amp;error));
		/// ThrowIfFailed(m_device-&gt;CreateRootSignature(0, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(),
		/// IID_PPV_ARGS(&amp;m_rootSignature))); } // Create the pipeline state, which includes compiling and loading shaders. {
		/// ComPtr&lt;ID3DBlob&gt; vertexShader; ComPtr&lt;ID3DBlob&gt; pixelShader; #if defined(_DEBUG) // Enable better shader debugging
		/// with the graphics debugging tools. UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION; #else UINT compileFlags
		/// = 0; #endif ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L"shaders.hlsl").c_str(), nullptr, nullptr, "VSMain", "vs_5_0",
		/// compileFlags, 0, &amp;vertexShader, nullptr)); ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L"shaders.hlsl").c_str(),
		/// nullptr, nullptr, "PSMain", "ps_5_0", compileFlags, 0, &amp;pixelShader, nullptr)); // Define the vertex input layout.
		/// D3D12_INPUT_ELEMENT_DESC inputElementDescs[] = { { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,
		/// D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, { "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12,
		/// D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 } }; // Describe and create the graphics pipeline state object (PSO).
		/// D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = {}; psoDesc.InputLayout = { inputElementDescs, _countof(inputElementDescs) };
		/// psoDesc.pRootSignature = m_rootSignature.Get(); psoDesc.VS = {
		/// reinterpret_cast&lt;UINT8*&gt;(vertexShader-&gt;GetBufferPointer()), vertexShader-&gt;GetBufferSize() }; psoDesc.PS = {
		/// reinterpret_cast&lt;UINT8*&gt;(pixelShader-&gt;GetBufferPointer()), pixelShader-&gt;GetBufferSize() }; psoDesc.RasterizerState =
		/// CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT); psoDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
		/// psoDesc.DepthStencilState.DepthEnable = FALSE; psoDesc.DepthStencilState.StencilEnable = FALSE; psoDesc.SampleMask = UINT_MAX;
		/// psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE; psoDesc.NumRenderTargets = 1; psoDesc.RTVFormats[0] =
		/// DXGI_FORMAT_R8G8B8A8_UNORM; psoDesc.SampleDesc.Count = 1; ThrowIfFailed(m_device-&gt;CreateGraphicsPipelineState(&amp;psoDesc,
		/// IID_PPV_ARGS(&amp;m_pipelineState))); } // Create the command list. ThrowIfFailed(m_device-&gt;CreateCommandList(0,
		/// D3D12_COMMAND_LIST_TYPE_DIRECT, m_commandAllocator.Get(), m_pipelineState.Get(), IID_PPV_ARGS(&amp;m_commandList))); // Command
		/// lists are created in the recording state, but there is nothing // to record yet. The main loop expects it to be closed, so close
		/// it now. ThrowIfFailed(m_commandList-&gt;Close()); // Create the vertex buffer. { // Define the geometry for a triangle. Vertex
		/// triangleVertices[] = { { { 0.0f, 0.25f * m_aspectRatio, 0.0f }, { 1.0f, 0.0f, 0.0f, 1.0f } }, { { 0.25f, -0.25f * m_aspectRatio,
		/// 0.0f }, { 0.0f, 1.0f, 0.0f, 1.0f } }, { { -0.25f, -0.25f * m_aspectRatio, 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f } } }; const UINT
		/// vertexBufferSize = sizeof(triangleVertices); // Note: using upload heaps to transfer static data like vert buffers is not //
		/// recommended. Every time the GPU needs it, the upload heap will be marshalled // over. Please read up on Default Heap usage. An
		/// upload heap is used here for // code simplicity and because there are very few verts to actually transfer.
		/// ThrowIfFailed(m_device-&gt;CreateCommittedResource( &amp;CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD), D3D12_HEAP_FLAG_NONE,
		/// &amp;D3D12_RESOURCE_DESC::Buffer(vertexBufferSize), D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		/// IID_PPV_ARGS(&amp;m_vertexBuffer))); // Copy the triangle data to the vertex buffer. UINT8* pVertexDataBegin; CD3DX12_RANGE
		/// readRange(0, 0); // We do not intend to read from this resource on the CPU. ThrowIfFailed(m_vertexBuffer-&gt;Map(0,
		/// &amp;readRange, reinterpret_cast&lt;void**&gt;(&amp;pVertexDataBegin))); memcpy(pVertexDataBegin, triangleVertices,
		/// sizeof(triangleVertices)); m_vertexBuffer-&gt;Unmap(0, nullptr); // Initialize the vertex buffer view.
		/// m_vertexBufferView.BufferLocation = m_vertexBuffer-&gt;GetGPUVirtualAddress(); m_vertexBufferView.StrideInBytes =
		/// sizeof(Vertex); m_vertexBufferView.SizeInBytes = vertexBufferSize; } // Create synchronization objects and wait until assets
		/// have been uploaded to the GPU. { ThrowIfFailed(m_device-&gt;CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&amp;m_fence)));
		/// m_fenceValue = 1; // Create an event handle to use for frame synchronization. m_fenceEvent = CreateEvent(nullptr, FALSE, FALSE,
		/// nullptr); if (m_fenceEvent == nullptr) { ThrowIfFailed(HRESULT_FROM_WIN32(GetLastError())); } // Wait for the command list to
		/// execute; we are reusing the same command // list in our main loop but for now, we just want to wait for setup to // complete
		/// before continuing. WaitForPreviousFrame(); } }</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-close HRESULT Close();
		[PreserveSig]
		new HRESULT Close();

		/// <summary>Resets a command list back to its initial state as if a new command list was just created.</summary>
		/// <param name="pAllocator">
		/// <para>Type: <b>ID3D12CommandAllocator*</b></para>
		/// <para>A pointer to the <c>ID3D12CommandAllocator</c> object that the device creates command lists from.</para>
		/// </param>
		/// <param name="pInitialState">
		/// <para>Type: <b>ID3D12PipelineState*</b></para>
		/// <para>
		/// A pointer to the <c>ID3D12PipelineState</c> object that contains the initial pipeline state for the command list. This is
		/// optional and can be NULL. If NULL, the runtime sets a dummy initial pipeline state so that drivers don't have to deal with
		/// undefined state. The overhead for this is low, particularly for a command list, for which the overall cost of recording the
		/// command list likely dwarfs the cost of one initial state setting. So there is little cost in not setting the initial pipeline
		/// state parameter if it isn't convenient.
		/// </para>
		/// <para>
		/// For bundles on the other hand, it might make more sense to try to set the initial state parameter since bundles are likely
		/// smaller overall and can be reused frequently.
		/// </para>
		/// </param>
		/// <returns>
		/// <para>Type: <b><c>HRESULT</c></b></para>
		/// <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the following values:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// <b>E_FAIL</b> if the command list was not in the "closed" state when the <b>Reset</b> call was made, or the per-device limit
		/// would have been exceeded.
		/// </description>
		/// </item>
		/// <item>
		/// <description><b>E_OUTOFMEMORY</b> if the operating system ran out of memory.</description>
		/// </item>
		/// <item>
		/// <description>
		/// <b>E_INVALIDARG</b> if the allocator is currently being used with another command list in the "recording" state or if the
		/// specified allocator was created with the wrong type.
		/// </description>
		/// </item>
		/// </list>
		/// <para>See <c>Direct3D 12 Return Codes</c> for other possible return values.</para>
		/// </returns>
		/// <remarks>
		/// <para>
		/// By using <b>Reset</b>, you can re-use command list tracking structures without any allocations. Unlike
		/// <c>ID3D12CommandAllocator::Reset</c>, you can call <b>Reset</b> while the command list is still being executed.
		/// </para>
		/// <para>You can use <b>Reset</b> for both direct command lists and bundles.</para>
		/// <para>
		/// The command allocator passed to <b>Reset</b> cannot be associated with any other currently-recording command list. The allocator
		/// type, direct command list or bundle, must match the type of command list that is being created.
		/// </para>
		/// <para>
		/// If a bundle doesn't specify a resource heap, it can't make changes to which descriptor tables are bound. Either way, bundles
		/// can't change the resource heap within the bundle. If a heap is specified for a bundle, the heap must match the calling 'parent'
		/// command lists heap.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>
		/// Before an app calls <b>Reset</b>, the command list must be in the "closed" state. <b>Reset</b> will fail if the command list
		/// isn't in the "closed" state.
		/// </para>
		/// <para>
		/// <b>Note</b>If a call to <c>ID3D12GraphicsCommandList::Close</c> fails, the command list can never be reset. Calling
		/// <b>Reset</b> will result in the same error being returned that <b>ID3D12GraphicsCommandList::Close</b> returned.
		/// </para>
		/// <para></para>
		/// <para>
		/// After <b>Reset</b> succeeds, the command list is left in the "recording" state. <b>Reset</b> will fail if it would cause the
		/// maximum concurrently recording command list limit, which is specified at device creation, to be exceeded.
		/// </para>
		/// <para>
		/// Apps must specify a command list allocator. The runtime will ensure that an allocator is never associated with more than one
		/// recording command list at the same time.
		/// </para>
		/// <para><b>Reset</b> fails for bundles that are referenced by a not yet submitted command list.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>
		/// The debug layer will also track graphics processing unit (GPU) progress and issue an error if it can't prove that there are no
		/// outstanding executions of the command list. Examples The <c>D3D12HelloTriangle</c> sample uses
		/// <b>ID3D12GraphicsCommandList::Reset</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset HRESULT Reset( [in]
		// ID3D12CommandAllocator *pAllocator, [in, optional] ID3D12PipelineState *pInitialState );
		[PreserveSig]
		new HRESULT Reset([In] ID3D12CommandAllocator pAllocator, [In, Optional] ID3D12PipelineState? pInitialState);

		/// <summary>Resets the state of a direct command list back to the state it was in when the command list was created.</summary>
		/// <param name="pPipelineState">
		/// <para>Type: <b><c>ID3D12PipelineState</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12PipelineState</c> object that contains the initial pipeline state for the command list.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// It is invalid to call <b>ClearState</b> on a bundle. If an app calls <b>ClearState</b> on a bundle, the call to <c>Close</c>
		/// will return <b>E_FAIL</b>.
		/// </para>
		/// <para>
		/// When <b>ClearState</b> is called, all currently bound resources are unbound. The primitive topology is set to
		/// <c>D3D_PRIMITIVE_TOPOLOGY_UNDEFINED</c>. Viewports, scissor rectangles, stencil reference value, and the blend factor are set to
		/// empty values (all zeros). Predication is disabled.
		/// </para>
		/// <para>The app-provided pipeline state object becomes bound as the currently set pipeline state object.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearstate void ClearState( [in,
		// optional] ID3D12PipelineState *pPipelineState );
		[PreserveSig]
		new void ClearState([In, Optional] ID3D12PipelineState? pPipelineState);

		/// <summary>Draws non-indexed, instanced primitives.</summary>
		/// <param name="VertexCountPerInstance">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of vertices to draw.</para>
		/// </param>
		/// <param name="InstanceCount">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of instances to draw.</para>
		/// </param>
		/// <param name="StartVertexLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Index of the first vertex.</para>
		/// </param>
		/// <param name="StartInstanceLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>A value added to each index before reading per-instance data from a vertex buffer.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>A draw API submits work to the rendering pipeline.</para>
		/// <para>
		/// Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing
		/// could be to draw the same object with different positions and colors.
		/// </para>
		/// <para>
		/// The vertex data for an instanced draw call typically comes from a vertex buffer that is bound to the pipeline. But, you could
		/// also provide the vertex data from a shader that has instanced data identified with a system-value semantic (SV_InstanceID).
		/// Examples The <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::DrawInstanced</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-drawinstanced void DrawInstanced(
		// [in] UINT VertexCountPerInstance, [in] UINT InstanceCount, [in] UINT StartVertexLocation, [in] UINT StartInstanceLocation );
		[PreserveSig]
		new void DrawInstanced(uint VertexCountPerInstance, uint InstanceCount, uint StartVertexLocation, uint StartInstanceLocation);

		/// <summary>Draws indexed, instanced primitives.</summary>
		/// <param name="IndexCountPerInstance">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of indices read from the index buffer for each instance.</para>
		/// </param>
		/// <param name="InstanceCount">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Number of instances to draw.</para>
		/// </param>
		/// <param name="StartIndexLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The location of the first index read by the GPU from the index buffer.</para>
		/// </param>
		/// <param name="BaseVertexLocation">
		/// <para>Type: <b><c>INT</c></b></para>
		/// <para>A value added to each index before reading a vertex from the vertex buffer.</para>
		/// </param>
		/// <param name="StartInstanceLocation">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>A value added to each index before reading per-instance data from a vertex buffer.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>A draw API submits work to the rendering pipeline.</para>
		/// <para>
		/// Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing
		/// could be to draw the same object with different positions and colors. Instancing requires multiple vertex buffers: at least one
		/// for per-vertex data and a second buffer for per-instance data. Examples The <c>D3D12Bundles</c> sample uses
		/// <b>ID3D12GraphicsCommandList::DrawIndexedInstanced</b> as follows:
		/// </para>
		/// <para>
		/// <c>void FrameResource::PopulateCommandList(ID3D12GraphicsCommandList* pCommandList, ID3D12PipelineState* pPso1,
		/// ID3D12PipelineState* pPso2, UINT frameResourceIndex, UINT numIndices, D3D12_INDEX_BUFFER_VIEW* pIndexBufferViewDesc,
		/// D3D12_VERTEX_BUFFER_VIEW* pVertexBufferViewDesc, ID3D12DescriptorHeap* pCbvSrvDescriptorHeap, UINT cbvSrvDescriptorSize,
		/// ID3D12DescriptorHeap* pSamplerDescriptorHeap, ID3D12RootSignature* pRootSignature) { // If the root signature matches the root
		/// signature of the caller, then // bindings are inherited, otherwise the bind space is reset.
		/// pCommandList-&gt;SetGraphicsRootSignature(pRootSignature); ID3D12DescriptorHeap* ppHeaps[] = { pCbvSrvDescriptorHeap,
		/// pSamplerDescriptorHeap }; pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// pCommandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		/// pCommandList-&gt;IASetIndexBuffer(pIndexBufferViewDesc); pCommandList-&gt;IASetVertexBuffers(0, 1, pVertexBufferViewDesc);
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(0, pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(1, pSamplerDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart()); //
		/// Calculate the descriptor offset due to multiple frame resources. // 1 SRV + how many CBVs we have currently. UINT
		/// frameResourceDescriptorOffset = 1 + (frameResourceIndex * m_cityRowCount * m_cityColumnCount); CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvSrvHandle(pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart(), frameResourceDescriptorOffset,
		/// cbvSrvDescriptorSize); BOOL usePso1 = TRUE; for (UINT i = 0; i &lt; m_cityRowCount; i++) { for (UINT j = 0; j &lt;
		/// m_cityColumnCount; j++) { // Alternate which PSO to use; the pixel shader is different on // each just as a PSO setting
		/// demonstration. pCommandList-&gt;SetPipelineState(usePso1 ? pPso1 : pPso2); usePso1 = !usePso1; // Set this city's CBV table and
		/// move to the next descriptor. pCommandList-&gt;SetGraphicsRootDescriptorTable(2, cbvSrvHandle);
		/// cbvSrvHandle.Offset(cbvSrvDescriptorSize); pCommandList-&gt;DrawIndexedInstanced(numIndices, 1, 0, 0, 0); } } }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-drawindexedinstanced void
		// DrawIndexedInstanced( [in] UINT IndexCountPerInstance, [in] UINT InstanceCount, [in] UINT StartIndexLocation, [in] INT
		// BaseVertexLocation, [in] UINT StartInstanceLocation );
		[PreserveSig]
		new void DrawIndexedInstanced(uint IndexCountPerInstance, uint InstanceCount, uint StartIndexLocation, int BaseVertexLocation, uint StartInstanceLocation);

		/// <summary>Executes a command list from a thread group.</summary>
		/// <param name="ThreadGroupCountX">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// The number of groups dispatched in the x direction. <i>ThreadGroupCountX</i> must be less than or equal to
		/// D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).
		/// </para>
		/// </param>
		/// <param name="ThreadGroupCountY">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// The number of groups dispatched in the y direction. <i>ThreadGroupCountY</i> must be less than or equal to
		/// D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).
		/// </para>
		/// </param>
		/// <param name="ThreadGroupCountZ">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>
		/// The number of groups dispatched in the z direction. <i>ThreadGroupCountZ</i> must be less than or equal to
		/// D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535). In feature level 10 the value for <i>ThreadGroupCountZ</i> must be 1.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// You call the <b>Dispatch</b> method to execute commands in a compute shader. A compute shader can be run on many threads in
		/// parallel, within a thread group. Index a particular thread, within a thread group using a 3D vector given by (x,y,z). Examples
		/// The <c>D3D12nBodyGravity</c> sample uses <b>ID3D12GraphicsCommandList::Dispatch</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Run the particle simulation using the compute shader. void D3D12nBodyGravity::Simulate(UINT threadIndex) {
		/// ID3D12GraphicsCommandList* pCommandList = m_computeCommandList[threadIndex].Get(); UINT srvIndex; UINT uavIndex; ID3D12Resource
		/// *pUavResource; if (m_srvIndex[threadIndex] == 0) { srvIndex = SrvParticlePosVelo0; uavIndex = UavParticlePosVelo1; pUavResource
		/// = m_particleBuffer1[threadIndex].Get(); } else { srvIndex = SrvParticlePosVelo1; uavIndex = UavParticlePosVelo0; pUavResource =
		/// m_particleBuffer0[threadIndex].Get(); } pCommandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(pUavResource, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE,
		/// D3D12_RESOURCE_STATE_UNORDERED_ACCESS)); pCommandList-&gt;SetPipelineState(m_computeState.Get());
		/// pCommandList-&gt;SetComputeRootSignature(m_computeRootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_srvUavHeap.Get()
		/// }; pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// srvHandle(m_srvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart(), srvIndex + threadIndex, m_srvUavDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE uavHandle(m_srvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart(), uavIndex + threadIndex,
		/// m_srvUavDescriptorSize); pCommandList-&gt;SetComputeRootConstantBufferView(RootParameterCB,
		/// m_constantBufferCS-&gt;GetGPUVirtualAddress()); pCommandList-&gt;SetComputeRootDescriptorTable(RootParameterSRV, srvHandle);
		/// pCommandList-&gt;SetComputeRootDescriptorTable(RootParameterUAV, uavHandle);
		/// pCommandList-&gt;Dispatch(static_cast&lt;int&gt;(ceil(ParticleCount / 128.0f)), 1, 1); pCommandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(pUavResource, D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
		/// D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch void Dispatch( [in] UINT
		// ThreadGroupCountX, [in] UINT ThreadGroupCountY, [in] UINT ThreadGroupCountZ );
		[PreserveSig]
		new void Dispatch(uint ThreadGroupCountX, uint ThreadGroupCountY, uint ThreadGroupCountZ);

		/// <summary>Copies a region of a buffer from one resource to another.</summary>
		/// <param name="pDstBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies the destination <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="DstOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies a UINT64 offset (in bytes) into the destination resource.</para>
		/// </param>
		/// <param name="pSrcBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies the source <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="SrcOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies a UINT64 offset (in bytes) into the source resource, to start the copy from.</para>
		/// </param>
		/// <param name="NumBytes">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies the number of bytes to copy.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Consider using the <c>CopyResource</c> method when copying an entire resource, and use this method for copying regions of a resource.
		/// </para>
		/// <para>
		/// <b>CopyBufferRegion</b> may be used to initialize resources which alias the same heap memory. See <c>CreatePlacedResource</c>
		/// for more details. Examples The <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::CopyBufferRegion</b> as follows:
		/// </para>
		/// <para>
		/// <c>inline UINT64 UpdateSubresources( _In_ ID3D12GraphicsCommandList* pCmdList, _In_ ID3D12Resource* pDestinationResource, _In_
		/// ID3D12Resource* pIntermediate, _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		/// _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources, UINT64 RequiredSize, _In_reads_(NumSubresources)
		/// const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts, _In_reads_(NumSubresources) const UINT* pNumRows,
		/// _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes, _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData)
		/// { // Minor validation D3D12_RESOURCE_DESC IntermediateDesc = pIntermediate-&gt;GetDesc(); D3D12_RESOURCE_DESC DestinationDesc =
		/// pDestinationResource-&gt;GetDesc(); if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER || IntermediateDesc.Width
		/// &lt; RequiredSize + pLayouts[0].Offset || RequiredSize &gt; (SIZE_T)-1 || (DestinationDesc.Dimension ==
		/// D3D12_RESOURCE_DIMENSION_BUFFER &amp;&amp; (FirstSubresource != 0 || NumSubresources != 1))) { return 0; } BYTE* pData; HRESULT
		/// hr = pIntermediate-&gt;Map(0, NULL, reinterpret_cast&lt;void**&gt;(&amp;pData)); if (FAILED(hr)) { return 0; } for (UINT i = 0;
		/// i &lt; NumSubresources; ++i) { if (pRowSizesInBytes[i] &gt; (SIZE_T)-1) return 0; D3D12_MEMCPY_DEST DestData = { pData +
		/// pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, pLayouts[i].Footprint.RowPitch * pNumRows[i] };
		/// MemcpySubresource(&amp;DestData, &amp;pSrcData[i], (SIZE_T)pRowSizesInBytes[i], pNumRows[i], pLayouts[i].Footprint.Depth); }
		/// pIntermediate-&gt;Unmap(0, NULL); if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER) { CD3DX12_BOX SrcBox( UINT(
		/// pLayouts[0].Offset ), UINT( pLayouts[0].Offset + pLayouts[0].Footprint.Width ) ); pCmdList-&gt;CopyBufferRegion(
		/// pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width); } else { for (UINT i = 0; i &lt;
		/// NumSubresources; ++i) { CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
		/// CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]); pCmdList-&gt;CopyTextureRegion(&amp;Dst, 0, 0, 0, &amp;Src,
		/// nullptr); } } return RequiredSize; }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copybufferregion void
		// CopyBufferRegion( [in] ID3D12Resource *pDstBuffer, UINT64 DstOffset, [in] ID3D12Resource *pSrcBuffer, UINT64 SrcOffset, UINT64
		// NumBytes );
		[PreserveSig]
		new void CopyBufferRegion([In] ID3D12Resource pDstBuffer, ulong DstOffset, [In] ID3D12Resource pSrcBuffer, ulong SrcOffset, ulong NumBytes);

		/// <summary>
		/// This method uses the GPU to copy texture data between two locations. Both the source and the destination may reference texture
		/// data located within either a buffer resource or a texture resource.
		/// </summary>
		/// <param name="pDst">
		/// <para>Type: <b>const <c>D3D12_TEXTURE_COPY_LOCATION</c>*</b></para>
		/// <para>
		/// Specifies the destination <c>D3D12_TEXTURE_COPY_LOCATION</c>. The subresource referred to must be in the
		/// D3D12_RESOURCE_STATE_COPY_DEST state.
		/// </para>
		/// </param>
		/// <param name="DstX">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The x-coordinate of the upper left corner of the destination region.</para>
		/// </param>
		/// <param name="DstY">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The y-coordinate of the upper left corner of the destination region. For a 1D subresource, this must be zero.</para>
		/// </param>
		/// <param name="DstZ">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The z-coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero.</para>
		/// </param>
		/// <param name="pSrc">
		/// <para>Type: <b>const <c>D3D12_TEXTURE_COPY_LOCATION</c>*</b></para>
		/// <para>
		/// Specifies the source <c>D3D12_TEXTURE_COPY_LOCATION</c>. The subresource referred to must be in the
		/// D3D12_RESOURCE_STATE_COPY_SOURCE state.
		/// </para>
		/// </param>
		/// <param name="pSrcBox">
		/// <para>Type: <b>const <c>D3D12_BOX</c>*</b></para>
		/// <para>Specifies an optional D3D12_BOX that sets the size of the source texture to copy.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The source box must be within the size of the source resource. The destination offsets, (x, y, and z), allow the source box to
		/// be offset when writing into the destination resource; however, the dimensions of the source box and the offsets must be within
		/// the size of the resource. If you try and copy outside the destination resource or specify a source box that is larger than the
		/// source resource, the behavior of <b>CopyTextureRegion</b> is undefined. If you created a device that supports the <c>debug
		/// layer</c>, the debug output reports an error on this invalid <b>CopyTextureRegion</b> call. Invalid parameters to
		/// <b>CopyTextureRegion</b> cause undefined behavior and might result in incorrect rendering, clipping, no copy, or even the
		/// removal of the rendering device.
		/// </para>
		/// <para>If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels.</para>
		/// <para>
		/// <b>CopyTextureRegion</b> performs the copy on the GPU (similar to a <c>memcpy</c> by the CPU). As a consequence, the source and
		/// destination resources:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>Must be different subresources (although they can be from the same resource).</description>
		/// </item>
		/// <item>
		/// <description>
		/// Must have compatible <c>DXGI_FORMAT</c> s (identical or from the same type group). For example, a DXGI_FORMAT_R32G32B32_FLOAT
		/// texture can be copied to a DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the
		/// DXGI_FORMAT_R32G32B32_TYPELESS group. <b>CopyTextureRegion</b> can copy between a few format types. For more info, see <c>Format
		/// Conversion using Direct3D 10.1</c>.
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// <b>CopyTextureRegion</b> only supports copy; it does not support any stretch, color key, or blend. <b>CopyTextureRegion</b> can
		/// reinterpret the resource data between a few format types.
		/// </para>
		/// <para>Note that for a depth-stencil buffer, the depth and stencil planes are <c>separate subresources</c> within the buffer.</para>
		/// <para>To copy an entire resource, rather than just a region of a subresource, we recommend to use <c>CopyResource</c> instead.</para>
		/// <para>
		/// <b>Note</b>If you use <b>CopyTextureRegion</b> with a depth-stencil buffer or a multisampled resource, you must copy the
		/// entire subresource rectangle. In this situation, you must pass 0 to the <i>DstX</i>, <i>DstY</i>, and <i>DstZ</i> parameters and
		/// <b>NULL</b> to the <i>pSrcBox</i> parameter. In addition, source and destination resources, which are represented by the
		/// <i>pSrcResource</i> and <i>pDstResource</i> parameters, should have identical sample count values.
		/// </para>
		/// <para></para>
		/// <para>
		/// <b>CopyTextureRegion</b> may be used to initialize resources which alias the same heap memory. See <c>CreatePlacedResource</c>
		/// for more details.
		/// </para>
		/// <para><c></c><c></c><c></c> Example</para>
		/// <para>
		/// The following code snippet copies the box (located at (120,100),(200,220)) from a source texture into the region
		/// (10,20),(90,140) in a destination texture.
		/// </para>
		/// <para>
		/// <c>D3D12_BOX sourceRegion; sourceRegion.left = 120; sourceRegion.top = 100; sourceRegion.right = 200; sourceRegion.bottom = 220;
		/// sourceRegion.front = 0; sourceRegion.back = 1; pCmdList -&gt; CopyTextureRegion(pDestTexture, 10, 20, 0, pSourceTexture, &amp;sourceRegion);</c>
		/// </para>
		/// <para>
		/// Notice, that for a 2D texture, front and back are set to 0 and 1 respectively. Examples The <b>HelloTriangle</b> sample uses
		/// <b>ID3D12GraphicsCommandList::CopyTextureRegion</b> as follows:
		/// </para>
		/// <para>
		/// <c>inline UINT64 UpdateSubresources( _In_ ID3D12GraphicsCommandList* pCmdList, _In_ ID3D12Resource* pDestinationResource, _In_
		/// ID3D12Resource* pIntermediate, _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
		/// _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources, UINT64 RequiredSize, _In_reads_(NumSubresources)
		/// const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts, _In_reads_(NumSubresources) const UINT* pNumRows,
		/// _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes, _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData)
		/// { // Minor validation D3D12_RESOURCE_DESC IntermediateDesc = pIntermediate-&gt;GetDesc(); D3D12_RESOURCE_DESC DestinationDesc =
		/// pDestinationResource-&gt;GetDesc(); if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER || IntermediateDesc.Width
		/// &lt; RequiredSize + pLayouts[0].Offset || RequiredSize &gt; (SIZE_T)-1 || (DestinationDesc.Dimension ==
		/// D3D12_RESOURCE_DIMENSION_BUFFER &amp;&amp; (FirstSubresource != 0 || NumSubresources != 1))) { return 0; } BYTE* pData; HRESULT
		/// hr = pIntermediate-&gt;Map(0, NULL, reinterpret_cast&lt;void**&gt;(&amp;pData)); if (FAILED(hr)) { return 0; } for (UINT i = 0;
		/// i &lt; NumSubresources; ++i) { if (pRowSizesInBytes[i] &gt; (SIZE_T)-1) return 0; D3D12_MEMCPY_DEST DestData = { pData +
		/// pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, pLayouts[i].Footprint.RowPitch * pNumRows[i] };
		/// MemcpySubresource(&amp;DestData, &amp;pSrcData[i], (SIZE_T)pRowSizesInBytes[i], pNumRows[i], pLayouts[i].Footprint.Depth); }
		/// pIntermediate-&gt;Unmap(0, NULL); if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER) { CD3DX12_BOX SrcBox( UINT(
		/// pLayouts[0].Offset ), UINT( pLayouts[0].Offset + pLayouts[0].Footprint.Width ) ); pCmdList-&gt;CopyBufferRegion(
		/// pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width); } else { for (UINT i = 0; i &lt;
		/// NumSubresources; ++i) { CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
		/// CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]); pCmdList-&gt;CopyTextureRegion(&amp;Dst, 0, 0, 0, &amp;Src,
		/// nullptr); } } return RequiredSize; }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion void
		// CopyTextureRegion( [in] const D3D12_TEXTURE_COPY_LOCATION *pDst, UINT DstX, UINT DstY, UINT DstZ, [in] const
		// D3D12_TEXTURE_COPY_LOCATION *pSrc, [in, optional] const D3D12_BOX *pSrcBox );
		[PreserveSig]
		new void CopyTextureRegion(in D3D12_TEXTURE_COPY_LOCATION pDst, uint DstX, uint DstY, uint DstZ, in D3D12_TEXTURE_COPY_LOCATION pSrc,
			[In, Optional] StructPointer<D3D12_BOX> pSrcBox);

		/// <summary>Copies the entire contents of the source resource to the destination resource.</summary>
		/// <param name="pDstResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the destination resource.</para>
		/// </param>
		/// <param name="pSrcResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the source resource.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>CopyResource</b> operations are performed on the GPU, and do not incur a significant CPU workload linearly dependent on the
		/// size of the data to copy.
		/// </para>
		/// <para>
		/// <b>CopyResource</b> can be used to initialize resources that alias the same heap memory. See <c>CreatePlacedResource</c> for
		/// more details.
		/// </para>
		/// <para>Debug layer</para>
		/// <para>The debug layer issues an error if the source subresource is not in the <c>D3D12_RESOURCE_STATE_COPY_SOURCE</c> state.</para>
		/// <para>
		/// The debug layer issues an error if the destination subresource is not in the <c>D3D12_RESOURCE_STATE_COPY_DEST</c> state.
		/// Restrictions This method has a few restrictions designed for improving performance. For instance, the source and destination resources:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>Must be different resources.</description>
		/// </item>
		/// <item>
		/// <description>Must be the same type.</description>
		/// </item>
		/// <item>
		/// <description>Must be the same total size (bytes).</description>
		/// </item>
		/// <item>
		/// <description>Must have identical dimensions (width, height, depth) or be a compatible <c>Reinterpret Copy</c>.</description>
		/// </item>
		/// <item>
		/// <description>
		/// Must have compatible <c>DXGI formats</c>, which means the formats must be identical or at least from the same type group. For
		/// example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to a DXGI_FORMAT_R32G32B32_UINT texture since both of these formats
		/// are in the DXGI_FORMAT_R32G32B32_TYPELESS group. <b>CopyResource</b> can copy between a few format types (see <c>Reinterpret copy</c>).
		/// </description>
		/// </item>
		/// <item>
		/// <description>Can't be currently mapped.</description>
		/// </item>
		/// </list>
		/// <para><b>CopyResource</b> only supports copy; it doesn't support any stretch, color key, or blend.</para>
		/// <para>
		/// <b>CopyResource</b> can reinterpret the resource data between a few format types, see <c>Reinterpret Copy</c> below for details.
		/// </para>
		/// <para>
		/// You can use a <c>depth-stencil</c> resource as either a source or a destination. Resources created with multi-sampling
		/// capability (see <c>DXGI_SAMPLE_DESC</c>) can be used as source and destination only if both source and destination have
		/// identical multi-sampled count and quality. If source and destination differ in multi-sampled count and quality or if one is
		/// multi-sampled and the other is not multi-sampled, the call to <b>CopyResource</b> fails. Use <c>ResolveSubresource</c> to
		/// resolve a multi-sampled resource to a resource that is not multi-sampled.
		/// </para>
		/// <para>
		/// The method is an asynchronous call, which may be added to the command-buffer queue. This attempts to remove pipeline stalls that
		/// may occur when copying data. For more info, see <c>performance considerations</c>.
		/// </para>
		/// <para>
		/// Consider using <c>CopyTextureRegion</c> or <c>CopyBufferRegion</c> if you only need to copy a portion of the data in a resource.
		/// </para>
		/// <para>Reinterpret copy</para>
		/// <para>
		/// The following table lists the allowable source and destination formats that you can use in the reinterpretation type of format
		/// conversion. The underlying data values are not converted or compressed/decompressed and must be encoded properly for the
		/// reinterpretation to work as expected. For more info, see <c>Format Conversion using Direct3D 10.1</c>.
		/// </para>
		/// <para>For DXGI_FORMAT_R9G9B9E5_SHAREDEXP the width and height must be equal (1 texel per block).</para>
		/// <para>
		/// Block-compressed resource width and height must be 4 times the uncompressed resource width and height (16 texels per block). For
		/// example, a uncompressed 256x256 DXGI_FORMAT_R32G32B32A32_UINT texture will map to a 1024x1024 DXGI_FORMAT_BC5_UNORM compressed texture.
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Bit width</description>
		/// <description>Uncompressed resource</description>
		/// <description>Block-compressed resource</description>
		/// <description>Width / height difference</description>
		/// </listheader>
		/// <item>
		/// <description>32</description>
		/// <description>DXGI_FORMAT_R32_UINT DXGI_FORMAT_R32_SINT</description>
		/// <description>DXGI_FORMAT_R9G9B9E5_SHAREDEXP</description>
		/// <description>1:1</description>
		/// </item>
		/// <item>
		/// <description>64</description>
		/// <description>DXGI_FORMAT_R16G16B16A16_UINT DXGI_FORMAT_R16G16B16A16_SINT DXGI_FORMAT_R32G32_UINT DXGI_FORMAT_R32G32_SINT</description>
		/// <description>DXGI_FORMAT_BC1_UNORM[_SRGB] DXGI_FORMAT_BC4_UNORM DXGI_FORMAT_BC4_SNORM</description>
		/// <description>1:4</description>
		/// </item>
		/// <item>
		/// <description>128</description>
		/// <description>DXGI_FORMAT_R32G32B32A32_UINT DXGI_FORMAT_R32G32B32A32_SINT</description>
		/// <description>DXGI_FORMAT_BC2_UNORM[_SRGB] DXGI_FORMAT_BC3_UNORM[_SRGB] DXGI_FORMAT_BC5_UNORM DXGI_FORMAT_BC5_SNORM</description>
		/// <description>1:4</description>
		/// </item>
		/// </list>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copyresource void CopyResource( [in]
		// ID3D12Resource *pDstResource, [in] ID3D12Resource *pSrcResource );
		[PreserveSig]
		new void CopyResource([In] ID3D12Resource pDstResource, [In] ID3D12Resource pSrcResource);

		/// <summary>Copies tiles from buffer to tiled resource or vice versa.</summary>
		/// <param name="pTiledResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to a tiled resource.</para>
		/// </param>
		/// <param name="pTileRegionStartCoordinate">
		/// <para>Type: <b>const <c>D3D12_TILED_RESOURCE_COORDINATE</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_TILED_RESOURCE_COORDINATE</c> structure that describes the starting coordinates of the tiled resource.</para>
		/// </param>
		/// <param name="pTileRegionSize">
		/// <para>Type: <b>const <c>D3D12_TILE_REGION_SIZE</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_TILE_REGION_SIZE</c> structure that describes the size of the tiled region.</para>
		/// </param>
		/// <param name="pBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para>A pointer to an <c>ID3D12Resource</c> that represents a default, dynamic, or staging buffer.</para>
		/// </param>
		/// <param name="BufferStartOffsetInBytes">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The offset in bytes into the buffer at <i>pBuffer</i> to start the operation.</para>
		/// </param>
		/// <param name="Flags">
		/// <para>Type: <b><c>D3D12_TILE_COPY_FLAGS</c></b></para>
		/// <para>
		/// A combination of <c>D3D12_TILE_COPY_FLAGS</c>-typed values that are combined by using a bitwise OR operation and that identifies
		/// how to copy tiles.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>CopyTiles</b> drops write operations to unmapped areas and handles read operations from unmapped areas (except on Tier_1
		/// tiled resources, where reading and writing unmapped areas is invalid - refer to <c>D3D12_TILED_RESOURCES_TIER</c>).
		/// </para>
		/// <para>
		/// If a copy operation involves writing to the same memory location multiple times because multiple locations in the destination
		/// resource are mapped to the same tile memory, the resulting write operations to multi-mapped tiles are non-deterministic and
		/// non-repeatable; that is, accesses to the tile memory happen in whatever order the hardware happens to execute the copy operation.
		/// </para>
		/// <para>
		/// The tiles involved in the copy operation can't include tiles that contain packed mipmaps or results of the copy operation are
		/// undefined. To transfer data to and from mipmaps that the hardware packs into the one-or-more tiles that constitute the packed
		/// mips, you must use the standard (that is, non-tile specific) copy APIs like <c>CopyTextureRegion</c>.
		/// </para>
		/// <para><b>CopyTiles</b> does copy data in a slightly different pattern than the standard copy methods.</para>
		/// <para>
		/// The memory layout of the tiles in the non-tiled buffer resource side of the copy operation is linear in memory within 64 KB
		/// tiles, which the hardware and driver swizzle and de-swizzle per tile as appropriate when they transfer to and from a tiled
		/// resource. For multisample antialiasing (MSAA) surfaces, the hardware and driver traverse each pixel's samples in sample-index
		/// order before they move to the next pixel. For tiles that are partially filled on the right side (for a surface that has a width
		/// not a multiple of tile width in pixels), the pitch and stride to move down a row is the full size in bytes of the number pixels
		/// that would fit across the tile if the tile was full. So, there can be a gap between each row of pixels in memory. Mipmaps that
		/// are smaller than a tile are not packed together in the linear layout, which might seem to be a waste of memory space, but as
		/// mentioned you can't use <b>CopyTiles</b> to copy to mipmaps that the hardware packs together. You can just use generic copy
		/// APIs, like <c>CopyTextureRegion</c>, to copy small mipmaps individually.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytiles void CopyTiles( [in]
		// ID3D12Resource *pTiledResource, [in] const D3D12_TILED_RESOURCE_COORDINATE *pTileRegionStartCoordinate, [in] const
		// D3D12_TILE_REGION_SIZE *pTileRegionSize, [in] ID3D12Resource *pBuffer, UINT64 BufferStartOffsetInBytes, D3D12_TILE_COPY_FLAGS
		// Flags );
		[PreserveSig]
		new void CopyTiles([In] ID3D12Resource pTiledResource, in D3D12_TILED_RESOURCE_COORDINATE pTileRegionStartCoordinate,
			in D3D12_TILE_REGION_SIZE pTileRegionSize, [In] ID3D12Resource pBuffer, ulong BufferStartOffsetInBytes, D3D12_TILE_COPY_FLAGS Flags);

		/// <summary>Copy a multi-sampled resource into a non-multi-sampled resource.</summary>
		/// <param name="pDstResource">
		/// <para>Type: [in] <b>ID3D12Resource*</b></para>
		/// <para>Destination resource. Must be a created on a <c>D3D12_HEAP_TYPE_DEFAULT</c> heap and be single-sampled. See <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="DstSubresource">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>
		/// A zero-based index, that identifies the destination subresource. Use <c>D3D12CalcSubresource</c> to calculate the subresource
		/// index if the parent resource is complex.
		/// </para>
		/// </param>
		/// <param name="pSrcResource">
		/// <para>Type: [in] <b>ID3D12Resource*</b></para>
		/// <para>Source resource. Must be multisampled.</para>
		/// </param>
		/// <param name="SrcSubresource">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The source subresource of the source resource.</para>
		/// </param>
		/// <param name="Format">
		/// <para>Type: [in] <b>DXGI_FORMAT</b></para>
		/// <para>A <c>DXGI_FORMAT</c> that indicates how the multisampled resource will be resolved to a single-sampled resource. See remarks.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>
		/// The debug layer will issue an error if the subresources referenced by the source view is not in the
		/// <c>D3D12_RESOURCE_STATE_RESOLVE_SOURCE</c> state.
		/// </para>
		/// <para>The debug layer will issue an error if the destination buffer is not in the <c>D3D12_RESOURCE_STATE_RESOLVE_DEST</c> state.</para>
		/// <para>
		/// The source and destination resources must be the same resource type and have the same dimensions. In addition, they must have
		/// compatible formats. There are three scenarios for this:
		/// </para>
		/// <list type="table">
		/// <listheader>
		/// <description>Scenario</description>
		/// <description>Requirements</description>
		/// </listheader>
		/// <item>
		/// <description>Source and destination are prestructured and typed</description>
		/// <description>
		/// Both the source and destination must have identical formats and that format must be specified in the Format parameter.
		/// </description>
		/// </item>
		/// <item>
		/// <description>One resource is prestructured and typed and the other is prestructured and typeless</description>
		/// <description>
		/// The typed resource must have a format that is compatible with the typeless resource (i.e. the typed resource is
		/// DXGI_FORMAT_R32_FLOAT and the typeless resource is DXGI_FORMAT_R32_TYPELESS). The format of the typed resource must be specified
		/// in the Format parameter.
		/// </description>
		/// </item>
		/// <item>
		/// <description>Source and destination are prestructured and typeless</description>
		/// <description>
		/// Both the source and destination must have the same typeless format (i.e. both must have DXGI_FORMAT_R32_TYPELESS), and the
		/// Format parameter must specify a format that is compatible with the source and destination (i.e. if both are
		/// DXGI_FORMAT_R32_TYPELESS then DXGI_FORMAT_R32_FLOAT could be specified in the Format parameter). For example, given the
		/// DXGI_FORMAT_R16G16B16A16_TYPELESS format:
		/// </description>
		/// </item>
		/// </list>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvesubresource void
		// ResolveSubresource( ID3D12Resource *pDstResource, UINT DstSubresource, ID3D12Resource *pSrcResource, UINT SrcSubresource,
		// DXGI_FORMAT Format );
		[PreserveSig]
		new void ResolveSubresource([In] ID3D12Resource pDstResource, uint DstSubresource, [In] ID3D12Resource pSrcResource, uint SrcSubresource,
			DXGI_FORMAT Format);

		/// <summary>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</summary>
		/// <param name="PrimitiveTopology">
		/// <para>Type: <b>D3D12_PRIMITIVE_TOPOLOGY</b></para>
		/// <para>The type of primitive and ordering of the primitive data (see <c>D3D_PRIMITIVE_TOPOLOGY</c>).</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-iasetprimitivetopology void
		// IASetPrimitiveTopology( [in] D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology );
		[PreserveSig]
		new void IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY PrimitiveTopology);

		/// <summary>Bind an array of viewports to the rasterizer stage of the pipeline.</summary>
		/// <param name="NumViewports">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Number of viewports to bind. The range of valid values is (0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE).</para>
		/// </param>
		/// <param name="pViewports">
		/// <para>Type: <b>const <c>D3D12_VIEWPORT</c>*</b></para>
		/// <para>An array of <c>D3D12_VIEWPORT</c> structures to bind to the device.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled.</para>
		/// <para>
		/// Which viewport to use is determined by the <c>SV_ViewportArrayIndex</c> semantic output by a geometry shader; if a geometry
		/// shader does not specify the semantic, Direct3D will use the first viewport in the array. Examples The <c>D3D12HelloTriangle</c>
		/// sample uses <b>ID3D12GraphicsCommandList::RSSetViewports</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-rssetviewports void RSSetViewports(
		// [in] UINT NumViewports, [in] const D3D12_VIEWPORT *pViewports );
		[PreserveSig]
		new void RSSetViewports(int NumViewports, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_VIEWPORT[] pViewports);

		/// <summary>Binds an array of scissor rectangles to the rasterizer stage.</summary>
		/// <param name="NumRects">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of scissor rectangles to bind.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: <b>const D3D12_RECT*</b></para>
		/// <para>An array of scissor rectangles.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>All scissor rectangles must be set atomically as one operation. Any scissor rectangles not defined by the call are disabled.</para>
		/// <para>
		/// Which scissor rectangle to use is determined by the <c>SV_ViewportArrayIndex</c> semantic output by a geometry shader (see
		/// shader semantic syntax). If a geometry shader does not make use of the <c>SV_ViewportArrayIndex</c> semantic then Direct3D will
		/// use the first scissor rectangle in the array.
		/// </para>
		/// <para>
		/// Each scissor rectangle in the array corresponds to a viewport in an array of viewports (see <c>RSSetViewports</c>). Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::RSSetScissorRects</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>// Command list allocators can only be reset when the associated // command lists have finished execution on the GPU; apps
		/// should use // fences to determine GPU execution progress. ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when
		/// ExecuteCommandList() is called on a particular command // list, that command list can then be reset at any time and must be
		/// before // re-recording. ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set
		/// necessary state. m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1,
		/// &amp;m_viewport); m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a
		/// render target. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT,
		/// D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close());</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-rssetscissorrects void
		// RSSetScissorRects( [in] UINT NumRects, [in] const D3D12_RECT *pRects );
		[PreserveSig]
		new void RSSetScissorRects(int NumRects, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] RECT[] pRects);

		/// <summary>Sets the blend factor that modulate values for a pixel shader, render target, or both.</summary>
		/// <param name="BlendFactor">
		/// <para>Type: <b>const FLOAT[4]</b></para>
		/// <para>Array of blend factors, one for each RGBA component.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// If you created the blend-state object with <c>D3D12_BLEND_BLEND_FACTOR</c> or <b>D3D12_BLEND_INV_BLEND_FACTOR</b>, then the
		/// blending stage uses the non-NULL array of blend factors. Otherwise,the blending stage doesn't use the non-NULL array of blend
		/// factors; the runtime stores the blend factors.
		/// </para>
		/// <para>If you pass NULL, then the runtime uses or stores a blend factor equal to <c>{ 1, 1, 1, 1 }</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetblendfactor void
		// OMSetBlendFactor( [in, optional] const FLOAT [4] BlendFactor );
		[PreserveSig]
		new void OMSetBlendFactor([In, Out, Optional, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] float[]? BlendFactor);

		/// <summary>Sets the reference value for depth stencil tests.</summary>
		/// <param name="StencilRef">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Reference value to perform against when doing a depth-stencil test.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetstencilref void
		// OMSetStencilRef( [in] UINT StencilRef );
		[PreserveSig]
		new void OMSetStencilRef(uint StencilRef);

		/// <summary>Sets all shaders and programs most of the fixed-function state of the graphics processing unit (GPU) pipeline.</summary>
		/// <param name="pPipelineState">
		/// <para>Type: <b><c>ID3D12PipelineState</c>*</b></para>
		/// <para>Pointer to the <c>ID3D12PipelineState</c> containing the pipeline state data.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setpipelinestate void
		// SetPipelineState( [in] ID3D12PipelineState *pPipelineState );
		[PreserveSig]
		new void SetPipelineState([In] ID3D12PipelineState pPipelineState);

		/// <summary>Notifies the driver that it needs to synchronize multiple accesses to resources.</summary>
		/// <param name="NumBarriers">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of submitted barrier descriptions.</para>
		/// </param>
		/// <param name="pBarriers">
		/// <para>Type: <b>const <c>D3D12_RESOURCE_BARRIER</c>*</b></para>
		/// <para>Pointer to an array of barrier descriptions.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <para>Note</para>
		/// <para>
		/// A resource to be used for the <c>D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE</c> state must be created in that state,
		/// and then never transitioned out of it. Nor may a resource that was created not in that state be transitioned into it. For more
		/// info, see <c>Acceleration structure memory restrictions</c> in the DirectX raytracing (DXR) functional specification on GitHub.
		/// </para>
		/// </para>
		/// <para>There are three types of barrier descriptions:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// <c>D3D12_RESOURCE_TRANSITION_BARRIER</c> - Transition barriers indicate that a set of subresources transition between different
		/// usages. The caller must specify the <i>before</i> and <i>after</i> usages of the subresources. The
		/// D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES flag is used to transition all subresources in a resource at the same time.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// <c>D3D12_RESOURCE_ALIASING_BARRIER</c> - Aliasing barriers indicate a transition between usages of two different resources which
		/// have mappings into the same heap. The application can specify both the before and the after resource. Note that one or both
		/// resources can be NULL (indicating that any tiled resource could cause aliasing).
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// <c>D3D12_RESOURCE_UAV_BARRIER</c> - Unordered access view barriers indicate all UAV accesses (read or writes) to a particular
		/// resource must complete before any future UAV accesses (read or write) can begin. The specified resource may be NULL. It is not
		/// necessary to insert a UAV barrier between two draw or dispatch calls which only read a UAV. Additionally, it is not necessary to
		/// insert a UAV barrier between two draw or dispatch calls which write to the same UAV if the application knows that it is safe to
		/// execute the UAV accesses in any order. The resource can be NULL (indicating that any UAV access could require the barrier).
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// When <b>ID3D12GraphicsCommandList::ResourceBarrier</b> is passed an array of resource barrier descriptions, the API behaves as
		/// if it was called N times (1 for each array element), in the specified order. Transitions should be batched together into a
		/// single API call when possible, as a performance optimization.
		/// </para>
		/// <para>
		/// For descriptions of the usage states a subresource can be in, see the <c>D3D12_RESOURCE_STATES</c> enumeration and the <c>Using
		/// Resource Barriers to Synchronize Resource States in Direct3D 12</c> section.
		/// </para>
		/// <para>
		/// All subresources in a resource must be in the RENDER_TARGET state, or DEPTH_WRITE state, for render targets/depth-stencil
		/// resources respectively, when <c>ID3D12GraphicsCommandList::DiscardResource</c> is called.
		/// </para>
		/// <para>
		/// When a back buffer is presented, it must be in the D3D12_RESOURCE_STATE_PRESENT state. If <c>IDXGISwapChain1::Present1</c> is
		/// called on a resource which is not in the PRESENT state, a debug layer warning will be emitted.
		/// </para>
		/// <para>The resource usage bits are group into two categories, read-only and read/write.</para>
		/// <para>The following usage bits are read-only:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_INDEX_BUFFER</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_COPY_SOURCE</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_DEPTH_READ</description>
		/// </item>
		/// </list>
		/// <para>The following usage bits are read/write:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_DEPTH_WRITE</description>
		/// </item>
		/// </list>
		/// <para>The following usage bits are write-only:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_COPY_DEST</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_RENDER_TARGET</description>
		/// </item>
		/// <item>
		/// <description>D3D12_RESOURCE_STATE_STREAM_OUT</description>
		/// </item>
		/// </list>
		/// <para>
		/// At most one write bit can be set. If any write bit is set, then no read bit may be set. If no write bit is set, then any number
		/// of read bits may be set.
		/// </para>
		/// <para>
		/// At any given time, a subresource is in exactly one state (determined by a set of flags). The application must ensure that the
		/// states are matched when making a sequence of <b>ResourceBarrier</b> calls. In other words, the before and after states in
		/// consecutive calls to <b>ResourceBarrier</b> must agree.
		/// </para>
		/// <para>
		/// To transition all subresources within a resource, the application can set the subresource index to
		/// D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES, which implies that all subresources are changed.
		/// </para>
		/// <para>
		/// For improved performance, applications should use split barriers (refer to <c>Multi-engine synchronization</c>). Your
		/// application should also batch multiple transitions into a single call whenever possible.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>The runtime will validate that the barrier type values are valid members of the <c>D3D12_RESOURCE_BARRIER_TYPE</c> enumeration.</para>
		/// <para>In addition, the runtime checks the following:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>The resource pointer is non-NULL.</description>
		/// </item>
		/// <item>
		/// <description>The subresource index is valid</description>
		/// </item>
		/// <item>
		/// <description>
		/// The before and after states are supported by the <c>D3D12_RESOURCE_BINDING_TIER</c> and <c>D3D12_RESOURCE_FLAGS</c> flags of the resource.
		/// </description>
		/// </item>
		/// <item>
		/// <description>Reserved bits in the state masks are not set.</description>
		/// </item>
		/// <item>
		/// <description>The before and after states are different.</description>
		/// </item>
		/// <item>
		/// <description>The set of bits in the before and after states are valid.</description>
		/// </item>
		/// <item>
		/// <description>
		/// If the D3D12_RESOURCE_STATE_RESOLVE_SOURCE bit is set, then the resource sample count must be greater than 1.
		/// </description>
		/// </item>
		/// <item>
		/// <description>If the D3D12_RESOURCE_STATE_RESOLVE_DEST bit is set, then the resource sample count must be equal to 1.</description>
		/// </item>
		/// </list>
		/// <para>For aliasing barriers the runtime will validate that, if either resource pointer is non-NULL, it refers to a tiled resource.</para>
		/// <para>
		/// For UAV barriers the runtime will validate that, if the resource is non-NULL, the resource has the
		/// D3D12_RESOURCE_STATE_UNORDERED_ACCESS bind flag set.
		/// </para>
		/// <para>Validation failure causes <c>ID3D12GraphicsCommandList::Close</c> to return E_INVALIDARG.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>The debug layer normally issues errors where runtime validation fails:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// If a subresource transition in a command list is inconsistent with previous transitions in the same command list.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// If a resource is used without first calling <b>ResourceBarrier</b> to put the resource into the correct state.
		/// </description>
		/// </item>
		/// <item>
		/// <description>If a resource is illegally bound for read and write at the same time.</description>
		/// </item>
		/// <item>
		/// <description>
		/// If the <i>before</i> states passed to the <b>ResourceBarrier</b> do not match the <i>after</i> states of previous calls to
		/// <b>ResourceBarrier</b>, including the aliasing case.
		/// </description>
		/// </item>
		/// </list>
		/// <para>
		/// Whereas the debug layer attempts to validate the runtime rules, it operates conservatively so that debug layer errors are real
		/// errors, and in some cases real errors may not produce debug layer errors.
		/// </para>
		/// <para>The debug layer will issue warnings in the following cases:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>All of the cases where the D3D12 debug layer would issues warnings for <c>ID3D12GraphicsCommandList::ResourceBarrier</c>.</description>
		/// </item>
		/// <item>
		/// <description>
		/// If a depth buffer is used in a non-read-only mode while the resource has the D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE usage
		/// bit set.
		/// </description>
		/// </item>
		/// </list>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier void
		// ResourceBarrier( [in] UINT NumBarriers, [in] const D3D12_RESOURCE_BARRIER *pBarriers );
		[PreserveSig]
		new void ResourceBarrier(int NumBarriers, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_RESOURCE_BARRIER[] pBarriers);

		/// <summary>Executes a bundle.</summary>
		/// <param name="pCommandList">
		/// <para>Type: <b><c>ID3D12GraphicsCommandList</c>*</b></para>
		/// <para>Specifies the <c>ID3D12GraphicsCommandList</c> that determines the bundle to be executed.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Bundles inherit all state from the parent command list on which <b>ExecuteBundle</b> is called, except the pipeline state object
		/// and primitive topology. All of the state that is set in a bundle will affect the state of the parent command list. Note that
		/// <b>ExecuteBundle</b> is not a predicated operation.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>
		/// The runtime will validate that the "callee" is a bundle and that the "caller" is a direct command list. The runtime will also
		/// validate that the bundle has been closed. If the contract is violated, the runtime will silently drop the call. Validation
		/// failure will result in <c>Close</c> returning E_INVALIDARG.
		/// </para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>
		/// The debug layer will issue a warning in the same cases where the runtime will fail. The debug layer will issue a warning if a
		/// predicate is set when <c>ExecuteCommandList</c> is called. Also, the debug layer will issue an error if it detects that any
		/// resource reference by the command list has been destroyed.
		/// </para>
		/// <para>
		/// The debug layer will also validate that the command allocator associated with the bundle has not been reset since <c>Close</c>
		/// was called on the command list. This validation occurs at <b>ExecuteBundle</b> time, and when the parent command list is
		/// executed on a command queue. Examples The <c>D3D12Bundles</c> sample uses <b>ID3D12GraphicsCommandList::ExecuteBundle</b> as follows:
		/// </para>
		/// <para>
		/// <c>void D3D12Bundles::PopulateCommandList(FrameResource* pFrameResource) { // Command list allocators can only be reset when the
		/// associated // command lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a
		/// particular command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_pCurrentFrameResource-&gt;m_commandAllocator.Get(), m_pipelineState1.Get())); // Set
		/// necessary state. m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = {
		/// m_cbvSrvHeap.Get(), m_samplerHeap.Get() }; m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// m_commandList-&gt;RSSetViewports(1, &amp;m_viewport); m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate
		/// that the back buffer will be used as a render target. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT,
		/// D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;ClearDepthStencilView(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0,
		/// nullptr); if (UseBundles) { // Execute the prebuilt bundle. m_commandList-&gt;ExecuteBundle(pFrameResource-&gt;m_bundle.Get());
		/// } else { // Populate a new command list. pFrameResource-&gt;PopulateCommandList(m_commandList.Get(), m_pipelineState1.Get(),
		/// m_pipelineState2.Get(), m_currentFrameResourceIndex, m_numIndices, &amp;m_indexBufferView, &amp;m_vertexBufferView,
		/// m_cbvSrvHeap.Get(), m_cbvSrvDescriptorSize, m_samplerHeap.Get(), m_rootSignature.Get()); } // Indicate that the back buffer will
		/// now be used to present. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET,
		/// D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-executebundle void ExecuteBundle(
		// [in] ID3D12GraphicsCommandList *pCommandList );
		[PreserveSig]
		new void ExecuteBundle([In] ID3D12GraphicsCommandList pCommandList);

		/// <summary>Changes the currently bound descriptor heaps that are associated with a command list.</summary>
		/// <param name="NumDescriptorHeaps">
		/// <para>Type: [in] <b><c>UINT</c></b></para>
		/// <para>Number of descriptor heaps to bind.</para>
		/// </param>
		/// <param name="ppDescriptorHeaps">
		/// <para>Type: [in] <b><c>ID3D12DescriptorHeap</c>*</b></para>
		/// <para>A pointer to an array of <c>ID3D12DescriptorHeap</c> objects for the heaps to set on the command list.</para>
		/// <para>You can only bind descriptor heaps of type <c><b>D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV</b></c> and <c><b>D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER</b></c>.</para>
		/// <para>
		/// Only one descriptor heap of each type can be set at one time, which means a maximum of 2 heaps (one sampler, one CBV/SRV/UAV)
		/// can be set at one time.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>SetDescriptorHeaps</b> can be called on a bundle, but the bundle descriptor heaps must match the calling command list
		/// descriptor heap. For more information on bundle restrictions, refer to <c>Creating and Recording Command Lists and Bundles</c>.
		/// </para>
		/// <para>All previously set heaps are unset by the call. At most one heap of each shader-visible type can be set in the call.</para>
		/// <para>
		/// Changing descriptor heaps can incur a pipeline flush on some hardware. Because of this, it is recommended to use a single
		/// shader-visible heap of each type, and set it once per frame, rather than regularly changing the bound descriptor heaps. Instead,
		/// use <c><b>ID3D12Device::CopyDescriptors</b></c> and <c><b>ID3D12Device::CopyDescriptorsSimple</b></c> to copy the required
		/// descriptors from shader-opaque heaps to the single shader-visible heap as required during rendering.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps void
		// SetDescriptorHeaps( UINT NumDescriptorHeaps, ID3D12DescriptorHeap * const *ppDescriptorHeaps );
		[PreserveSig]
		new void SetDescriptorHeaps(int NumDescriptorHeaps, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ID3D12DescriptorHeap[] ppDescriptorHeaps);

		/// <summary>Sets the layout of the compute root signature.</summary>
		/// <param name="pRootSignature">
		/// <para>Type: <b><c>ID3D12RootSignature</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12RootSignature</c> object.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootsignature void
		// SetComputeRootSignature( [in, optional] ID3D12RootSignature *pRootSignature );
		[PreserveSig]
		new void SetComputeRootSignature([In, Optional] ID3D12RootSignature? pRootSignature);

		/// <summary>Sets the layout of the graphics root signature.</summary>
		/// <param name="pRootSignature">
		/// <para>Type: <b><c>ID3D12RootSignature</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12RootSignature</c> object.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootsignature void
		// SetGraphicsRootSignature( [in, optional] ID3D12RootSignature *pRootSignature );
		[PreserveSig]
		new void SetGraphicsRootSignature([In, Optional] ID3D12RootSignature? pRootSignature);

		/// <summary>Sets a descriptor table into the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BaseDescriptor">
		/// <para>Type: <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A GPU_descriptor_handle object for the base descriptor to set.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable void
		// SetComputeRootDescriptorTable( [in] UINT RootParameterIndex, [in] D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor );
		[PreserveSig]
		new void SetComputeRootDescriptorTable(uint RootParameterIndex, D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);

		/// <summary>Sets a descriptor table into the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BaseDescriptor">
		/// <para>Type: <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>A GPU_descriptor_handle object for the base descriptor to set.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable void
		// SetGraphicsRootDescriptorTable( [in] UINT RootParameterIndex, [in] D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor );
		[PreserveSig]
		new void SetGraphicsRootDescriptorTable(uint RootParameterIndex, D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor);

		/// <summary>Sets a constant in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="SrcData">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The source data for the constant to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The offset, in 32-bit values, to set the constant in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputeroot32bitconstant void
		// SetComputeRoot32BitConstant( [in] UINT RootParameterIndex, [in] UINT SrcData, [in] UINT DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetComputeRoot32BitConstant(uint RootParameterIndex, uint SrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a constant in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="SrcData">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The source data for the constant to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The offset, in 32-bit values, to set the constant in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsroot32bitconstant void
		// SetGraphicsRoot32BitConstant( [in] UINT RootParameterIndex, [in] UINT SrcData, [in] UINT DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetGraphicsRoot32BitConstant(uint RootParameterIndex, uint SrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a group of constants in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="Num32BitValuesToSet">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of constants to set in the root signature.</para>
		/// </param>
		/// <param name="pSrcData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>The source data for the group of constants to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The offset, in 32-bit values, to set the first constant of the group in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputeroot32bitconstants void
		// SetComputeRoot32BitConstants( [in] UINT RootParameterIndex, [in] UINT Num32BitValuesToSet, [in] const void *pSrcData, [in] UINT
		// DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetComputeRoot32BitConstants(uint RootParameterIndex, uint Num32BitValuesToSet,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] uint[] pSrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a group of constants in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="Num32BitValuesToSet">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of constants to set in the root signature.</para>
		/// </param>
		/// <param name="pSrcData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>The source data for the group of constants to set.</para>
		/// </param>
		/// <param name="DestOffsetIn32BitValues">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The offset, in 32-bit values, to set the first constant of the group in the root signature.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsroot32bitconstants void
		// SetGraphicsRoot32BitConstants( [in] UINT RootParameterIndex, [in] UINT Num32BitValuesToSet, [in] const void *pSrcData, [in] UINT
		// DestOffsetIn32BitValues );
		[PreserveSig]
		new void SetGraphicsRoot32BitConstants(uint RootParameterIndex, uint Num32BitValuesToSet,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] uint[] pSrcData, uint DestOffsetIn32BitValues);

		/// <summary>Sets a CPU descriptor handle for the constant buffer in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>Specifies the D3D12_GPU_VIRTUAL_ADDRESS of the constant buffer.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootconstantbufferview
		// void SetComputeRootConstantBufferView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetComputeRootConstantBufferView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the constant buffer in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the constant buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootconstantbufferview
		// void SetGraphicsRootConstantBufferView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetGraphicsRootConstantBufferView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the shader resource in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootshaderresourceview
		// void SetComputeRootShaderResourceView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetComputeRootShaderResourceView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the shader resource in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the Buffer. Textures are not supported. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootshaderresourceview
		// void SetGraphicsRootShaderResourceView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetGraphicsRootShaderResourceView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the unordered-access-view resource in the compute root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootunorderedaccessview
		// void SetComputeRootUnorderedAccessView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetComputeRootUnorderedAccessView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets a CPU descriptor handle for the unordered-access-view resource in the graphics root signature.</summary>
		/// <param name="RootParameterIndex">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The slot number for binding.</para>
		/// </param>
		/// <param name="BufferLocation">
		/// <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
		/// <para>The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootunorderedaccessview
		// void SetGraphicsRootUnorderedAccessView( [in] UINT RootParameterIndex, [in] D3D12_GPU_VIRTUAL_ADDRESS BufferLocation );
		[PreserveSig]
		new void SetGraphicsRootUnorderedAccessView(uint RootParameterIndex, D3D12_GPU_VIRTUAL_ADDRESS BufferLocation);

		/// <summary>Sets the view for the index buffer.</summary>
		/// <param name="pView">
		/// <para>Type: <b>const <c>D3D12_INDEX_BUFFER_VIEW</c>*</b></para>
		/// <para>
		/// The view specifies the index buffer's address, size, and <c>DXGI_FORMAT</c>, as a pointer to a <c>D3D12_INDEX_BUFFER_VIEW</c> structure.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Only one index buffer can be bound to the graphics pipeline at any one time. Examples The <c>D3D12Bundles</c> sample uses
		/// <b>ID3D12GraphicsCommandList::IASetIndexBuffer</b> as follows:
		/// </para>
		/// <para>
		/// <c>void FrameResource::PopulateCommandList(ID3D12GraphicsCommandList* pCommandList, ID3D12PipelineState* pPso1,
		/// ID3D12PipelineState* pPso2, UINT frameResourceIndex, UINT numIndices, D3D12_INDEX_BUFFER_VIEW* pIndexBufferViewDesc,
		/// D3D12_VERTEX_BUFFER_VIEW* pVertexBufferViewDesc, ID3D12DescriptorHeap* pCbvSrvDescriptorHeap, UINT cbvSrvDescriptorSize,
		/// ID3D12DescriptorHeap* pSamplerDescriptorHeap, ID3D12RootSignature* pRootSignature) { // If the root signature matches the root
		/// signature of the caller, then // bindings are inherited, otherwise the bind space is reset.
		/// pCommandList-&gt;SetGraphicsRootSignature(pRootSignature); ID3D12DescriptorHeap* ppHeaps[] = { pCbvSrvDescriptorHeap,
		/// pSamplerDescriptorHeap }; pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// pCommandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		/// pCommandList-&gt;IASetIndexBuffer(pIndexBufferViewDesc); pCommandList-&gt;IASetVertexBuffers(0, 1, pVertexBufferViewDesc);
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(0, pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());
		/// pCommandList-&gt;SetGraphicsRootDescriptorTable(1, pSamplerDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart()); //
		/// Calculate the descriptor offset due to multiple frame resources. // 1 SRV + how many CBVs we have currently. UINT
		/// frameResourceDescriptorOffset = 1 + (frameResourceIndex * m_cityRowCount * m_cityColumnCount); CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvSrvHandle(pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart(), frameResourceDescriptorOffset,
		/// cbvSrvDescriptorSize); BOOL usePso1 = TRUE; for (UINT i = 0; i &lt; m_cityRowCount; i++) { for (UINT j = 0; j &lt;
		/// m_cityColumnCount; j++) { // Alternate which PSO to use; the pixel shader is different on // each just as a PSO setting
		/// demonstration. pCommandList-&gt;SetPipelineState(usePso1 ? pPso1 : pPso2); usePso1 = !usePso1; // Set this city's CBV table and
		/// move to the next descriptor. pCommandList-&gt;SetGraphicsRootDescriptorTable(2, cbvSrvHandle);
		/// cbvSrvHandle.Offset(cbvSrvDescriptorSize); pCommandList-&gt;DrawIndexedInstanced(numIndices, 1, 0, 0, 0); } } }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-iasetindexbuffer void
		// IASetIndexBuffer( [in, optional] const D3D12_INDEX_BUFFER_VIEW *pView );
		[PreserveSig]
		new void IASetIndexBuffer([In, Optional] StructPointer<D3D12_INDEX_BUFFER_VIEW> pView);

		/// <summary>Sets a CPU descriptor handle for the vertex buffers.</summary>
		/// <param name="StartSlot">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Index into the device's zero-based array to begin setting vertex buffers.</para>
		/// </param>
		/// <param name="NumViews">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of views in the <i>pViews</i> array.</para>
		/// </param>
		/// <param name="pViews">
		/// <para>Type: <b>const <c>D3D12_VERTEX_BUFFER_VIEW</c>*</b></para>
		/// <para>Specifies the vertex buffer views in an array of <c>D3D12_VERTEX_BUFFER_VIEW</c> structures.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-iasetvertexbuffers void
		// IASetVertexBuffers( [in] UINT StartSlot, [in] UINT NumViews, [in, optional] const D3D12_VERTEX_BUFFER_VIEW *pViews );
		[PreserveSig]
		new void IASetVertexBuffers(uint StartSlot, int NumViews, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_VERTEX_BUFFER_VIEW[] pViews);

		/// <summary>Sets the stream output buffer views.</summary>
		/// <param name="StartSlot">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Index into the device's zero-based array to begin setting stream output buffers.</para>
		/// </param>
		/// <param name="NumViews">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of entries in the <i>pViews</i> array.</para>
		/// </param>
		/// <param name="pViews">
		/// <para>Type: <b>const <c>D3D12_STREAM_OUTPUT_BUFFER_VIEW</c>*</b></para>
		/// <para>Specifies an array of <c>D3D12_STREAM_OUTPUT_BUFFER_VIEW</c> structures.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-sosettargets void SOSetTargets( [in]
		// UINT StartSlot, [in] UINT NumViews, [in, optional] const D3D12_STREAM_OUTPUT_BUFFER_VIEW *pViews );
		[PreserveSig]
		new void SOSetTargets(uint StartSlot, int NumViews, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_STREAM_OUTPUT_BUFFER_VIEW[] pViews);

		/// <summary>Sets CPU descriptor handles for the render targets and depth stencil.</summary>
		/// <param name="NumRenderTargetDescriptors">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// The number of entries in the <i>pRenderTargetDescriptors</i> array (ranges between 0 and
		/// <b>D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT</b>). If this parameter is nonzero, the number of entries in the array to which
		/// pRenderTargetDescriptors points must equal the number in this parameter.
		/// </para>
		/// </param>
		/// <param name="pRenderTargetDescriptors">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>
		/// Specifies an array of <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> structures that describe the CPU descriptor handles that represents the
		/// start of the heap of render target descriptors. If this parameter is NULL and NumRenderTargetDescriptors is 0, no render targets
		/// are bound.
		/// </para>
		/// </param>
		/// <param name="RTsSingleHandleToDescriptorRange">
		/// <para>Type: <b>BOOL</b></para>
		/// <para>
		/// <b>True</b> means the handle passed in is the pointer to a contiguous range of <i>NumRenderTargetDescriptors</i> descriptors.
		/// This case is useful if the set of descriptors to bind already happens to be contiguous in memory (so all thats needed is a
		/// handle to the first one). For example, if <i>NumRenderTargetDescriptors</i> is 3 then the memory layout is taken as follows:
		/// </para>
		/// <para>In this case the driver dereferences the handle and then increments the memory being pointed to.</para>
		/// <para>
		/// <b>False</b> means that the handle is the first of an array of <i>NumRenderTargetDescriptors</i> handles. The false case allows
		/// an application to bind a set of descriptors from different locations at once. Again assuming that
		/// <i>NumRenderTargetDescriptors</i> is 3, the memory layout is taken as follows:
		/// </para>
		/// <para>In this case the driver dereferences three handles that are expected to be adjacent to each other in memory.</para>
		/// </param>
		/// <param name="pDepthStencilDescriptor">
		/// <para>Type: <b>const <c>D3D12_CPU_DESCRIPTOR_HANDLE</c>*</b></para>
		/// <para>
		/// A pointer to a <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> structure that describes the CPU descriptor handle that represents the start
		/// of the heap that holds the depth stencil descriptor. If this parameter is NULL, no depth stencil descriptor is bound.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets void
		// OMSetRenderTargets( [in] UINT NumRenderTargetDescriptors, [in, optional] const D3D12_CPU_DESCRIPTOR_HANDLE
		// *pRenderTargetDescriptors, [in] BOOL RTsSingleHandleToDescriptorRange, [in, optional] const D3D12_CPU_DESCRIPTOR_HANDLE
		// *pDepthStencilDescriptor );
		[PreserveSig]
		new void OMSetRenderTargets(uint NumRenderTargetDescriptors,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_CPU_DESCRIPTOR_HANDLE[]? pRenderTargetDescriptors,
			bool RTsSingleHandleToDescriptorRange, [In, Optional] StructPointer<D3D12_CPU_DESCRIPTOR_HANDLE> pDepthStencilDescriptor);

		/// <summary>Clears the depth-stencil resource.</summary>
		/// <param name="DepthStencilView">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>Describes the CPU descriptor handle that represents the start of the heap for the depth stencil to be cleared.</para>
		/// </param>
		/// <param name="ClearFlags">
		/// <para>Type: <b><c>D3D12_CLEAR_FLAGS</c></b></para>
		/// <para>
		/// A combination of <c>D3D12_CLEAR_FLAGS</c> values that are combined by using a bitwise OR operation. The resulting value
		/// identifies the type of data to clear (depth buffer, stencil buffer, or both).
		/// </para>
		/// </param>
		/// <param name="Depth">
		/// <para>Type: <b><c>FLOAT</c></b></para>
		/// <para>A value to clear the depth buffer with. This value will be clamped between 0 and 1.</para>
		/// </param>
		/// <param name="Stencil">
		/// <para>Type: <b>UINT8</b></para>
		/// <para>A value to clear the stencil buffer with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>The number of rectangles in the array that the <i>pRects</i> parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: <b>const <b>D3D12_RECT</b>*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearDepthStencilView</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>Only direct and bundle command lists support this operation.</para>
		/// <para>
		/// <b>ClearDepthStencilView</b> may be used to initialize resources which alias the same heap memory. See
		/// <c>CreatePlacedResource</c> for more details.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>For floating-point inputs, the runtime will set denormalized values to 0 (while preserving NANs).</para>
		/// <para>Validation failure will result in the call to <c>Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>The debug layer will issue errors if the input colors are denormalized.</para>
		/// <para>
		/// The debug layer will issue an error if the subresources referenced by the view are not in the appropriate state. For
		/// <b>ClearDepthStencilView</b>, the state must be in the state <c>D3D12_RESOURCE_STATE_DEPTH_WRITE</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-cleardepthstencilview void
		// ClearDepthStencilView( [in] D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView, [in] D3D12_CLEAR_FLAGS ClearFlags, [in] FLOAT Depth,
		// [in] UINT8 Stencil, [in] UINT NumRects, [in] const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearDepthStencilView([In] D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView, D3D12_CLEAR_FLAGS ClearFlags, float Depth, byte Stencil,
			[Optional] int NumRects, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] RECT[]? pRects);

		/// <summary>Sets all the elements in a render target to one value.</summary>
		/// <param name="RenderTargetView">
		/// <para>Type: <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// Specifies a D3D12_CPU_DESCRIPTOR_HANDLE structure that describes the CPU descriptor handle that represents the start of the heap
		/// for the render target to be cleared.
		/// </para>
		/// </param>
		/// <param name="ColorRGBA">
		/// <para>Type: <b>const FLOAT[4]</b></para>
		/// <para>A 4-component array that represents the color to fill the render target with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of rectangles in the array that the <i>pRects</i> parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: <b>const D3D12_RECT*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearRenderTargetView</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>ClearRenderTargetView</b> may be used to initialize resources which alias the same heap memory. See
		/// <c>CreatePlacedResource</c> for more details.
		/// </para>
		/// <para><c></c><c></c><c></c> Runtime validation</para>
		/// <para>For floating-point inputs, the runtime will set denormalized values to 0 (while preserving NANs).</para>
		/// <para>Validation failure will result in the call to <c>Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para><c></c><c></c><c></c> Debug layer</para>
		/// <para>The debug layer will issue errors if the input colors are denormalized.</para>
		/// <para>
		/// The debug layer will issue an error if the subresources referenced by the view are not in the appropriate state. For
		/// <b>ClearRenderTargetView</b>, the state must be <c>D3D12_RESOURCE_STATE_RENDER_TARGET</c>. Examples The
		/// <c>D3D12HelloTriangle</c> sample uses <b>ID3D12GraphicsCommandList::ClearRenderTargetView</b> as follows:
		/// </para>
		/// <para>
		/// <c>D3D12_VIEWPORT m_viewport; D3D12_RECT m_scissorRect; ComPtr&lt;IDXGISwapChain3&gt; m_swapChain; ComPtr&lt;ID3D12Device&gt;
		/// m_device; ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount]; ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
		/// ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue; ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
		/// ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap; ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
		/// ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList; UINT m_rtvDescriptorSize;</c>
		/// </para>
		/// <para>
		/// <c>void D3D12HelloTriangle::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocator-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular command // list,
		/// that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
		/// m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE, nullptr); // Record commands. const float clearColor[] = { 0.0f,
		/// 0.2f, 0.4f, 1.0f }; m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); m_commandList-&gt;DrawInstanced(3, 1, 0, 0); // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>The <c>D3D12Multithreading</c> sample uses <b>ID3D12GraphicsCommandList::ClearRenderTargetView</b> as follows:</para>
		/// <para><c>// Frame resources. FrameResource* m_frameResources[FrameCount]; FrameResource* m_pCurrentFrameResource; int m_currentFrameResourceIndex;</c></para>
		/// <para>
		/// <c>// Assemble the CommandListPre command list. void D3D12Multithreading::BeginFrame() { m_pCurrentFrameResource-&gt;Init(); //
		/// Indicate that the back buffer will be used as a render target.
		/// m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT,
		/// D3D12_RESOURCE_STATE_RENDER_TARGET)); // Clear the render target and depth stencil. const float clearColor[] = { 0.0f, 0.0f,
		/// 0.0f, 1.0f }; CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex,
		/// m_rtvDescriptorSize); m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ClearRenderTargetView(rtvHandle,
		/// clearColor, 0, nullptr);
		/// m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ClearDepthStencilView(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(),
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
		/// ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;Close()); } // Assemble the CommandListMid command
		/// list. void D3D12Multithreading::MidFrame() { // Transition our shadow map from the shadow pass to readable in the scene pass.
		/// m_pCurrentFrameResource-&gt;SwapBarriers();
		/// ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandLists[CommandListMid]-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearrendertargetview void
		// ClearRenderTargetView( [in] D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView, [in] const FLOAT [4] ColorRGBA, [in] UINT NumRects,
		// [in] const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearRenderTargetView([In] D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] float[] ColorRGBA,
			[Optional] int NumRects, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] RECT[]? pRects);

		/// <summary>
		/// <para>Sets all the elements in a unordered-access view (UAV) to the specified integer values.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This behaves like a compute operation in that it isn't ordered with respect to surrounding work such as <b>Dispatch</b> calls.
		/// To ensure ordering, barrier calls must be issued before and/or after the <b>ClearUnorderedAccessViewXxx</b> call as needed. It
		/// might appear on some drivers that such barriers aren't necessary. But implicit barriers are not a spec guarantee; so they can't
		/// be relied upon. This is in contrast to <b>ClearDepthStencilView</b> and <b>ClearRenderTargetView</b> which (like <b>DrawXxx</b>
		/// commands), respect command list ordering.
		/// </para>
		/// </para>
		/// </summary>
		/// <param name="ViewGPUHandleInCurrentHeap">
		/// <para>Type: [in] <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_GPU_DESCRIPTOR_HANDLE</c> that references an initialized descriptor for the unordered-access view (UAV) that is to be
		/// cleared. This descriptor must be in a shader-visible descriptor heap, which must be set on the command list via <c>SetDescriptorHeaps</c>.
		/// </para>
		/// </param>
		/// <param name="ViewCPUHandle">
		/// <para>Type: [in] <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> in a non-shader visible descriptor heap that references an initialized descriptor for the
		/// unordered-access view (UAV) that is to be cleared.
		/// </para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This descriptor must not be in a shader-visible descriptor heap. This is to allow drivers that implement the clear as a
		/// fixed-function hardware operation (rather than as a dispatch) to efficiently read from the descriptor, as shader-visible heaps
		/// may be created in <b>WRITE_BACK</b> memory (similar to <b>D3D12_HEAP_TYPE_UPLOAD</b> heap types), and CPU reads from this type
		/// of memory are prohibitively slow.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="pResource">
		/// <para>Type: [in] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the unordered-access-view (UAV) resource to clear.</para>
		/// </param>
		/// <param name="Values">
		/// <para>Type: [in] <b>const UINT[4]</b></para>
		/// <para>A 4-component array that containing the values to fill the unordered-access-view resource with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The number of rectangles in the array that the pRects parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: [in] <b>const <c>D3D12_RECT</c>*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearUnorderedAccessViewUint</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>Runtime validation</para>
		/// <para>Validation failure results in the call to <c>ID3D12GraphicsCommandList::Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para>Debug layer</para>
		/// <para>The debug layer issues errors if the input values are outside of a normalized range.</para>
		/// <para>
		/// The debug layer issues an error if the subresources referenced by the view aren't in the appropriate state. For
		/// <b>ClearUnorderedAccessViewUint</b>, the state must be <c>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewuint void
		// ClearUnorderedAccessViewUint( D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
		// ID3D12Resource *pResource, const UINT [4] Values, UINT NumRects, const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearUnorderedAccessViewUint([In] D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, [In] D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
			[In] ID3D12Resource pResource, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] uint[] Values, int NumRects,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] RECT[] pRects);

		/// <summary>
		/// <para>Sets all of the elements in an unordered-access view (UAV) to the specified float values.</para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This behaves like a compute operation in that it isn't ordered with respect to surrounding work such as <b>Dispatch</b> calls.
		/// To ensure ordering, barrier calls must be issued before and/or after the <b>ClearUnorderedAccessViewXxx</b> call as needed. It
		/// might appear on some drivers that such barriers aren't necessary. But implicit barriers are not a spec guarantee; so they can't
		/// be relied upon. This is in contrast to <b>ClearDepthStencilView</b> and <b>ClearRenderTargetView</b> which (like <b>DrawXxx</b>
		/// commands), respect command list ordering.
		/// </para>
		/// </para>
		/// </summary>
		/// <param name="ViewGPUHandleInCurrentHeap">
		/// <para>Type: [in] <b><c>D3D12_GPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_GPU_DESCRIPTOR_HANDLE</c> that references an initialized descriptor for the unordered-access view (UAV) that is to be
		/// cleared. This descriptor must be in a shader-visible descriptor heap, which must be set on the command list via <c>SetDescriptorHeaps</c>.
		/// </para>
		/// </param>
		/// <param name="ViewCPUHandle">
		/// <para>Type: [in] <b><c>D3D12_CPU_DESCRIPTOR_HANDLE</c></b></para>
		/// <para>
		/// A <c>D3D12_CPU_DESCRIPTOR_HANDLE</c> in a non-shader visible descriptor heap that references an initialized descriptor for the
		/// unordered-access view (UAV) that is to be cleared.
		/// </para>
		/// <para>
		/// <para>Important</para>
		/// <para>
		/// This descriptor must not be in a shader-visible descriptor heap. This is to allow drivers that implement the clear as a
		/// fixed-function hardware operation (rather than as a dispatch) to efficiently read from the descriptor, as shader-visible heaps
		/// may be created in <b>WRITE_BACK</b> memory (similar to <b>D3D12_HEAP_TYPE_UPLOAD</b> heap types), and CPU reads from this type
		/// of memory are prohibitively slow.
		/// </para>
		/// </para>
		/// </param>
		/// <param name="pResource">
		/// <para>Type: [in] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface that represents the unordered-access-view (UAV) resource to clear.</para>
		/// </param>
		/// <param name="Values">
		/// <para>Type: [in] <b>const FLOAT[4]</b></para>
		/// <para>A 4-component array that containing the values to fill the unordered-access-view resource with.</para>
		/// </param>
		/// <param name="NumRects">
		/// <para>Type: [in] <b>UINT</b></para>
		/// <para>The number of rectangles in the array that the pRects parameter specifies.</para>
		/// </param>
		/// <param name="pRects">
		/// <para>Type: [in] <b>const <c>D3D12_RECT</c>*</b></para>
		/// <para>
		/// An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>,
		/// <b>ClearUnorderedAccessViewFloat</b> clears the entire resource view.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>Runtime validation</para>
		/// <para>For floating-point inputs, the runtime sets denormalized values to 0 (while preserving NANs).</para>
		/// <para>If you want to clear the UAV to a specific bit pattern, consider using <c>ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint</c>.</para>
		/// <para>Validation failure results in the call to <c>ID3D12GraphicsCommandList::Close</c> returning <b>E_INVALIDARG</b>.</para>
		/// <para>Debug layer</para>
		/// <para>The debug layer issues errors if the input values are outside of a normalized range.</para>
		/// <para>
		/// The debug layer issues an error if the subresources referenced by the view aren't in the appropriate state. For
		/// <b>ClearUnorderedAccessViewFloat</b>, the state must be <c>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</c>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewfloat void
		// ClearUnorderedAccessViewFloat( D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
		// ID3D12Resource *pResource, const FLOAT [4] Values, UINT NumRects, const D3D12_RECT *pRects );
		[PreserveSig]
		new void ClearUnorderedAccessViewFloat([In] D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap, [In] D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
			[In] ID3D12Resource pResource, [In, MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] float[] Values, int NumRects,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] RECT[] pRects);

		/// <summary>
		/// Indicates that the contents of a resource don't need to be preserved. The function may re-initialize resource metadata in some cases.
		/// </summary>
		/// <param name="pResource">
		/// <para>Type: [in] <b><c>ID3D12Resource</c>*</b></para>
		/// <para>A pointer to the <c>ID3D12Resource</c> interface for the resource to discard.</para>
		/// </param>
		/// <param name="pRegion">
		/// <para>Type: [in, optional] <b>const <c>D3D12_DISCARD_REGION</c>*</b></para>
		/// <para>A pointer to a <c>D3D12_DISCARD_REGION</c> structure that describes details for the discard-resource operation.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>The semantics of <b>DiscardResource</b> change based on the command list type.</para>
		/// <para>For <c>D3D12_COMMAND_LIST_TYPE_DIRECT</c>, the following two rules apply:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// When a resource has the <c>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</c> flag, <b>DiscardResource</b> must be called when the
		/// discarded subresource regions are in the <c>D3D12_RESOURCE_STATE_RENDER_TARGET</c> resource barrier state.
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// When a resource has the <c>D3D12_RESOURCE_FLAG _ALLOW_DEPTH_STENCIL</c> flag, <b>DiscardResource</b> must be called when the
		/// discarded subresource regions are in the <c>D3D12_RESOURCE_STATE_DEPTH_WRITE</c>.
		/// </description>
		/// </item>
		/// </list>
		/// <para>For <c>D3D12_COMMAND_LIST_TYPE_COMPUTE</c>, the following rule applies:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// The resource must have the <c>D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS</c> flag, and <b>DiscardResource</b> must be called
		/// when the discarded subresource regions are in the <c>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</c> resource barrier state.
		/// </description>
		/// </item>
		/// </list>
		/// <para><b>DiscardResource</b> is not supported on command lists with either <c>D3D12_COMMAND_LIST_TYPE_BUNDLE</c> nor <b>D3D12_COMMAND_LIST_TYPE_COPY</b>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-discardresource void
		// DiscardResource( ID3D12Resource *pResource, const D3D12_DISCARD_REGION *pRegion );
		[PreserveSig]
		new void DiscardResource([In] ID3D12Resource pResource, [In, Optional] StructPointer<D3D12_DISCARD_REGION> pRegion);

		/// <summary>Starts a query running.</summary>
		/// <param name="pQueryHeap">
		/// <para>Type: <b><c>ID3D12QueryHeap</c>*</b></para>
		/// <para>Specifies the <c>ID3D12QueryHeap</c> containing the query.</para>
		/// </param>
		/// <param name="Type">
		/// <para>Type: <b><c>D3D12_QUERY_TYPE</c></b></para>
		/// <para>Specifies one member of <c>D3D12_QUERY_TYPE</c>.</para>
		/// </param>
		/// <param name="Index">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the index of the query within the query heap.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// See <c>Queries</c> for more information about D3D12 queries. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12GraphicsCommandList::BeginQuery</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void
		/// D3D12PredicationQueries::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); // Draw the quads and perform the occlusion query. { CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); // Draw the far quad conditionally based on the result of the occlusion query // from the previous
		/// frame. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad); m_commandList-&gt;SetPredication(m_queryResult.Get(), 0,
		/// D3D12_PREDICATION_OP_EQUAL_ZERO); m_commandList-&gt;DrawInstanced(4, 1, 0, 0); // Disable predication and always draw the near
		/// quad. m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
		/// m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad); m_commandList-&gt;DrawInstanced(4, 1, 4, 0); // Run the
		/// occlusion query with the bounding box quad. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
		/// m_commandList-&gt;SetPipelineState(m_queryState.Get()); m_commandList-&gt;BeginQuery(m_queryHeap.Get(),
		/// D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
		/// m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); // Resolve the occlusion query and store
		/// the results in the query result buffer // to be used on the subsequent frame. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION,
		/// D3D12_RESOURCE_STATE_COPY_DEST)); m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1,
		/// m_queryResult.Get(), 0); m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(),
		/// D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION)); } // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-beginquery void BeginQuery( [in]
		// ID3D12QueryHeap *pQueryHeap, [in] D3D12_QUERY_TYPE Type, [in] UINT Index );
		[PreserveSig]
		new void BeginQuery([In] ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);

		/// <summary>Ends a running query.</summary>
		/// <param name="pQueryHeap">
		/// <para>Type: <b><c>ID3D12QueryHeap</c>*</b></para>
		/// <para>Specifies the <c>ID3D12QueryHeap</c> containing the query.</para>
		/// </param>
		/// <param name="Type">
		/// <para>Type: <b><c>D3D12_QUERY_TYPE</c></b></para>
		/// <para>Specifies one member of <c>D3D12_QUERY_TYPE</c>.</para>
		/// </param>
		/// <param name="Index">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the index of the query in the query heap.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// See <c>Queries</c> for more information about D3D12 queries. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12GraphicsCommandList::EndQuery</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void
		/// D3D12PredicationQueries::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); // Draw the quads and perform the occlusion query. { CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); // Draw the far quad conditionally based on the result of the occlusion query // from the previous
		/// frame. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad); m_commandList-&gt;SetPredication(m_queryResult.Get(), 0,
		/// D3D12_PREDICATION_OP_EQUAL_ZERO); m_commandList-&gt;DrawInstanced(4, 1, 0, 0); // Disable predication and always draw the near
		/// quad. m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
		/// m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad); m_commandList-&gt;DrawInstanced(4, 1, 4, 0); // Run the
		/// occlusion query with the bounding box quad. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
		/// m_commandList-&gt;SetPipelineState(m_queryState.Get()); m_commandList-&gt;BeginQuery(m_queryHeap.Get(),
		/// D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
		/// m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); // Resolve the occlusion query and store
		/// the results in the query result buffer // to be used on the subsequent frame. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION,
		/// D3D12_RESOURCE_STATE_COPY_DEST)); m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1,
		/// m_queryResult.Get(), 0); m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(),
		/// D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION)); } // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-endquery void EndQuery( [in]
		// ID3D12QueryHeap *pQueryHeap, [in] D3D12_QUERY_TYPE Type, [in] UINT Index );
		[PreserveSig]
		new void EndQuery([In] ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);

		/// <summary>Extracts data from a query. <b>ResolveQueryData</b> works with all heap types (default, upload, and readback).</summary>
		/// <param name="pQueryHeap">
		/// <para>Type: <b><c>ID3D12QueryHeap</c>*</b></para>
		/// <para>Specifies the <c>ID3D12QueryHeap</c> containing the queries to resolve.</para>
		/// </param>
		/// <param name="Type">
		/// <para>Type: <b><c>D3D12_QUERY_TYPE</c></b></para>
		/// <para>Specifies the type of query, one member of <c>D3D12_QUERY_TYPE</c>.</para>
		/// </param>
		/// <param name="StartIndex">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies an index of the first query to resolve.</para>
		/// </param>
		/// <param name="NumQueries">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Specifies the number of queries to resolve.</para>
		/// </param>
		/// <param name="pDestinationBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies an <c>ID3D12Resource</c> destination buffer, which must be in the state <c>D3D12_RESOURCE_STATE_COPY_DEST</c>.</para>
		/// </param>
		/// <param name="AlignedDestinationBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies an alignment offset into the destination buffer. Must be a multiple of 8 bytes.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>ResolveQueryData</b> performs a batched operation that writes query data into a destination buffer. Query data is written
		/// contiguously to the destination buffer, and the parameter.
		/// </para>
		/// <para>
		/// <b>ResolveQueryData</b> turns application-opaque query data in an application-opaque query heap into adapter-agnostic values
		/// usable by your application. Resolving queries within a heap that have not been completed (so have had
		/// <c><b>ID3D12GraphicsCommandList::BeginQuery</b></c> called for them, but not <c><b>ID3D12GraphicsCommandList::EndQuery</b></c>),
		/// or that have been uninitialized, results in undefined behavior and might cause device hangs or removal. The debug layer will
		/// emit an error if it detects an application has resolved incomplete or uninitialized queries.
		/// </para>
		/// <para>
		/// <para>Note</para>
		/// <para>
		/// Resolving incomplete or uninitialized queries is undefined behavior because the driver might internally store GPUVAs or other
		/// data within unresolved queries. And so attempting to resolve these queries on uninitialized data could cause a page fault or
		/// device hang. Older versions of the debug layer didn't validate this behavior.
		/// </para>
		/// </para>
		/// <para>
		/// Binary occlusion queries write 64-bits per query. The least significant bit is either 0 (the object was entirely occluded) or 1
		/// (at least 1 sample of the object would have been drawn). The rest of the bits are 0. Occlusion queries write 64-bits per query.
		/// The value is the number of samples that passed testing. Timestamp queries write 64-bits per query, which is a tick value that
		/// must be compared to the respective command queue frequency (see <c>Timing</c>).
		/// </para>
		/// <para>
		/// Pipeline statistics queries write a <c><b>D3D12_QUERY_DATA_PIPELINE_STATISTICS</b></c> structure per query. All stream-out
		/// statistics queries write a <c><b>D3D12_QUERY_DATA_SO_STATISTICS</b></c> structure per query.
		/// </para>
		/// <para>The core runtime will validate the following.</para>
		/// <list type="bullet">
		/// <item>
		/// <description><i>StartIndex</i> and <i>NumQueries</i> are within range.</description>
		/// </item>
		/// <item>
		/// <description><i>AlignedDestinationBufferOffset</i> is a multiple of 8 bytes.</description>
		/// </item>
		/// <item>
		/// <description><i>DestinationBuffer</i> is a buffer.</description>
		/// </item>
		/// <item>
		/// <description>The written data will not overflow the output buffer.</description>
		/// </item>
		/// <item>
		/// <description>The query type must be supported by the command list type.</description>
		/// </item>
		/// <item>
		/// <description>The query type must be supported by the query heap.</description>
		/// </item>
		/// </list>
		/// <para>
		/// The debug layer will issue a warning if the destination buffer is not in the D3D12_RESOURCE_STATE_COPY_DEST state, or if any
		/// queries being resolved have not had <c><b>ID3D12GraphicsCommandList::EndQuery</b></c> called on them.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvequerydata void
		// ResolveQueryData( [in] ID3D12QueryHeap *pQueryHeap, [in] D3D12_QUERY_TYPE Type, [in] UINT StartIndex, [in] UINT NumQueries, [in]
		// ID3D12Resource *pDestinationBuffer, [in] UINT64 AlignedDestinationBufferOffset );
		[PreserveSig]
		new void ResolveQueryData([In] ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint StartIndex, uint NumQueries,
			[In] ID3D12Resource pDestinationBuffer, ulong AlignedDestinationBufferOffset);

		/// <summary>Sets a rendering predicate.</summary>
		/// <param name="pBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>
		/// The buffer, as an <c>ID3D12Resource</c>, which must be in the <c><b>D3D12_RESOURCE_STATE_PREDICATION</b></c> or
		/// <c><b>D3D21_RESOURCE_STATE_INDIRECT_ARGUMENT</b></c> state (both values are identical, and provided as aliases for clarity), or
		/// <b>NULL</b> to disable predication.
		/// </para>
		/// </param>
		/// <param name="AlignedBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>The aligned buffer offset, as a UINT64.</para>
		/// </param>
		/// <param name="Operation">
		/// <para>Type: <b><c>D3D12_PREDICATION_OP</c></b></para>
		/// <para>Specifies a <c>D3D12_PREDICATION_OP</c>, such as D3D12_PREDICATION_OP_EQUAL_ZERO or D3D12_PREDICATION_OP_NOT_EQUAL_ZERO.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Use this method to denote that subsequent rendering and resource manipulation commands are not actually performed if the
		/// resulting predicate data of the predicate is equal to the operation specified.
		/// </para>
		/// <para>
		/// Unlike Direct3D 11, in Direct3D 12 predication state is not inherited by direct command lists, and predication is always
		/// respected (there are no predication hints). All direct command lists begin with predication disabled. Bundles do inherit
		/// predication state. It is legal for the same predicate to be bound multiple times.
		/// </para>
		/// <para>
		/// Illegal API calls will result in <c>Close</c> returning an error, or <c>ID3D12CommandQueue::ExecuteCommandLists</c> dropping the
		/// command list and removing the device.
		/// </para>
		/// <para>The debug layer will issue errors whenever the runtime validation fails.</para>
		/// <para>
		/// Refer to <c>Predication</c> for more information. Examples The <c>D3D12PredicationQueries</c> sample uses
		/// <b>ID3D12GraphicsCommandList::SetPredication</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void
		/// D3D12PredicationQueries::PopulateCommandList() { // Command list allocators can only be reset when the associated // command
		/// lists have finished execution on the GPU; apps should use // fences to determine GPU execution progress.
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, &amp;m_scissorRect); // Indicate that the back buffer will be used as a render target.
		/// m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET)); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); // Draw the quads and perform the occlusion query. { CD3DX12_GPU_DESCRIPTOR_HANDLE
		/// cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
		/// CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);
		/// m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); m_commandList-&gt;IASetVertexBuffers(0, 1,
		/// &amp;m_vertexBufferView); // Draw the far quad conditionally based on the result of the occlusion query // from the previous
		/// frame. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad); m_commandList-&gt;SetPredication(m_queryResult.Get(), 0,
		/// D3D12_PREDICATION_OP_EQUAL_ZERO); m_commandList-&gt;DrawInstanced(4, 1, 0, 0); // Disable predication and always draw the near
		/// quad. m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
		/// m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad); m_commandList-&gt;DrawInstanced(4, 1, 4, 0); // Run the
		/// occlusion query with the bounding box quad. m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
		/// m_commandList-&gt;SetPipelineState(m_queryState.Get()); m_commandList-&gt;BeginQuery(m_queryHeap.Get(),
		/// D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
		/// m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0); // Resolve the occlusion query and store
		/// the results in the query result buffer // to be used on the subsequent frame. m_commandList-&gt;ResourceBarrier(1,
		/// &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION,
		/// D3D12_RESOURCE_STATE_COPY_DEST)); m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1,
		/// m_queryResult.Get(), 0); m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_queryResult.Get(),
		/// D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION)); } // Indicate that the back buffer will now be used to
		/// present. m_commandList-&gt;ResourceBarrier(1, &amp;CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(),
		/// D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT)); ThrowIfFailed(m_commandList-&gt;Close()); }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setpredication void SetPredication(
		// [in, optional] ID3D12Resource *pBuffer, [in] UINT64 AlignedBufferOffset, [in] D3D12_PREDICATION_OP Operation );
		[PreserveSig]
		new void SetPredication([In, Optional] ID3D12Resource? pBuffer, ulong AlignedBufferOffset, D3D12_PREDICATION_OP Operation);

		/// <summary>Not intended to be called directly. Use the <c>PIX event runtime</c> to insert events into a command list.</summary>
		/// <param name="Metadata">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const void*</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="Size">
		/// <para>Type: <b>UINT</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This is a support method used internally by the PIX event runtime. It is not intended to be called directly.</para>
		/// <para>
		/// To insert instrumentation markers at the current location within a D3D12 command list, use the <b>PIXSetMarker</b> function.
		/// This is provided by the <c>WinPixEventRuntime</c> NuGet package.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setmarker void SetMarker( UINT
		// Metadata, [in, optional] const void *pData, UINT Size );
		[PreserveSig]
		new void SetMarker(uint Metadata, [In, Optional] IntPtr pData, uint Size);

		/// <summary>Not intended to be called directly. Use the <c>PIX event runtime</c> to insert events into a command list.</summary>
		/// <param name="Metadata">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="pData">
		/// <para>Type: <b>const <c>void</c>*</b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <param name="Size">
		/// <para>Type: <b><c>UINT</c></b></para>
		/// <para>Internal.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This is a support method used internally by the PIX event runtime. It is not intended to be called directly.</para>
		/// <para>
		/// To mark the start of an instrumentation region at the current location within a D3D12 command list, use the <b>PIXBeginEvent</b>
		/// function or <b>PIXScopedEvent</b> macro. These are provided by the <c>WinPixEventRuntime</c> NuGet package.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-beginevent void BeginEvent( UINT
		// Metadata, [in, optional] const void *pData, UINT Size );
		[PreserveSig]
		new void BeginEvent(uint Metadata, [In, Optional] IntPtr pData, uint Size);

		/// <summary>Not intended to be called directly. Use the <c>PIX event runtime</c> to insert events into a command list.</summary>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This is a support method used internally by the PIX event runtime. It is not intended to be called directly.</para>
		/// <para>
		/// To mark the end of an instrumentation region at the current location within a D3D12 command list, use the <b>PIXEndEvent</b>
		/// function or <b>PIXScopedEvent</b> macro. These are provided by the <c>WinPixEventRuntime</c> NuGet package.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-endevent void EndEvent();
		[PreserveSig]
		new void EndEvent();

		/// <summary>Apps perform indirect draws/dispatches using the <b>ExecuteIndirect</b> method.</summary>
		/// <param name="pCommandSignature">
		/// <para>Type: <b><c>ID3D12CommandSignature</c>*</b></para>
		/// <para>
		/// Specifies a <c>ID3D12CommandSignature</c>. The data referenced by <i>pArgumentBuffer</i> will be interpreted depending on the
		/// contents of the command signature. Refer to <c>Indirect Drawing</c> for the APIs that are used to create a command signature.
		/// </para>
		/// </param>
		/// <param name="MaxCommandCount">
		/// <para>Type: <b>UINT</b></para>
		/// <para>There are two ways that command counts can be specified:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>
		/// If <i>pCountBuffer</i> is not NULL, then <i>MaxCommandCount</i> specifies the maximum number of operations which will be
		/// performed. The actual number of operations to be performed are defined by the minimum of this value, and a 32-bit unsigned
		/// integer contained in <i>pCountBuffer</i> (at the byte offset specified by <i>CountBufferOffset</i>).
		/// </description>
		/// </item>
		/// <item>
		/// <description>
		/// If <i>pCountBuffer</i> is NULL, the <i>MaxCommandCount</i> specifies the exact number of operations which will be performed.
		/// </description>
		/// </item>
		/// </list>
		/// </param>
		/// <param name="pArgumentBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies one or more <c>ID3D12Resource</c> objects, containing the command arguments.</para>
		/// </param>
		/// <param name="ArgumentBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies an offset into <i>pArgumentBuffer</i> to identify the first command argument.</para>
		/// </param>
		/// <param name="pCountBuffer">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>Specifies a pointer to a <c>ID3D12Resource</c>.</para>
		/// </param>
		/// <param name="CountBufferOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>Specifies a UINT64 that is the offset into <i>pCountBuffer</i>, identifying the argument count.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>The semantics of this API are defined with the following pseudo-code:</para>
		/// <para>Non-NULL pCountBuffer:</para>
		/// <para>
		/// <c>// Read draw count out of count buffer UINT CommandCount = pCountBuffer-&gt;ReadUINT32(CountBufferOffset); CommandCount =
		/// min(CommandCount, MaxCommandCount) // Get pointer to first Commanding argument BYTE* Arguments = pArgumentBuffer-&gt;GetBase() +
		/// ArgumentBufferOffset; for(UINT CommandIndex = 0; CommandIndex &lt; CommandCount; CommandIndex++) { // Interpret the data
		/// contained in *Arguments // according to the command signature pCommandSignature-&gt;Interpret(Arguments); Arguments +=
		/// pCommandSignature-&gt;GetByteStride(); }</c>
		/// </para>
		/// <para>NULL pCountBuffer:</para>
		/// <para>
		/// <c>// Get pointer to first Commanding argument BYTE* Arguments = pArgumentBuffer-&gt;GetBase() + ArgumentBufferOffset; for(UINT
		/// CommandIndex = 0; CommandIndex &lt; MaxCommandCount; CommandIndex++) { // Interpret the data contained in *Arguments //
		/// according to the command signature pCommandSignature-&gt;Interpret(Arguments); Arguments +=
		/// pCommandSignature-&gt;GetByteStride(); }</c>
		/// </para>
		/// <para>
		/// The debug layer will issue an error if either the count buffer or the argument buffer are not in the
		/// D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT state. The core runtime will validate:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description><i>CountBufferOffset</i> and <i>ArgumentBufferOffset</i> are 4-byte aligned</description>
		/// </item>
		/// <item>
		/// <description><i>pCountBuffer</i> and <i>pArgumentBuffer</i> are buffer resources (any heap type)</description>
		/// </item>
		/// <item>
		/// <description>
		/// The offset implied by <i>MaxCommandCount</i>, <i>ArgumentBufferOffset</i>, and the drawing program stride do not exceed the
		/// bounds of <i>pArgumentBuffer</i> (similarly for count buffer)
		/// </description>
		/// </item>
		/// <item>
		/// <description>The command list is a direct command list or a compute command list (not a copy or JPEG decode command list)</description>
		/// </item>
		/// <item>
		/// <description>The root signature of the command list matches the root signature of the command signature</description>
		/// </item>
		/// </list>
		/// <para>
		/// The functionality of two APIs from earlier versions of Direct3D, <c>DrawInstancedIndirect</c> and
		/// <c>DrawIndexedInstancedIndirect</c>, are encompassed by <b>ExecuteIndirect</b>.
		/// </para>
		/// <para><c></c><c></c><c></c> Bundles</para>
		/// <para>
		/// <b>ID3D12GraphicsCommandList::ExecuteIndirect</b> is allowed inside of bundle command lists only if all of the following are true:
		/// </para>
		/// <list type="bullet">
		/// <item>
		/// <description>CountBuffer is NULL (CPU-specified count only).</description>
		/// </item>
		/// <item>
		/// <description>
		/// The command signature contains exactly one operation. This implies that the command signature does not contain root arguments
		/// changes, nor contain VB/IB binding changes.
		/// </description>
		/// </item>
		/// </list>
		/// <para><c></c><c></c><c></c> Obtaining buffer virtual addresses</para>
		/// <para>The <c>ID3D12Resource::GetGPUVirtualAddress</c> method enables an app to retrieve the GPU virtual address of a buffer.</para>
		/// <para>
		/// Apps are free to apply byte offsets to virtual addresses before placing them in an indirect argument buffer. Note that all of
		/// the D3D12 alignment requirements for VB/IB/CB still apply to the resulting GPU virtual address. Examples The
		/// <c>D3D12ExecuteIndirect</c> sample uses <b>ID3D12GraphicsCommandList::ExecuteIndirect</b> as follows:
		/// </para>
		/// <para>
		/// <c>// Data structure to match the command signature used for ExecuteIndirect. struct IndirectCommand { D3D12_GPU_VIRTUAL_ADDRESS
		/// cbv; D3D12_DRAW_ARGUMENTS drawArguments; };</c>
		/// </para>
		/// <para>
		/// The call to <b>ExecuteIndirect</b> is near the end of this listing, below the comment "Draw the triangles that have not been culled."
		/// </para>
		/// <para>
		/// <c>// Fill the command list with all the render commands and dependent state. void D3D12ExecuteIndirect::PopulateCommandLists()
		/// { // Command list allocators can only be reset when the associated // command lists have finished execution on the GPU; apps
		/// should use // fences to determine GPU execution progress. ThrowIfFailed(m_computeCommandAllocators[m_frameIndex]-&gt;Reset());
		/// ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset()); // However, when ExecuteCommandList() is called on a particular
		/// command // list, that command list can then be reset at any time and must be before // re-recording.
		/// ThrowIfFailed(m_computeCommandList-&gt;Reset(m_computeCommandAllocators[m_frameIndex].Get(), m_computeState.Get()));
		/// ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get())); // Record the compute
		/// commands that will cull triangles and prevent them from being processed by the vertex shader. if (m_enableCulling) { UINT
		/// frameDescriptorOffset = m_frameIndex * CbvSrvUavDescriptorCountPerFrame; D3D12_GPU_DESCRIPTOR_HANDLE cbvSrvUavHandle =
		/// m_cbvSrvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart();
		/// m_computeCommandList-&gt;SetComputeRootSignature(m_computeRootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = {
		/// m_cbvSrvUavHeap.Get() }; m_computeCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		/// m_computeCommandList-&gt;SetComputeRootDescriptorTable( SrvUavTable, CD3DX12_GPU_DESCRIPTOR_HANDLE(cbvSrvUavHandle, CbvSrvOffset
		/// + frameDescriptorOffset, m_cbvSrvUavDescriptorSize)); m_computeCommandList-&gt;SetComputeRoot32BitConstants(RootConstants, 4,
		/// reinterpret_cast&lt;void*&gt;(&amp;m_csRootConstants), 0); // Reset the UAV counter for this frame.
		/// m_computeCommandList-&gt;CopyBufferRegion(m_processedCommandBuffers[m_frameIndex].Get(), CommandBufferSizePerFrame,
		/// m_processedCommandBufferCounterReset.Get(), 0, sizeof(UINT)); D3D12_RESOURCE_BARRIER barrier =
		/// CD3DX12_RESOURCE_BARRIER::Transition(m_processedCommandBuffers[m_frameIndex].Get(), D3D12_RESOURCE_STATE_COPY_DEST,
		/// D3D12_RESOURCE_STATE_UNORDERED_ACCESS); m_computeCommandList-&gt;ResourceBarrier(1, &amp;barrier);
		/// m_computeCommandList-&gt;Dispatch(static_cast&lt;UINT&gt;(ceil(TriangleCount / float(ComputeThreadBlockSize))), 1, 1); }
		/// ThrowIfFailed(m_computeCommandList-&gt;Close()); // Record the rendering commands. { // Set necessary state.
		/// m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get()); ID3D12DescriptorHeap* ppHeaps[] = { m_cbvSrvUavHeap.Get() };
		/// m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps); m_commandList-&gt;RSSetViewports(1, &amp;m_viewport);
		/// m_commandList-&gt;RSSetScissorRects(1, m_enableCulling ? &amp;m_cullingScissorRect : &amp;m_scissorRect); // Indicate that the
		/// command buffer will be used for indirect drawing // and that the back buffer will be used as a render target.
		/// D3D12_RESOURCE_BARRIER barriers[2] = { CD3DX12_RESOURCE_BARRIER::Transition( m_enableCulling ?
		/// m_processedCommandBuffers[m_frameIndex].Get() : m_commandBuffer.Get(), m_enableCulling ? D3D12_RESOURCE_STATE_UNORDERED_ACCESS :
		/// D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT), CD3DX12_RESOURCE_BARRIER::Transition(
		/// m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET) };
		/// m_commandList-&gt;ResourceBarrier(_countof(barriers), barriers); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize); CD3DX12_CPU_DESCRIPTOR_HANDLE
		/// dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart()); m_commandList-&gt;OMSetRenderTargets(1, &amp;rtvHandle, FALSE,
		/// &amp;dsvHandle); // Record commands. const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
		/// m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr); m_commandList-&gt;ClearDepthStencilView(dsvHandle,
		/// D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr); m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
		/// m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;m_vertexBufferView); if (m_enableCulling) { // Draw the triangles that have not
		/// been culled. m_commandList-&gt;ExecuteIndirect( m_commandSignature.Get(), TriangleCount,
		/// m_processedCommandBuffers[m_frameIndex].Get(), 0, m_processedCommandBuffers[m_frameIndex].Get(), CommandBufferSizePerFrame); }
		/// else { // Draw all of the triangles. m_commandList-&gt;ExecuteIndirect( m_commandSignature.Get(), TriangleCount,
		/// m_commandBuffer.Get(), CommandBufferSizePerFrame * m_frameIndex, nullptr, 0); } // Indicate that the command buffer may be used
		/// by the compute shader // and that the back buffer will now be used to present. barriers[0].Transition.StateBefore =
		/// D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT; barriers[0].Transition.StateAfter = m_enableCulling ? D3D12_RESOURCE_STATE_COPY_DEST :
		/// D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE; barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
		/// barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT; m_commandList-&gt;ResourceBarrier(_countof(barriers),
		/// barriers); ThrowIfFailed(m_commandList-&gt;Close()); } }</c>
		/// </para>
		/// <para>See <c>Example Code in the D3D12 Reference</c>.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-executeindirect void
		// ExecuteIndirect( [in] ID3D12CommandSignature *pCommandSignature, [in] UINT MaxCommandCount, [in] ID3D12Resource *pArgumentBuffer,
		// [in] UINT64 ArgumentBufferOffset, [in, optional] ID3D12Resource *pCountBuffer, [in] UINT64 CountBufferOffset );
		[PreserveSig]
		new void ExecuteIndirect([In] ID3D12CommandSignature pCommandSignature, uint MaxCommandCount, [In] ID3D12Resource pArgumentBuffer,
			ulong ArgumentBufferOffset, [In, Optional] ID3D12Resource? pCountBuffer, ulong CountBufferOffset);

		/// <summary>
		/// <para>Atomically copies a primary data element of type UINT from one resource to another, along with optional dependent resources.</para>
		/// <para>
		/// These 'dependent resources' are so-named because they depend upon the primary data element to locate them, typically the key
		/// element is an address, index, or other handle that refers to one or more the dependent resources indirectly.
		/// </para>
		/// <para>
		/// This function supports a primary data element of type UINT (32bit). A different version of this function,
		/// <c>AtomicCopyBufferUINT64</c>, supports a primary data element of type UINT64 (64bit).
		/// </para>
		/// </summary>
		/// <param name="pDstBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>The resource that the UINT primary data element is copied into.</para>
		/// </param>
		/// <param name="DstOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the destination resource buffer that specifies where the primary data element is copied into, in bytes. This
		/// offset combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT values.
		/// </para>
		/// </param>
		/// <param name="pSrcBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The resource that the UINT primary data element is copied from. This data is typically an address, index, or other handle that
		/// shader code can use to locate the most-recent version of latency-sensitive information.
		/// </para>
		/// </param>
		/// <param name="SrcOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the source resource buffer that specifies where the primary data element is copied from, in bytes. This offset
		/// combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT values.
		/// </para>
		/// </param>
		/// <param name="Dependencies">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of dependent resources.</para>
		/// </param>
		/// <param name="ppDependentResources">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>An array of resources that contain the dependent elements of the data payload.</para>
		/// </param>
		/// <param name="pDependentSubresourceRanges">
		/// <para>Type: <b>const <c>D3D12_SUBRESOURCE_RANGE_UINT64</c>*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>
		/// An array of subresource ranges that specify the dependent elements of the data payload. These elements are completely updated
		/// before the primary data element is itself atomically copied. This ensures that the entire operation is logically atomic; that
		/// is, the primary data element never refers to an incomplete data payload.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// This method is typically used to update resources for which normal rendering pipeline latency can be detrimental to user
		/// experience. For example, an application can compute a view matrix from the latest user input (such as from the sensors of a
		/// head-mounted display), and use this function to update and activate this matrix in command lists already dispatched to the GPU
		/// to reduce perceived latency between input and rendering.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint void
		// AtomicCopyBufferUINT( [in] ID3D12Resource *pDstBuffer, UINT64 DstOffset, [in] ID3D12Resource *pSrcBuffer, UINT64 SrcOffset, UINT
		// Dependencies, [in] ID3D12Resource * const *ppDependentResources, [in] const D3D12_SUBRESOURCE_RANGE_UINT64
		// *pDependentSubresourceRanges );
		[PreserveSig]
		new void AtomicCopyBufferUINT([In] ID3D12Resource pDstBuffer, ulong DstOffset, [In] ID3D12Resource pSrcBuffer, ulong SrcOffset, int Dependencies,
			[In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 4)] ID3D12Resource[] ppDependentResources,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] D3D12_SUBRESOURCE_RANGE_UINT64[] pDependentSubresourceRanges);

		/// <summary>
		/// <para>Atomically copies a primary data element of type UINT64 from one resource to another, along with optional dependent resources.</para>
		/// <para>
		/// These 'dependent resources' are so-named because they depend upon the primary data element to locate them, typically the key
		/// element is an address, index, or other handle that refers to one or more the dependent resources indirectly.
		/// </para>
		/// <para>
		/// This function supports a primary data element of type UINT64 (64bit). A different version of this function,
		/// <c>AtomicCopyBufferUINT</c>, supports a primary data element of type UINT (32bit).
		/// </para>
		/// </summary>
		/// <param name="pDstBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>The resource that the UINT64 primary data element is copied into.</para>
		/// </param>
		/// <param name="DstOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the destination resource buffer that specifies where the primary data element is copied into, in bytes. This
		/// offset combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT64 values.
		/// </para>
		/// </param>
		/// <param name="pSrcBuffer">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The resource that the UINT64 primary data element is copied from. This data is typically an address, index, or other handle that
		/// shader code can use to locate the most-recent version of latency-sensitive information.
		/// </para>
		/// </param>
		/// <param name="SrcOffset">
		/// <para>Type: <b>UINT64</b></para>
		/// <para>
		/// An offset into the source resource buffer that specifies where the primary data element is copied from, in bytes. This offset
		/// combined with the base address of the resource buffer must result in a memory address that's naturally aligned for UINT64 values.
		/// </para>
		/// </param>
		/// <param name="Dependencies">
		/// <para>Type: <b>UINT</b></para>
		/// <para>The number of dependent resources.</para>
		/// </param>
		/// <param name="ppDependentResources">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>An array of resources that contain the dependent elements of the data payload.</para>
		/// </param>
		/// <param name="pDependentSubresourceRanges">
		/// <para>Type: <b>const <c>D3D12_SUBRESOURCE_RANGE_UINT64</c>*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(Dependencies)</c></para>
		/// <para>
		/// An array of subresource ranges that specify the dependent elements of the data payload. These elements are completely updated
		/// before the primary data element is itself atomically copied. This ensures that the entire operation is logically atomic; that
		/// is, the primary data element never refers to an incomplete data payload.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// This method is typically used to update resources for which normal rendering pipeline latency can be detrimental to user
		/// experience. For example, an application can compute a view matrix from the latest user input (such as from the sensors of a
		/// head-mounted display), and use this function to update and activate this matrix in command lists already dispatched to the GPU
		/// to reduce perceived latency between input and rendering.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64 void
		// AtomicCopyBufferUINT64( [in] ID3D12Resource *pDstBuffer, UINT64 DstOffset, [in] ID3D12Resource *pSrcBuffer, UINT64 SrcOffset,
		// UINT Dependencies, [in] ID3D12Resource * const *ppDependentResources, [in] const D3D12_SUBRESOURCE_RANGE_UINT64
		// *pDependentSubresourceRanges );
		[PreserveSig]
		new void AtomicCopyBufferUINT64([In] ID3D12Resource pDstBuffer, ulong DstOffset, [In] ID3D12Resource pSrcBuffer, ulong SrcOffset, int Dependencies,
			[In, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 4)] ID3D12Resource[] ppDependentResources,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] D3D12_SUBRESOURCE_RANGE_UINT64[] pDependentSubresourceRanges);

		/// <summary>This method enables you to change the depth bounds dynamically.</summary>
		/// <param name="Min">
		/// <para>Type: <b>FLOAT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Specifies the minimum depth bounds. The default value is 0. NaN values silently convert to 0.</para>
		/// </param>
		/// <param name="Max">
		/// <para>Type: <b>FLOAT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Specifies the maximum depth bounds. The default value is 1. NaN values silently convert to 0.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Depth-bounds testing allows pixels and samples to be discarded if the currently-stored depth value is outside the range
		/// specified by <i>Min</i> and <i>Max</i>, inclusive. If the currently-stored depth value of the pixel or sample is inside this
		/// range, then the depth-bounds test passes and it is rendered; otherwise, the depth-bounds test fails and the pixel or sample is
		/// discarded. Note that the depth-bounds test considers the currently-stored depth value, not the depth value generated by the
		/// executing pixel shader.
		/// </para>
		/// <para>
		/// To use depth-bounds testing, the application must use the new <c>CreatePipelineState</c> method to enable depth-bounds testing
		/// on the PSO and then can use this command list method to change the depth-bounds dynamically.
		/// </para>
		/// <para>
		/// OMSetDepthBounds is an optional feature. Use the <c>CheckFeatureSupport</c> method to determine whether or not this feature is
		/// supported by the user-mode driver. Support for this feature is reported through the <c>D3D12_FEATURE_D3D12_OPTIONS2</c> structure.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-omsetdepthbounds void
		// OMSetDepthBounds( [in] FLOAT Min, [in] FLOAT Max );
		[PreserveSig]
		new void OMSetDepthBounds(float Min, float Max);

		/// <summary>This method configures the sample positions used by subsequent draw, copy, resolve, and similar operations.</summary>
		/// <param name="NumSamplesPerPixel">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// Specifies the number of samples to take, per pixel. This value can be 1, 2, 4, 8, or 16, otherwise the SetSamplePosition call is
		/// dropped. The number of samples must match the sample count configured in the PSO at draw time, otherwise the behavior is undefined.
		/// </para>
		/// </param>
		/// <param name="NumPixels">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// Specifies the number of pixels that sample patterns are being specified for. This value can be either 1 or 4, otherwise the
		/// SetSamplePosition call is dropped. A value of 1 configures a single sample pattern to be used for each pixel; a value of 4
		/// configures separate sample patterns for each pixel in a 2x2 pixel grid which is repeated over the render-target or viewport
		/// space, aligned to even coordinates.
		/// </para>
		/// <para>
		/// Note that the maximum number of combined samples can't exceed 16, otherwise the call is dropped. If NumPixels is set to 4,
		/// NumSamplesPerPixel can specify no more than 4 samples.
		/// </para>
		/// </param>
		/// <param name="pSamplePositions">
		/// <para>Type: <b><c>D3D12_SAMPLE_POSITION</c>*</b></para>
		/// <para><c>SAL</c>: <c>In_reads(NumSamplesPerPixel*NumPixels)</c></para>
		/// <para>
		/// Specifies an array of D3D12_SAMPLE_POSITION elements. The size of the array is NumPixels * NumSamplesPerPixel. If NumPixels is
		/// set to 4, then the first group of sample positions corresponds to the upper-left pixel in the 2x2 grid of pixels; the next group
		/// of sample positions corresponds to the upper-right pixel, the next group to the lower-left pixel, and the final group to the
		/// lower-right pixel.
		/// </para>
		/// <para>
		/// If centroid interpolation is used during rendering, the order of positions for each pixel determines centroid-sampling priority.
		/// That is, the first covered sample in the order specified is chosen as the centroid sample location.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The operational semantics of sample positions are determined by the various draw, copy, resolve, and other operations that can occur.
		/// </para>
		/// <para>
		/// <b>CommandList:</b> In the absence of any prior calls to SetSamplePositions in a CommandList, samples assume the default
		/// position based on the Pipeline State Object (PSO). The default positions are determined either by the SAMPLE_DESC portion of the
		/// PSO if it is present, or by the standard sample positions if the RASTERIZER_DESC portion of the PSO has ForcedSampleCount set to
		/// a value greater than 0.
		/// </para>
		/// <para>
		/// After SetSamplePosition has been called, subsequent draw calls must use a PSO that specifies a matching sample count either
		/// using the SAMPLE_DESC portion of the PSO, or ForcedSampleCount in the RASTERIZER_DESC portion of the PSO.
		/// </para>
		/// <para>
		/// SetSamplePositions can only be called on a graphics CommandList. It can't be called in a bundle; bundles inherit sample position
		/// state from the calling CommandList and don't modify it.
		/// </para>
		/// <para>Calling SetSamplePositions(0, 0, NULL) reverts the sample positions to their default values.</para>
		/// <para><b>Clear RenderTarget:</b> Sample positions are ignored when clearing a render target.</para>
		/// <para>
		/// <b>Clear DepthStencil:</b> When clearing the depth portion of a depth-stencil surface or any region of it, the sample positions
		/// must be set to match those of future rendering to the cleared surface or region; the contents of any uncleared regions produced
		/// using different sample positions become undefined.
		/// </para>
		/// <para>When clearing the stencil portion of a depth-stencil surface or any region of it, the sample positions are ignored.</para>
		/// <para>
		/// <b>Draw to RenderTarget:</b> When drawing to a render target the sample positions can be changed for each draw call, even when
		/// drawing to a region that overlaps previous draw calls. The current sample positions determine the operational semantics of each
		/// draw call and samples are taken from taken from the stored contents of the render target, even if the contents were produced
		/// using different sample positions.
		/// </para>
		/// <para>
		/// <b>Draw using DepthStencil:</b> When drawing to a depth-stencil surface (read or write) or any region of it, the sample
		/// positions must be set to match those used to clear the affected region previously. To use a different sample position, the
		/// target region must be cleared first. The pixels outside the clear region are unaffected.
		/// </para>
		/// <para>
		/// Hardware may store the depth portion or a depth-stencil surface as plane equations, and evaluate them to produce depth values
		/// when the application issues a read. Only the rasterizer and output-merger are required to support programmable sample positions
		/// of the depth portion of a depth-stencil surface. Any other read or write of the depth portion that has been rendered with sample
		/// positions set may ignore them and instead sample at the standard positions.
		/// </para>
		/// <para>
		/// <b>Resolve RenderTarget:</b> When resolving a render target or any region of it, the sample positions are ignored; these APIs
		/// operate only on stored color values.
		/// </para>
		/// <para>
		/// <b>Resolve DepthStencil:</b> When resolving the depth portion of a depth-stencil surface or any region of it, the sample
		/// positions must be set to match those of past rendering to the resolved surface or region. To use a different sample position,
		/// the target region must be cleared first.
		/// </para>
		/// <para>
		/// When resolving the stencil portion of a depth-stencil surface or any region of it, the sample positions are ignored; stencil
		/// resolves operate only on stored stencil values.
		/// </para>
		/// <para>
		/// <b>Copy RenderTarget:</b> When copying from a render target, the sample positions are ignored regardless of whether it is a full
		/// or partial copy.
		/// </para>
		/// <para>
		/// <b>Copy DepthStencil (Full Subresource):</b> When copying a full subresource from a depth-stencil surface, the sample positions
		/// must be set to match the sample positions used to generate the source surface. To use a different sample position, the target
		/// region must be cleared first.
		/// </para>
		/// <para>
		/// On some hardware properties of the source surface (such as stored plane equations for depth values) transfer to the destination.
		/// Therefore, if the destination surface is subsequently drawn to, the sample positions originally used to generate the source
		/// content need to be used with the destination surface. The API requires this on all hardware for consistency even if it may only
		/// apply to some.
		/// </para>
		/// <para>
		/// <b>Copy DepthStencil (Partial Subresource):</b> When copying a partial subresource from a depth-stencil surface, the sample
		/// positions must be set to match the sample positions used to generate the source surface, similarly to copying a full
		/// subresource. However, if the content of an affected destination subresources is only partially covered by the copy, the contents
		/// of the uncovered portion within those subresources becomes undefined unless all of it was generated using the same sample
		/// positions as the copy source. To use a different sample position, the target region must be cleared first.
		/// </para>
		/// <para>
		/// When copying a partial subresource from the stencil portion of a depth-stencil surface, the sample postions are ignored. It
		/// doesnt matter what sample positions were used to generate content for any other areas of the destination buffer not covered by
		/// the copy  those contents remain valid.
		/// </para>
		/// <para>
		/// <b>Shader SamplePos:</b> The HLSL SamplePos intrinsic is not aware of programmable sample positions and results returned to
		/// shaders calling this on a surface rendered with programmable positions is undefined. Applications must pass coordinates into
		/// their shader manually if needed. Similarly evaluating attributes by sample index is undefined with programmable sample positions.
		/// </para>
		/// <para>
		/// <b>Transitioning out of DEPTH_READ or DEPTH_WRITE state:</b> If a subresource in DEPTH_READ or DEPTH_WRITE state is transitioned
		/// to any other state, including COPY_SOURCE or RESOLVE_SOURCE, some hardware might need to decompress the surface. Therefore, the
		/// sample positions must be set on the command list to match those used to generate the content in the source surface. Furthermore,
		/// for any subsequent transitions of the surface while the same depth data remains in it, the sample positions must continue to
		/// match those set on the command list. To use a different sample position, the target region must be cleared first.
		/// </para>
		/// <para>
		/// If an application wants to minimize the decompressed area when only a portion needs to be used, or just to preserve compression,
		/// ResolveSubresourceRegion() can be called in DECOMPRESS mode with a rect specified. This will decompress just the relevant area
		/// to a separate resource leaving the source intact on some hardware, though on other hardware even the source area is
		/// decompressed. The separate explicitly decompressed resource can then be transitioned to the desired state (such as SHADER_RESOURCE).
		/// </para>
		/// <para>
		/// <b>Transitioning out of RENDER_TARGET state:</b> If a subresource in RENDER_TARGET state is transitioned to anything other than
		/// COPY_SOURCE or RESOLVE_SOURCE, some implementations may need to decompress the surface. This decompression is agnostic to sample positions.
		/// </para>
		/// <para>
		/// If an application wants to minimize the decompressed area when only a portion needs to be used, or just to preserve compression,
		/// ResolveSubresourceRegion() can be called in DECOMPRESS mode with a rect specified. This will decompress just the relevant area
		/// to a separate resource leaving the source intact on some hardware, though on other hardware even the source area is
		/// decompressed. The separate explicitly decompressed resource can then be transitioned to the desired state (such as SHADER_RESOURCE).
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-setsamplepositions void
		// SetSamplePositions( [in] UINT NumSamplesPerPixel, [in] UINT NumPixels, [in] D3D12_SAMPLE_POSITION *pSamplePositions );
		[PreserveSig]
		new void SetSamplePositions(uint NumSamplesPerPixel, uint NumPixels,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_SAMPLE_POSITION[] pSamplePositions);

		/// <summary>Copy a region of a multisampled or compressed resource into a non-multisampled or non-compressed resource.</summary>
		/// <param name="pDstResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// Destination resource. Must be created with the <b>D3D11_USAGE_DEFAULT</b> flag and must be single-sampled unless its to be
		/// resolved from a compressed resource ( <b>D3D12_RESOLVE_MODE_DECOMPRESS</b>); in this case it must have the same sample count as
		/// the compressed source.
		/// </para>
		/// </param>
		/// <param name="DstSubresource">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// A zero-based index that identifies the destination subresource. Use <c>D3D12CalcSubresource</c> to calculate the subresource
		/// index if the parent resource is complex.
		/// </para>
		/// </param>
		/// <param name="DstX">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The X coordinate of the left-most edge of the destination region. The width of the destination region is the same as the width
		/// of the source rect.
		/// </para>
		/// </param>
		/// <param name="DstY">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>
		/// The Y coordinate of the top-most edge of the destination region. The height of the destination region is the same as the height
		/// of the source rect.
		/// </para>
		/// </param>
		/// <param name="pSrcResource">
		/// <para>Type: <b>ID3D12Resource*</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Source resource. Must be multisampled or compressed.</para>
		/// </param>
		/// <param name="SrcSubresource">
		/// <para>Type: <b>UINT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>A zero-based index that identifies the source subresource.</para>
		/// </param>
		/// <param name="pSrcRect">
		/// <para>Type: <b>D3D12_RECT*</b></para>
		/// <para><c>SAL</c>: <c>In_opt</c></para>
		/// <para>
		/// Specifies the rectangular region of the source resource to be resolved. Passing NULL for <i>pSrcRect</i> specifies that the
		/// entire subresource is to be resolved.
		/// </para>
		/// </param>
		/// <param name="Format">
		/// <para>Type: <b>DXGI_FORMAT</b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>A DXGI_FORMAT that specifies how the source and destination resource formats are consolidated.</para>
		/// </param>
		/// <param name="ResolveMode">
		/// <para>Type: <b><c>D3D12_RESOLVE_MODE</c></b></para>
		/// <para><c>SAL</c>: <c>In</c></para>
		/// <para>Specifies the operation used to resolve the source samples.</para>
		/// <para>
		/// When using the <b>D3D12_RESOLVE_MODE_DECOMPRESS</b> operation, the sample count can be larger than 1 as long as the source and
		/// destination have the same sample count, and source and destination may specify the same resource as long as the source rect
		/// aligns with the destination X and Y coordinates, in which case decompression occurs in place.
		/// </para>
		/// <para>
		/// When using the <b>D3D12_RESOLVE_MODE_MIN</b>, <b>D3D12_RESOLVE_MODE_MAX</b>, or <b>D3D12_RESOLVE_MODE_AVERAGE</b> operation, the
		/// destination must have a sample count of 1.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// ResolveSubresourceRegion operates like <c>ResolveSubresource</c> but allows for only part of a resource to be resolved and for
		/// source samples to be resolved in several ways. Partial resolves can be useful in multi-adapter scenarios; for example, when the
		/// rendered area has been partitioned across adapters, each adapter might only need to resolve the portion of a subresource that
		/// corresponds to its assigned partition.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion void
		// ResolveSubresourceRegion( [in] ID3D12Resource *pDstResource, [in] UINT DstSubresource, [in] UINT DstX, [in] UINT DstY, [in]
		// ID3D12Resource *pSrcResource, [in] UINT SrcSubresource, [in, optional] D3D12_RECT *pSrcRect, [in] DXGI_FORMAT Format, [in]
		// D3D12_RESOLVE_MODE ResolveMode );
		[PreserveSig]
		new void ResolveSubresourceRegion([In] ID3D12Resource pDstResource, uint DstSubresource, uint DstX, uint DstY, [In] ID3D12Resource pSrcResource,
			uint SrcSubresource, [In, Optional] PRECT? pSrcRect, DXGI_FORMAT Format, D3D12_RESOLVE_MODE ResolveMode);

		/// <summary>Set a mask that controls which view instances are enabled for subsequent draws.</summary>
		/// <param name="Mask">
		/// <para>Type: <b>UINT</b></para>
		/// <para>
		/// A mask that specifies which views are enabled or disabled. If bit <i>i</i> starting from the least-significant bit is set, view
		/// instance <i>i</i> is enabled.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// The view instance mask only affects PSOs that declare view instance masking by specifying the
		/// D3D12_VIEW_INSTANCING_FLAG_ENABLE_VIEW_INSTANCE_MASKING flag during their creation. Attempting to create a PSO that declares
		/// view instance masking will fail on adapters that don't support view instancing.
		/// </para>
		/// <para>
		/// The view instance mask defaults to 0 which disables all views. This forces applications that declare view instance masking to
		/// explicitly choose the views to enable, otherwise nothing will be rendered. If the view instance mask enabled all views by
		/// default the application might not remember to disable unused views, resulting in lost performance due to wasted work.
		/// </para>
		/// <para>
		/// Bundles don't inherit their view instance mask from their caller, defaulting to 0 instead. This is because the mask setting must
		/// be known when the bundle is recorded if it affects how an implementation records draws. The view instance mask set by a bundle
		/// does persist to the caller after the bundle completes, however. These inheritance semantics are similar to those of PSOs.
		/// </para>
		/// <para>
		/// No shader code paths that are dependent on SV_ViewID are executed at any shader stage for view instances that are masked off and
		/// no clipping, viewport processing, or rasterization is performed. Implementations that inspect the mask during rendering can
		/// incur a small performance penalty over PSOs that don't declare view instance masking at all, but usually the penalty can be
		/// overcome by the performance savings that result from skipping the work associated with the masked off views. Depending on the
		/// frequency and amount of skipped work, the performance gains can be significant.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-setviewinstancemask void
		// SetViewInstanceMask( [in] UINT Mask );
		[PreserveSig]
		new void SetViewInstanceMask(uint Mask);

		/// <summary>Writes a number of 32-bit immediate values to the specified buffer locations directly from the command stream.</summary>
		/// <param name="Count">
		/// The number of <c>D3D12_WRITEBUFFERIMMEDIATE_PARAMETER</c> structures that are pointed to by <i>pParams</i> and <i>pModes</i>.
		/// </param>
		/// <param name="pParams">
		/// The address of an array containing a number of <c>D3D12_WRITEBUFFERIMMEDIATE_PARAMETER</c> structures equal to <i>Count</i>.
		/// </param>
		/// <param name="pModes">
		/// The address of an array containing a number of <c>D3D12_WRITEBUFFERIMMEDIATE_MODE</c> structures equal to <i>Count</i>. The
		/// default value is <b>null</b>; passing <b>null</b> causes the system to write all immediate values using <b>D3D12_WRITEBUFFERIMMEDIATE_MODE_DEFAULT</b>.
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// <b>WriteBufferImmediate</b> performs <i>Count</i> number of 32-bit writes: one for each value and destination specified in <i>pParams</i>.
		/// </para>
		/// <para>
		/// The receiving buffer (resource) must be in the <b>D3D12_RESOURCE_STATE_COPY_DEST</b> state to be a valid destination for <b>WriteBufferImmediate</b>.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist2-writebufferimmediate void
		// WriteBufferImmediate( UINT Count, [in] const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER *pParams, [in, optional] const
		// D3D12_WRITEBUFFERIMMEDIATE_MODE *pModes );
		[PreserveSig]
		new void WriteBufferImmediate(int Count, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_WRITEBUFFERIMMEDIATE_PARAMETER[] pParams,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_WRITEBUFFERIMMEDIATE_MODE[] pModes);

		/// <summary>
		/// Specifies whether or not protected resources can be accessed by subsequent commands in the command list. By default, no
		/// protected resources are enabled. After calling <b>SetProtectedResourceSession</b> with a valid session, protected resources of
		/// the same type can refer to that session. After calling <b>SetProtectedResourceSession</b> with <b>NULL</b>, no protected
		/// resources can be accessed.
		/// </summary>
		/// <param name="pProtectedResourceSession">
		/// <para>Type: <b><c>ID3D12ProtectedResourceSession</c>*</b></para>
		/// <para>
		/// An optional pointer to an <b>ID3D12ProtectedResourceSession</b>. You can obtain an <b>ID3D12ProtectedResourceSession</b> by
		/// calling <c>ID3D12Device4::CreateProtectedResourceSession</c>.
		/// </para>
		/// </param>
		/// <returns>
		/// If set, indicates that protected resources can be accessed with the given session. Access to protected resources can only happen
		/// after <b>SetProtectedResourceSession</b> is called with a valid session. The command list state is cleared when calling this
		/// method. If you pass <b>NULL</b>, then no protected resources can be accessed.
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist3-setprotectedresourcesession void
		// SetProtectedResourceSession( [in, optional] ID3D12ProtectedResourceSession *pProtectedResourceSession );
		[PreserveSig]
		new void SetProtectedResourceSession([In, Optional] ID3D12ProtectedResourceSession? pProtectedResourceSession);

		/// <summary>
		/// Marks the beginning of a render pass by binding a set of output resources for the duration of the render pass. These bindings
		/// are to one or more render target views (RTVs), and/or to a depth stencil view (DSV).
		/// </summary>
		/// <param name="NumRenderTargets">A <b>UINT</b>. The number of render targets being bound.</param>
		/// <param name="pRenderTargets">
		/// A pointer to a constant <c>D3D12_RENDER_PASS_RENDER_TARGET_DESC</c>, which describes bindings (fixed for the duration of the
		/// render pass) to one or more render target views (RTVs), as well as their beginning and ending access characteristics.
		/// </param>
		/// <param name="pDepthStencil">
		/// A pointer to a constant <c>D3D12_RENDER_PASS_DEPTH_STENCIL_DESC</c>, which describes a binding (fixed for the duration of the
		/// render pass) to a depth stencil view (DSV), as well as its beginning and ending access characteristics.
		/// </param>
		/// <param name="Flags">
		/// A <c>D3D12_RENDER_PASS_FLAGS</c>. The nature/requirements of the render pass; for example, whether it is a suspending or a
		/// resuming render pass, or whether it wants to write to unordered access view(s).
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass void
		// BeginRenderPass( UINT NumRenderTargets, const D3D12_RENDER_PASS_RENDER_TARGET_DESC *pRenderTargets, const
		// D3D12_RENDER_PASS_DEPTH_STENCIL_DESC *pDepthStencil, D3D12_RENDER_PASS_FLAGS Flags );
		[PreserveSig]
		new void BeginRenderPass(int NumRenderTargets, [In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_RENDER_PASS_RENDER_TARGET_DESC[]? pRenderTargets,
			[In, Optional] ManagedStructPointer<D3D12_RENDER_PASS_DEPTH_STENCIL_DESC> pDepthStencil, D3D12_RENDER_PASS_FLAGS Flags);

		/// <summary>Marks the ending of a render pass.</summary>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-endrenderpass void EndRenderPass();
		[PreserveSig]
		new void EndRenderPass();

		/// <summary>
		/// <para>Initializes the specified meta command.</para>
		/// <para>
		/// You must initialize a meta command at least once prior (on the GPU's timeline) to executing it. Initializing gives the
		/// implementation the chance to perform any work necessary to accelerate the invocation of the meta command. You must supply the
		/// sufficient resource parameters, including the persistent cache resource.
		/// </para>
		/// </summary>
		/// <param name="pMetaCommand">A pointer to an <c>ID3D12MetaCommand</c> representing the meta command to initialize.</param>
		/// <param name="pInitializationParametersData">
		/// An optional pointer to a constant structure containing the values of the parameters for initializing the meta command.
		/// </param>
		/// <param name="InitializationParametersDataSizeInBytes">
		/// A <c>SIZE_T</c> containing the size of the structure pointed to by <i>pInitializationParametersData</i>, if set, otherwise 0.
		/// </param>
		/// <returns>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-initializemetacommand void
		// InitializeMetaCommand( [in] ID3D12MetaCommand *pMetaCommand, [in, optional] const void *pInitializationParametersData, [in]
		// SIZE_T InitializationParametersDataSizeInBytes );
		[PreserveSig]
		new void InitializeMetaCommand([In] ID3D12MetaCommand pMetaCommand, [In, Optional] IntPtr pInitializationParametersData,
			[In] SizeT InitializationParametersDataSizeInBytes);

		/// <summary>
		/// <para>Records the execution (or invocation) of the specified meta command into a graphics command list.</para>
		/// <para>
		/// Call <c>ID3D12GraphicsCommandList4::InitializeMetaCommand</c> before executing a meta command. During invocation, you can
		/// specify overrides for values of any of the runtime parameters. You can execute multiple meta commands on the same graphics
		/// command list. And you can execute the same meta command multiple times on the same command list.
		/// </para>
		/// <para>
		/// With a PIX capture taken with the use of meta commands, you can play that back on the same hardware configuration. But, by
		/// design, it's not portable to other GPUs.
		/// </para>
		/// </summary>
		/// <param name="pMetaCommand">A pointer to an <b>ID3D12MetaCommand</b> representing the meta command to initialize.</param>
		/// <param name="pExecutionParametersData">
		/// An optional pointer to a constant structure containing the values of the parameters for executing the meta command.
		/// </param>
		/// <param name="ExecutionParametersDataSizeInBytes">
		/// A <c>SIZE_T</c> containing the size of the structure pointed to by <i>pExecutionParametersData</i>, if set, otherwise 0.
		/// </param>
		/// <returns>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</returns>
		/// <remarks>
		/// <para>
		/// Your application is responsible for setting up the resources supplied to a meta command in the state required according to the
		/// meta command specification. The meta command definition specification defines the expected resource state for each parameter.
		/// Your application is responsible for inserting unordered access view (UAV) barriers for input resources before the meta command's
		/// algorithm can consume them. You're also responsible for inserting the UAV barrier for the output resources when you intend to
		/// read them back.
		/// </para>
		/// <para>
		/// During an algorithm invocation, the driver may insert as many UAV barriers to output resources as are needed to synchronize the
		/// output resource usage in the algorithm implementation. From your application's point of view, you should assume that all out and
		/// in/out resources are written to by the meta command, including scratch memory.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-executemetacommand void
		// ExecuteMetaCommand( [in] ID3D12MetaCommand *pMetaCommand, [in, optional] const void *pExecutionParametersData, [in] SIZE_T
		// ExecutionParametersDataSizeInBytes );
		[PreserveSig]
		new void ExecuteMetaCommand([In] ID3D12MetaCommand pMetaCommand, [In, Optional] IntPtr pExecutionParametersData, [In] SizeT ExecutionParametersDataSizeInBytes);

		/// <summary>
		/// Performs a raytracing acceleration structure build on the GPU and optionally outputs post-build information immediately after
		/// the build.
		/// </summary>
		/// <param name="pDesc">Description of the acceleration structure to build.</param>
		/// <param name="NumPostbuildInfoDescs">Size of the <i>pPostbuildInfoDescs</i> array. Set to 0 if no post-build info is needed.</param>
		/// <param name="pPostbuildInfoDescs">
		/// Optional array of descriptions for post-build info to generate describing properties of the acceleration structure that was built.
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This method can be called on graphics or compute command lists but not from bundles.</para>
		/// <para>
		/// Post-build information can also be obtained separately from an already built acceleration structure by calling
		/// <c>EmitRaytracingAccelerationStructurePostbuildInfo</c>. The advantage of generating post-build info along with a build is that
		/// a barrier isnt needed in between the build completing and requesting post-build information, enabling scenarios where the app
		/// needs the post-build info right away.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-buildraytracingaccelerationstructure
		// void BuildRaytracingAccelerationStructure( [in] const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC *pDesc, [in] UINT
		// NumPostbuildInfoDescs, [in] const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC *pPostbuildInfoDescs );
		[PreserveSig]
		new void BuildRaytracingAccelerationStructure(in D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC pDesc, int NumPostbuildInfoDescs,
			[In, Optional, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC[]? pPostbuildInfoDescs);

		/// <summary>
		/// Emits post-build properties for a set of acceleration structures. This enables applications to know the output resource
		/// requirements for performing acceleration structure operations via <c>ID3D12GraphicsCommandList4::CopyRaytracingAccelerationStructure</c>.
		/// </summary>
		/// <param name="pDesc">
		/// A <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC</c> object describing post-build information to generate.
		/// </param>
		/// <param name="NumSourceAccelerationStructures">
		/// Number of pointers to acceleration structure GPU virtual addresses pointed to by <i>pSourceAccelerationStructureData</i>. This
		/// number also affects the destination (output), which will be a contiguous array of <b>NumSourceAccelerationStructures</b> output
		/// structures, where the type of the structures depends on <i>InfoType</i> field of the supplied in the <i>pDesc</i> description.
		/// </param>
		/// <param name="pSourceAccelerationStructureData">
		/// <para>Pointer to array of GPU virtual addresses of size <i>NumSourceAccelerationStructures</i>.</para>
		/// <para>The address must be aligned to 256 bytes, defined as <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT</c>.</para>
		/// <para>The memory pointed to must be in state <c>D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE</c>.</para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>This method can be called from graphics or compute command lists but not from bundles.</remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-emitraytracingaccelerationstructurepostbuildinfo
		// void EmitRaytracingAccelerationStructurePostbuildInfo( [in] const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC
		// *pDesc, [in] UINT NumSourceAccelerationStructures, [in] const D3D12_GPU_VIRTUAL_ADDRESS *pSourceAccelerationStructureData );
		[PreserveSig]
		new void EmitRaytracingAccelerationStructurePostbuildInfo(in D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC pDesc,
			int NumSourceAccelerationStructures, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] D3D12_GPU_VIRTUAL_ADDRESS[] pSourceAccelerationStructureData);

		/// <summary>Copies a source acceleration structure to destination memory while applying the specified transformation.</summary>
		/// <param name="DestAccelerationStructureData">
		/// <para>
		/// The destination memory. The required size can be discovered by calling <c>EmitRaytracingAccelerationStructurePostbuildInfo</c>
		/// beforehand, if necessary for the specified <i>Mode</i>.
		/// </para>
		/// <para>
		/// The destination start address must be aligned to 256 bytes, defined as
		/// <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT</c>, regardless of the specified <i>Mode</i>.
		/// </para>
		/// <para>The destination memory range cannot overlap source. Otherwise, results are undefined.</para>
		/// <para>
		/// The resource state that the memory pointed to must be in depends on the <i>Mode</i> parameter. For more information, see <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE</c>.
		/// </para>
		/// </param>
		/// <param name="SourceAccelerationStructureData">
		/// <para>
		/// The address of the acceleration structure or other type of data to copy/transform based on the specified <i>Mode</i>. The data
		/// remains unchanged and usable. The operation only copies the data pointed to by <i>SourceAccelerationStructureData</i> and not
		/// any other data, such as acceleration structures, that the source data may point to. For example, in the case of a top-level
		/// acceleration structure, any bottom-level acceleration structures that it points to are not copied in the operation.
		/// </para>
		/// <para>
		/// The source memory must be aligned to 256 bytes, defined as <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT</c>,
		/// regardless of the specified <i>Mode</i>.
		/// </para>
		/// <para>
		/// The resource state that the memory pointed to must be in depends on the <i>Mode</i> parameter. For more information, see <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE</c>.
		/// </para>
		/// </param>
		/// <param name="Mode">The type of copy operation to perform. For more information, see <c>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE</c>.</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// Since raytracing acceleration structures may contain internal pointers and have a device dependent opaque layout, copying them
		/// around or otherwise manipulating them requires a dedicated API so that drivers can handle the requested operation.
		/// </para>
		/// <para>This method can be called from graphics or compute command lists but not from bundles.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-copyraytracingaccelerationstructure
		// void CopyRaytracingAccelerationStructure( [in] D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData, [in]
		// D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData, [in] D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode );
		[PreserveSig]
		new void CopyRaytracingAccelerationStructure(D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData, D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData,
			D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode);

		/// <summary>Sets a state object on the command list.</summary>
		/// <param name="pStateObject">The state object to set on the command list. In the current release, this can only be of type <c>D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE</c>.</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This method can be called from graphics or compute command lists and bundles.</para>
		/// <para>
		/// This method is an alternative to <c>ID3D12GraphicsCommandList::SetPipelineState</c>, which is only defined for graphics and
		/// compute shaders. There is only one pipeline state active on a command list at a time, so either call sets the current pipeline
		/// state. The distinction between the calls is that each sets particular types of pipeline state only. In the current release,
		/// <b>SetPipelineState1</b> is only used for setting raytracing pipeline state.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-setpipelinestate1 void
		// SetPipelineState1( ID3D12StateObject *pStateObject );
		[PreserveSig]
		new void SetPipelineState1([In] ID3D12StateObject pStateObject);

		/// <summary>Launch the threads of a ray generation shader.</summary>
		/// <param name="pDesc">A description of the ray dispatch</param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>This method can be called from graphics or compute command lists and bundles.</para>
		/// <para>A raytracing pipeline state must be set on the command list. Otherwise, the behavior of this call is undefined.</para>
		/// <para>
		/// There are 3 dimensions passed in to set the grid size: width/height/depth. These dimensions are constrained such that width *
		/// height * depth &lt;= 2^30. Exceeding this produces undefined behavior. If any grid dimension is 0, no threads are launched.
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-dispatchrays void DispatchRays(
		// [in] const D3D12_DISPATCH_RAYS_DESC *pDesc );
		[PreserveSig]
		new void DispatchRays(in D3D12_DISPATCH_RAYS_DESC pDesc);

		/// <summary>
		/// Sets the base shading rate, and combiners, for variable-rate shading (VRS). For more info, see <c>Variable-rate shading (VRS)</c>.
		/// </summary>
		/// <param name="baseShadingRate">
		/// <para>Type: <c><b>D3D12_SHADING_RATE</b></c></para>
		/// <para>A constant from the <c>D3D12_SHADING_RATE</c> enumeration describing the base shading rate to set.</para>
		/// </param>
		/// <param name="combiners">
		/// <para>Type: <b>const <c>D3D12_SHADING_RATE_COMBINER</c>*</b></para>
		/// <para>
		/// An optional pointer to a constant array of <c><b>D3D12_SHADING_RATE_COMBINER</b></c> containing the shading rate combiners to
		/// set. The count of <c><b>D3D12_SHADING_RATE_COMBINER</b></c> elements in the array must be equal to the constant
		/// <c><b>D3D12_RS_SET_SHADING_RATE_COMBINER_COUNT</b></c>, which is equal to <b>2</b>.
		/// </para>
		/// <para>
		/// Because per-primitive and screen-space image-based VRS isn't supported on Tier1 <c>Variable-rate shading (VRS)</c>, for these
		/// values to be meaningful, the adapter requires Tier2 VRS support. See <c><b>D3D12_FEATURE_DATA_D3D12_OPTIONS6</b></c> and <c><b>D3D12_VARIABLE_SHADING_RATE_TIER</b></c>.
		/// </para>
		/// <para>A <b>NULL</b> pointer is equivalent to the default shading combiners, which are both <c><b>D3D12_SHADING_RATE_COMBINER_PASSTHROUGH</b></c>.</para>
		/// <para>The algorithm for final shading-rate is determined by the following.</para>
		/// </param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist5-rssetshadingrate void
		// RSSetShadingRate( D3D12_SHADING_RATE baseShadingRate, const D3D12_SHADING_RATE_COMBINER *combiners );
		[PreserveSig]
		new void RSSetShadingRate(D3D12_SHADING_RATE baseShadingRate, [In, Optional, MarshalAs(UnmanagedType.LPArray)] D3D12_SHADING_RATE_COMBINER[]? combiners);

		/// <summary>
		/// Sets the screen-space shading-rate image for variable-rate shading (VRS). For more info, see <c>Variable-rate shading (VRS)</c>.
		/// This method requires Tier2 <c>Variable-rate shading (VRS)</c> support. See <c><b>D3D12_FEATURE_DATA_D3D12_OPTIONS6</b></c> and <c><b>D3D12_VARIABLE_SHADING_RATE_TIER</b></c>.
		/// </summary>
		/// <param name="shadingRateImage">
		/// <para>Type: <b><c>ID3D12Resource</c>*</b></para>
		/// <para>
		/// An optional pointer to an <c>ID3D12Resource</c> representing a screen-space shading-rate image. If <b>NULL</b>, the effect is
		/// the same as having a shading-rate image where all values are a shading rate of 1x1.
		/// </para>
		/// <para>This texture must have the <c><b>D3D12_RESOURCE_STATE_SHADING_RATE_SOURCE</b></c> state applied.</para>
		/// <para>
		/// The tile-size of the shading-rate image can be determined via <c><b>D3D12_FEATURE_DATA_D3D12_OPTIONS6</b></c>. The size of the
		/// shading-rate image should therefore be
		/// </para>
		/// <para>
		/// The shading-rate image must be a 2D texture with a single mip, and format <c><b>DXGI_FORMAT_R8_UINT</b></c>. Each texel must be
		/// a value corresponding to <c><b>D3D12_SHADING_RATE</b></c>. It must have layout <c><b>D3D12_TEXTURE_LAYOUT_UNKNOWN</b></c> and
		/// can't be a depth-stencil, render-target, simultaneous-access, or cross-adapter resource.
		/// </para>
		/// <para>
		/// As (0, 0) is the top left in DirectX, a too-small or large shading-rate image results in the bottom or right having no
		/// shading-rate image area, or the image extending in these directions. When there is excess, it is ignored (but legal), and when
		/// the image is too small, all out-of-bounds areas in the bottom and right will have the default shading rate of 1x1 from the image
		/// (however, this does not mean that is the final shading rate. The combiners will still be applied to this 1x1 default value).
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// For the screen-space shading-rate image to take affect, <c><b>ID3D12GraphicsCommandList5::RSSetShadingRate</b></c> must have
		/// been called to set the combiners for shading. Else, with the default combiners (both
		/// <c><b>D3D12_SHADING_RATE_COMBINER_PASSTHROUGH</b></c>), the screen-space shading-rate image is ignored in determining shading granularity.
		/// </para>
		/// <para>
		/// The second combiner passed to [ <b>ID3D12GraphicsCommandList5::RSSetShadingRate</b>] is the one which applies to the
		/// shading-rate image, which occurs after the global shading rate and the per-primitive shading rate have been combined.
		/// </para>
		/// <para>The algorithm for final shading-rate is determined by</para>
		/// <para>
		/// <c>postRasterizerRate = ApplyCombiner(Combiners[0], CommandListShadingRate, Primitive-&gt;PrimitiveSpecifiedShadingRate);
		/// finalRate = ApplyCombiner(Combiners[1], postRasterizerRate, ScreenSpaceImage[xy]);</c>
		/// </para>
		/// <para>where <c>ApplyCombiner</c> is</para>
		/// <para>
		/// <c>UINT ApplyCombiner(D3D12_SHADING_RATE_COMBINER combiner, UINT a, UINT b) { MaxShadingRate =
		/// options6.AdditionalShadingRatesSupported ? 4 : 2; switch (combiner) { case D3D12_SHADING_RATE_COMBINER_PASSTHROUGH: // default
		/// return a; case D3D12_SHADING_RATE_COMBINER_OVERRIDE: return b; case D3D12_SHADING_RATE_COMBINER_MAX: return max(a, b); case
		/// D3D12_SHADING_RATE_COMBINER_MIN: return min(a, b); case D3D12_SHADING_RATE_COMBINER_SUM: return min(MaxShadingRate, a + b); case
		/// default: return a; } }</c>
		/// </para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist5-rssetshadingrateimage void
		// RSSetShadingRateImage( ID3D12Resource *shadingRateImage );
		[PreserveSig]
		new void RSSetShadingRateImage([In, Optional] ID3D12Resource? shadingRateImage);

		/// <summary/>
		/// <param name="ThreadGroupCountX"/>
		/// <param name="ThreadGroupCountY"/>
		/// <param name="ThreadGroupCountZ"/>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist6-dispatchmesh void DispatchMesh(
		// UINT ThreadGroupCountX, UINT ThreadGroupCountY, UINT ThreadGroupCountZ );
		[PreserveSig]
		new void DispatchMesh(uint ThreadGroupCountX, uint ThreadGroupCountY, uint ThreadGroupCountZ);

		/// <summary>
		/// <para>Adds a collection of barriers into a graphics command list recording.</para>
		/// <para>Requires the DirectX 12 Agility SDK 1.608 or later.</para>
		/// </summary>
		/// <param name="NumBarrierGroups">Number of barrier groups pointed to by pBarrierGroups.</param>
		/// <param name="pBarrierGroups">Pointer to an array of <c>D3D12_BARRIER_GROUP</c> objects.</param>
		/// <returns>None</returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist7-barrier void Barrier( UINT32
		// NumBarrierGroups, const D3D12_BARRIER_GROUP *pBarrierGroups );
		[PreserveSig]
		new void Barrier(int NumBarrierGroups, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] D3D12_BARRIER_GROUP[] pBarrierGroups);

		[PreserveSig]
		new void OMSetFrontAndBackStencilRef(uint FrontStencilRef, uint BackStencilRef);

		[PreserveSig]
		void RSSetDepthBias(float DepthBias, float DepthBiasClamp, float SlopeScaledDepthBias);

		[PreserveSig]
		void IASetIndexBufferStripCutValue(D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue);
	}

	[ComImport, Guid("460caac7-1d24-446a-a184-ca67db494138"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ID3D12StateObjectProperties1 : ID3D12StateObjectProperties
	{
		/// <summary>Retrieves the unique identifier for a shader that can be used in a shader record.</summary>
		/// <param name="pExportName">Entrypoint in the state object for which to retrieve an identifier.</param>
		/// <returns>
		/// <para>A pointer to the shader identifier.</para>
		/// <para>
		/// The data referenced by this pointer is valid as long as the state object it came from is valid. The size of the data returned is
		/// <c>D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES</c>. Applications should copy and cache this data to avoid the cost of searching for it
		/// in the state object if it will need to be retrieved many times. The identifier is used in shader records within shader tables in
		/// GPU memory, which the app must populate.
		/// </para>
		/// <para>
		/// The data itself globally identifies the shader, so even if the shader appears in a different state object with same
		/// associations, like any root signatures, it will have the same identifier.
		/// </para>
		/// <para>If the shader isnt fully resolved in the state object, the return value is <b>nullptr</b>.</para>
		/// </returns>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12stateobjectproperties-getshaderidentifier void *
		// GetShaderIdentifier( LPCWSTR pExportName );
		[PreserveSig]
		new void GetShaderIdentifier([MarshalAs(UnmanagedType.LPWStr)] string pExportName);

		/// <summary>Gets the amount of stack memory required to invoke a raytracing shader in HLSL.</summary>
		/// <param name="pExportName">
		/// <para>
		/// The shader entrypoint in the state object for which to retrieve stack size. For hit groups, an individual shader within the hit
		/// group must be specified using the syntax:
		/// </para>
		/// <para>hitGroupName::shaderType</para>
		/// <para>Where <i>hitGroupName</i> is the entrypoint name for the hit group and <i>shaderType</i> is one of:</para>
		/// <list type="bullet">
		/// <item>
		/// <description>intersection</description>
		/// </item>
		/// <item>
		/// <description>anyhit</description>
		/// </item>
		/// <item>
		/// <description>closesthit</description>
		/// </item>
		/// </list>
		/// <para>These values are all case-sensitive.</para>
		/// <para>An example value is: "myTreeLeafHitGroup::anyhit".</para>
		/// </param>
		/// <returns>
		/// Amount of stack memory, in bytes, required to invoke the shader. If the shader isnt fully resolved in the state object, or the
		/// shader is unknown or of a type for which a stack size isnt relevant, such as a hit group, the return value is 0xffffffff. The
		/// 32-bit 0xffffffff value is used for the UINT64 return value to ensure that bad return values dont get lost when summed up with
		/// other values as part of calculating an overall pipeline stack size.
		/// </returns>
		/// <remarks>
		/// <para>
		/// This method only needs to be called if the app wants to configure the stack size by calling <c>SetPipelineStackSize</c>, rather
		/// than relying on the conservative default stack size. This method is only valid for ray generation shaders, hit groups, miss
		/// shaders, and callable shaders. Even ray generation shaders may return a non-zero value despite being at the bottom of the stack.
		/// </para>
		/// <para>
		/// For hit groups, stack size must be queried for the individual shaders comprising it (intersection shaders, any hit shaders,
		/// closest hit shaders), as each likely has a different stack size requirement. The stack size cant be queried on these individual
		/// shaders directly, as the way they are compiled can be influenced by the overall hit group that contains them. The
		/// <i>pExportName</i> parameter includes syntax for identifying individual shaders within a hit group.
		/// </para>
		/// <para>This API can be called on either collection state objects or raytracing pipeline state objects.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12stateobjectproperties-getshaderstacksize UINT64
		// GetShaderStackSize( LPCWSTR pExportName );
		[PreserveSig]
		new ulong GetShaderStackSize([MarshalAs(UnmanagedType.LPWStr)] string pExportName);

		/// <summary>Gets the current pipeline stack size.</summary>
		/// <returns>
		/// The current pipeline stack size in bytes. When called on non-executable state objects, such as collections, the return value is 0.
		/// </returns>
		/// <remarks>
		/// This method and <c>SetPipelineStackSize</c> are not re-entrant. This means if calling either or both from separate threads, the
		/// app must synchronize on its own.
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12stateobjectproperties-getpipelinestacksize UINT64 GetPipelineStackSize();
		[PreserveSig]
		new ulong GetPipelineStackSize();

		/// <summary>Set the current pipeline stack size.</summary>
		/// <param name="PipelineStackSizeInBytes">
		/// <para>
		/// Stack size in bytes to use during pipeline execution for each shader thread. There can be many thousands of threads in flight at
		/// once on the GPU.
		/// </para>
		/// <para>
		/// If the value is greater than 0xffffffff (the maximum value of a 32-bit UINT) the runtime will drop the call, and the debug layer
		/// will print an error, as this is likely the result of summing up invalid stack sizes returned from <c>GetShaderStackSize</c>
		/// called with invalid parameters, which return 0xffffffff. In this case, the previously set stack size, or the default, remains.
		/// </para>
		/// </param>
		/// <returns>None</returns>
		/// <remarks>
		/// <para>
		/// This method and <c>GetPipelineStackSize</c> are not re-entrant. This means if calling either or both from separate threads, the
		/// app must synchronize on its own.
		/// </para>
		/// <para>The runtime drops calls to state objects other than raytracing pipelines, such as collections.</para>
		/// </remarks>
		// https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12stateobjectproperties-setpipelinestacksize void
		// SetPipelineStackSize( UINT64 PipelineStackSizeInBytes );
		[PreserveSig]
		new void SetPipelineStackSize(ulong PipelineStackSizeInBytes);

		[PreserveSig]
		D3D12_PROGRAM_IDENTIFIER GetProgramIdentifier([MarshalAs(UnmanagedType.LPWStr)] string pProgramName);
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct D3D12_DISPATCH_GRAPH_DESC
	{
		[FieldOffset(0)]
		public D3D12_DISPATCH_MODE Mode;

		[FieldOffset(8)]
		public D3D12_NODE_CPU_INPUT NodeCPUInput;

		[FieldOffset(8)]
		public ulong NodeGPUInput;

		[FieldOffset(8)]
		public D3D12_MULTI_NODE_CPU_INPUT MultiNodeCPUInput;

		[FieldOffset(8)]
		public ulong MultiNodeGPUInput;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_MULTI_NODE_CPU_INPUT
	{
		public uint NumNodeInputs;

		public IntPtr pNodeInputs;

		public ulong NodeInputStrideInBytes;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_NODE_CPU_INPUT
	{
		public uint EntrypointIndex;

		public uint NumRecords;

		public IntPtr pRecords;

		public ulong RecordStrideInBytes;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_PROGRAM_IDENTIFIER
	{
		private unsafe fixed ulong _OpaqueData[4];

		public ulong[] OpaqueData 
		{
			get { unsafe { ulong[] ret = new ulong[4]; for (int i = 0; i < 4; i++) ret[i] = _OpaqueData[i]; return ret; } }
			set { if (value is null || value.Length != 4) throw new ArgumentOutOfRangeException(); unsafe { for (int i = 0; i < 4; i++) _OpaqueData[i] = value[i]; } }
		}
	}

	[PInvokeData("d3d12.h", MSDNShortId = "NS:d3d12.D3D12_SAMPLER_DESC")]
	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_SAMPLER_DESC2
	{
		/// <summary>A <c>D3D12_FILTER</c>-typed value that specifies the filtering method to use when sampling a texture.</summary>
		public D3D12_FILTER Filter;

		/// <summary>
		/// A <c>D3D12_TEXTURE_ADDRESS_MODE</c>-typed value that specifies the method to use for resolving a u texture coordinate that is
		/// outside the 0 to 1 range.
		/// </summary>
		public D3D12_TEXTURE_ADDRESS_MODE AddressU;

		/// <summary>
		/// A <c>D3D12_TEXTURE_ADDRESS_MODE</c>-typed value that specifies the method to use for resolving a v texture coordinate that is
		/// outside the 0 to 1 range.
		/// </summary>
		public D3D12_TEXTURE_ADDRESS_MODE AddressV;

		/// <summary>
		/// A <c>D3D12_TEXTURE_ADDRESS_MODE</c>-typed value that specifies the method to use for resolving a w texture coordinate that is
		/// outside the 0 to 1 range.
		/// </summary>
		public D3D12_TEXTURE_ADDRESS_MODE AddressW;

		/// <summary>
		/// Offset from the calculated mipmap level. For example, if the runtime calculates that a texture should be sampled at mipmap level
		/// 3 and <b>MipLODBias</b> is 2, the texture will be sampled at mipmap level 5.
		/// </summary>
		public float MipLODBias;

		/// <summary>
		/// Clamping value used if <b>D3D12_FILTER_ANISOTROPIC</b> or <b>D3D12_FILTER_COMPARISON_ANISOTROPIC</b> is specified in
		/// <b>Filter</b>. Valid values are between 1 and 16.
		/// </summary>
		public uint MaxAnisotropy;

		/// <summary>
		/// A <c>D3D12_COMPARISON_FUNC</c>-typed value that specifies a function that compares sampled data against existing sampled data.
		/// </summary>
		public D3D12_COMPARISON_FUNC ComparisonFunc;

		/// <summary>
		/// RGBA border color to use if <c>D3D12_TEXTURE_ADDRESS_MODE_BORDER</c> is specified for <b>AddressU</b>, <b>AddressV</b>, or
		/// <b>AddressW</b>. Range must be between 0.0 and 1.0 inclusive.
		/// </summary>
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public float[] FloatBorderColor;

		public uint[] UintBorderColor
		{
			get { unsafe { fixed (float* p = &FloatBorderColor[0]) { return ((IntPtr)p).ToArray<uint>(4) ?? new uint[4]; } } }
			set { if (value is null || value.Length != 4) throw new ArgumentOutOfRangeException(); unsafe { fixed (uint* p = &value[0]) { Marshal.Copy((IntPtr)p, FloatBorderColor, 0, 4); } } }
		}

		/// <summary>
		/// Lower end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher
		/// than that is less detailed.
		/// </summary>
		public float MinLOD;

		/// <summary>
		/// Upper end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher
		/// than that is less detailed. This value must be greater than or equal to <b>MinLOD</b>. To have no upper limit on LOD, set this
		/// member to a large value.
		/// </summary>
		public float MaxLOD;

		public D3D12_SAMPLER_FLAGS Flags;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_SET_GENERIC_PIPELINE_DESC
	{
		public D3D12_PROGRAM_IDENTIFIER ProgramIdentifier;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_SET_PROGRAM_DESC
	{
		public D3D12_PROGRAM_TYPE Type;

		public D3D12_SET_WORK_GRAPH_DESC WorkGraph;

		public D3D12_SET_GENERIC_PIPELINE_DESC GenericPipeline
		{
			get => new() { ProgramIdentifier = WorkGraph.ProgramIdentifier };
			set => WorkGraph = new() { ProgramIdentifier = value.ProgramIdentifier };
		}

		public D3D12_SET_RAYTRACING_PIPELINE_DESC RaytracingPipeline
		{
			get => new() { ProgramIdentifier = WorkGraph.ProgramIdentifier };
			set => WorkGraph = new() { ProgramIdentifier = value.ProgramIdentifier };
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_SET_RAYTRACING_PIPELINE_DESC
	{
		public D3D12_PROGRAM_IDENTIFIER ProgramIdentifier;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_SET_WORK_GRAPH_DESC
	{
		public D3D12_PROGRAM_IDENTIFIER ProgramIdentifier;

		public D3D12_SET_WORK_GRAPH_FLAGS Flags;

		public D3D12_GPU_VIRTUAL_ADDRESS_RANGE BackingMemory;

		public D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE NodeLocalRootArgumentsTable;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_RASTERIZER_DESC2
	{
		public D3D12_FILL_MODE FillMode;
		public D3D12_CULL_MODE CullMode;
		[MarshalAs(UnmanagedType.Bool)]
		public bool FrontCounterClockwise;
		public float DepthBias;
		public float DepthBiasClamp;
		public float SlopeScaledDepthBias;
		[MarshalAs(UnmanagedType.Bool)]
		public bool DepthClipEnable;
		public D3D12_LINE_RASTERIZATION_MODE LineRasterizationMode;
		public uint ForcedSampleCount;
		public D3D12_CONSERVATIVE_RASTERIZATION_MODE ConservativeRaster;
	}

	public enum D3D12_LINE_RASTERIZATION_MODE
	{
		D3D12_LINE_RASTERIZATION_MODE_ALIASED = 0,
		D3D12_LINE_RASTERIZATION_MODE_ALPHA_ANTIALIASED,
		D3D12_LINE_RASTERIZATION_MODE_QUADRILATERAL_WIDE,
		D3D12_LINE_RASTERIZATION_MODE_QUADRILATERAL_NARROW,
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	public struct D3D12_GENERIC_PROGRAM_DESC
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string ProgramName;
		public uint NumExports;
		public ArrayPointer<StrPtrUni> pExports;
		public uint NumSubobjects;
		public ArrayPointer<D3D12_STATE_SUBOBJECT> ppSubobjects;

		/// <summary>Initializes a new instance of the <see cref="D3D12_GENERIC_PROGRAM_DESC"/> struct.</summary>
		public D3D12_GENERIC_PROGRAM_DESC(string programName, [Optional] string[]? exports, [Optional] object[]? subobjects, out SafeAllocatedMemoryHandle memoryHandle)
		{
			SafeCoTaskMemHandle h = new(256);
			NativeMemoryStream ms = new(h);
			ProgramName = programName;
			NumExports = (uint)(exports?.Length ?? 0);
			if (NumExports > 0)
			{
				pExports = ms.Pointer;
				ms.Write(exports!, StringListPackMethod.Packed);
			}
			NumSubobjects = (uint)(subobjects?.Length ?? 0);
			if (NumSubobjects > 0)
			{
				var subs = new D3D12_STATE_SUBOBJECT[(int)NumSubobjects];
				for (int i = 0; i < subs.Length; i++)
				{
					if (!CorrespondingTypeAttribute.CanSet(subobjects![i].GetType(), out D3D12_STATE_SUBOBJECT_TYPE type))
						throw new ArgumentException("Subobject type is not valid.", nameof(subobjects));
					subs[i] = new D3D12_STATE_SUBOBJECT() { Type = type, pDesc = ms.Pointer.Offset(ms.Position) };
					ms.WriteObject(subobjects![i]);
				}
				ppSubobjects = ms.Pointer.Offset(ms.Position);
				ms.Write(subs);
			}
			memoryHandle = h;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_DEPTH_STENCIL_DESC2
	{
		[MarshalAs(UnmanagedType.Bool)]
		public bool DepthEnable;
		public D3D12_DEPTH_WRITE_MASK DepthWriteMask;
		public D3D12_COMPARISON_FUNC DepthFunc;
		[MarshalAs(UnmanagedType.Bool)]
		public bool StencilEnable;
		public D3D12_DEPTH_STENCILOP_DESC1 FrontFace;
		public D3D12_DEPTH_STENCILOP_DESC1 BackFace;
		[MarshalAs(UnmanagedType.Bool)]
		public bool DepthBoundsTestEnable;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_DEPTH_STENCILOP_DESC1
	{
		public D3D12_STENCIL_OP StencilFailOp;
		public D3D12_STENCIL_OP StencilDepthFailOp;
		public D3D12_STENCIL_OP StencilPassOp;
		public D3D12_COMPARISON_FUNC StencilFunc;
		public byte StencilReadMask;
		public byte StencilWriteMask;
	}

	public static void swap<T>(ref T a, ref T b) where T : struct
	{
		T temp = a;
		a = b;
		b = temp;
	}

	public delegate HRESULT DxcCreateInstanceProc(in Guid rclsid, in Guid riid, [MarshalAs(UnmanagedType.Interface, IidParameterIndex = 1)] out object? ppv);

	public enum D3D12_WORK_GRAPHS_TIER
	{
		D3D12_WORK_GRAPHS_TIER_NOT_SUPPORTED = 0,
		D3D12_WORK_GRAPHS_TIER_1_0 = 10
	}

	public enum D3D12_EXECUTE_INDIRECT_TIER
	{
		D3D12_EXECUTE_INDIRECT_TIER_1_0 = 10,
		D3D12_EXECUTE_INDIRECT_TIER_1_1 = 11
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_FEATURE_DATA_D3D12_OPTIONS21
	{
		public D3D12_WORK_GRAPHS_TIER WorkGraphsTier;
		public D3D12_EXECUTE_INDIRECT_TIER ExecuteIndirectTier;
		public BOOL SampleCmpGradientAndBiasSupported;
		public BOOL ExtendedCommandInfoSupported;
	}

	[Flags]
	public enum D3D12_WORK_GRAPH_FLAGS
	{
		D3D12_WORK_GRAPH_FLAG_NONE = 0,
		D3D12_WORK_GRAPH_FLAG_INCLUDE_ALL_AVAILABLE_NODES = 0x1
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_WORK_GRAPH_DESC
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string ProgramName;
		public D3D12_WORK_GRAPH_FLAGS Flags;
		public uint NumEntrypoints;
		public ManagedArrayPointer<D3D12_NODE_ID> pEntrypoints;
		public uint NumExplicitlyDefinedNodes;
		public ManagedArrayPointer<D3D12_NODE> pExplicitlyDefinedNodes;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_NODE_ID
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Name;
		public uint ArrayIndex;
	}

	public enum D3D12_NODE_TYPE
	{
		D3D12_NODE_TYPE_SHADER = 0
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_NODE
	{
		public D3D12_NODE_TYPE NodeType;
		public D3D12_SHADER_NODE Shader;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_NODE_OUTPUT_OVERRIDES
	{
		public uint OutputIndex;
		public ManagedStructPointer<D3D12_NODE_ID> pNewName;
		public StructPointer<BOOL> pAllowSparseNodes;
		public StructPointer<uint> pMaxRecords;
		public StructPointer<uint> pMaxRecordsSharedWithOutputIndex;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_BROADCASTING_LAUNCH_OVERRIDES
	{
		public StructPointer<uint> pLocalRootArgumentsTableIndex;
		public StructPointer<BOOL> pProgramEntry;
		public ManagedStructPointer<D3D12_NODE_ID> pNewName;
		public ManagedStructPointer<D3D12_NODE_ID> pShareInputOf;
		public ArrayPointer<uint> pDispatchGrid;
		public ArrayPointer<uint> pMaxDispatchGrid;
		public uint NumOutputOverrides;
		public ArrayPointer<D3D12_NODE_OUTPUT_OVERRIDES> pOutputOverrides;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_COALESCING_LAUNCH_OVERRIDES
	{
		public StructPointer<uint> pLocalRootArgumentsTableIndex;
		public StructPointer<BOOL> pProgramEntry;
		public ManagedStructPointer<D3D12_NODE_ID> pNewName;
		public ManagedStructPointer<D3D12_NODE_ID> pShareInputOf;
		public uint NumOutputOverrides;
		public ArrayPointer<D3D12_NODE_OUTPUT_OVERRIDES> pOutputOverrides;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_THREAD_LAUNCH_OVERRIDES
	{
		public StructPointer<uint> pLocalRootArgumentsTableIndex;
		public StructPointer<BOOL> pProgramEntry;
		public ManagedStructPointer<D3D12_NODE_ID> pNewName;
		public ManagedStructPointer<D3D12_NODE_ID> pShareInputOf;
		public uint NumOutputOverrides;
		public ArrayPointer<D3D12_NODE_OUTPUT_OVERRIDES> pOutputOverrides;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_COMMON_COMPUTE_NODE_OVERRIDES
	{
		public StructPointer<uint> pLocalRootArgumentsTableIndex;
		public StructPointer<BOOL> pProgramEntry;
		public ManagedStructPointer<D3D12_NODE_ID> pNewName;
		public ManagedStructPointer<D3D12_NODE_ID> pShareInputOf;
		public uint NumOutputOverrides;
		public ArrayPointer<D3D12_NODE_OUTPUT_OVERRIDES> pOutputOverrides;
	}

	public enum D3D12_NODE_OVERRIDES_TYPE
	{
		D3D12_NODE_OVERRIDES_TYPE_NONE = 0,
		D3D12_NODE_OVERRIDES_TYPE_BROADCASTING_LAUNCH = 1,
		D3D12_NODE_OVERRIDES_TYPE_COALESCING_LAUNCH = 2,
		D3D12_NODE_OVERRIDES_TYPE_THREAD_LAUNCH = 3,
		D3D12_NODE_OVERRIDES_TYPE_COMMON_COMPUTE = 4
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_SHADER_NODE
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Shader;
		public D3D12_NODE_OVERRIDES_TYPE OverridesType;
		public IntPtr pOverrides;
		//const D3D12_BROADCASTING_LAUNCH_OVERRIDES* pBroadcastingLaunchOverrides;
		//const D3D12_COALESCING_LAUNCH_OVERRIDES* pCoalescingLaunchOverrides;
		//const D3D12_THREAD_LAUNCH_OVERRIDES* pThreadLaunchOverrides;
		//const D3D12_COMMON_COMPUTE_NODE_OVERRIDES* pCommonComputeNodeOverrides;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS
	{
		public ulong MinSizeInBytes;
		public ulong MaxSizeInBytes;
		public uint SizeGranularityInBytes;
	}

	[ComImport, Guid("065acf71-f863-4b89-82f4-02e4d5886757"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ID3D12WorkGraphProperties
	{
		[PreserveSig]
		uint GetNumWorkGraphs();

		[PreserveSig]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string GetProgramName(uint WorkGraphIndex);

		[PreserveSig]
		uint GetWorkGraphIndex([MarshalAs(UnmanagedType.LPWStr)] string pProgramName);

		[PreserveSig]
		uint GetNumNodes(uint WorkGraphIndex);

		[PreserveSig]
		ManagedStructPointer<D3D12_NODE_ID> GetNodeID(ManagedStructPointer<D3D12_NODE_ID> RetVal, uint WorkGraphIndex, uint NodeIndex);

		[PreserveSig]
		uint GetNodeIndex(uint WorkGraphIndex, D3D12_NODE_ID NodeID);

		[PreserveSig]
		uint GetNodeLocalRootArgumentsTableIndex(uint WorkGraphIndex, uint NodeIndex);

		[PreserveSig]
		uint GetNumEntrypoints(uint WorkGraphIndex);

		[PreserveSig]
		ManagedStructPointer<D3D12_NODE_ID> GetEntrypointID(ManagedStructPointer<D3D12_NODE_ID> RetVal, uint WorkGraphIndex, uint EntrypointIndex);

		[PreserveSig]
		uint GetEntrypointIndex(uint WorkGraphIndex, D3D12_NODE_ID NodeID);

		[PreserveSig]
		uint GetEntrypointRecordSizeInBytes(uint WorkGraphIndex, uint EntrypointIndex);

		[PreserveSig]
		void GetWorkGraphMemoryRequirements(uint WorkGraphIndex, out D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS pWorkGraphMemoryRequirements);

		[PreserveSig]
		uint GetEntrypointRecordAlignmentInBytes(uint WorkGraphIndex, uint EntrypointIndex);
	}
}